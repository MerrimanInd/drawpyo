{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to drawpyo","text":"<p>Drawpyo is a Python library for programmatically generating Draw.io charts. It enables creating a diagram object, placing and styling objects, then writing the object to a file.</p>"},{"location":"#historyjustification","title":"History/Justification","text":"<p>I love Draw.io! Compared to expensive and heavy commercial options like Visio and Miro, Draw.io's free and lightweight app allows wider and more universal distribution of diagrams. Because the files are stored in plaintext they can be versioned alongside code in a repository as documentation. Draw.io also maintains backwards compatibility and any diagram created in the app since it was launched can still be opened. The XML-based file format makes these diagrams semi-portable, and could easily be ported to other applications if Draw.io ever disappeared. For these reason, I think it's one of the best options for documentation diagrams.</p> <p>So when I had a need to generate hierarchical tree diagrams of requirement structures I looked to Draw.io but I was surprised to find there wasn't even a single existing Python library for working with these files. I took the project home and spent a weekend building the initial functionality. I've been adding functionality, robustness, and documentation intermittently since.</p>"},{"location":"#the-future-of-drawpyo","title":"The Future of Drawpyo","text":"<p>We\u2019re constantly working to add new functionality, address issues and feature requests. If you find Drawpyo useful and would like to contribute, we\u2019d greatly appreciate your help! You can reach out directly at xander@merriman.industries or join the conversation through GitHub issues.</p>"},{"location":"about/","title":"Conventions and Naming","text":"<p>This library contains quite a lot of camel case (capitalizeEachWord) attributes. While the Python convention is snake case (underscores_between_lowercase) the Draw.io style strings and attributes are camel case. Wherever possible, drawpyo uses the terminology and variable names from Draw.io to make it more intuitive to work between the two apps. However, any attribute that does not have an analogy in the Draw.io app is snake case. While this is a bit confusing I hope it helps to clarify when there's a direct analog between drawpyo and Draw.io and when the variable is a drawpyo abstraction. If this is confusing please share that feedback on the GitHub page or email and it may be changed in future versions!</p>"},{"location":"about/#basic-diagrams","title":"Basic Diagrams","text":"<p>Drawpyo's basic functionality provides the same features as using the Draw.io app. You can create files with one or more pages, add objects to them, and position those objects. You can style objects from built-in shape libraries, manually, or from style strings. Those objects can be shapes, containers, or edges to connect them. Finally you can save your diagrams where they can be opened with the Draw.io app.</p> <p>See the full documentation for these functions in Basic Diagrams - Usage.</p>"},{"location":"about/#extended-functionality","title":"Extended Functionality","text":"<p>Drawpyo extends the basic functionality of the Draw.io app with custom diagram types. These custom diagrams have automated styling and layouting to make common or complex diagrams easier to generate.</p>"},{"location":"about/#treediagram","title":"TreeDiagram","text":"<p>This diagram makes creating directed tree graphs easy. Define trees, nodes, and the apply an auto layout.</p> <p>Documentation</p>"},{"location":"about/#barchart","title":"BarChart","text":"<p>Useful visualization to compare the absolute size of different categories.</p> <p>Documentation</p>"},{"location":"about/#piechart","title":"PieChart","text":"<p>Useful visualization to compare the relative size of different categories.</p> <p>Documentation</p>"},{"location":"api/architecture/","title":"Architecture","text":"<p>Drawpyo provides two high level classes to define critical methods and attributes for all  exportable Draw.io objects. Primarily they define the parent and id attributes as well as a series of methods and properties for generating XML and style strings.</p>"},{"location":"api/architecture/#xmlbase","title":"XMLBase","text":"<p>XMLBase is the base class for all exportable objects in drawpyo. This class defines a few useful properties that drawpyo needs to use to generate a Draw.io file.</p> Source code in <code>src/drawpyo/xml_base.py</code> <pre><code>class XMLBase:\n    \"\"\"\n    XMLBase is the base class for all exportable objects in drawpyo. This class defines a few useful properties that drawpyo needs to use to generate a Draw.io file.\n    \"\"\"\n\n    def __init__(self, **kwargs: Any) -&gt; None:\n        self._id: Union[int, str] = kwargs.get(\"id\", id(self))\n        self.xml_class: str = kwargs.get(\"xml_class\", \"xml_tag\")\n\n        # There's only one situation where XMLBase is called directly: to\n        # create the two empty mxCell objects at the beginning of every\n        # Draw.io diagram. The following declarations should be overwritten\n        # in every other use case.\n        self.xml_parent: Optional[Any] = kwargs.get(\"xml_parent\", None)\n\n        self.tag: Optional[str] = kwargs.get(\"tag\", None)\n        self.tooltip: Optional[str] = kwargs.get(\"tooltip\", None)\n\n    @property\n    def id(self) -&gt; Union[int, str]:\n        \"\"\"\n        id is a unique identifier. Draw.io generated diagrams use an ID many more characters but the app isn't picky when parsing so drawpyo just uses Python's built-in id() function as it guarantees unique identifiers.\n\n        Returns:\n            int: A unique identifier for the Draw.io object\n        \"\"\"\n        return self._id\n\n    @property\n    def attributes(self) -&gt; Dict[str, Any]:\n        \"\"\"\n        The most basic attributes of a Draw.io object. Extended by subclasses.\n\n        Returns:\n            dict: A dict containing an 'id' and 'xml_parent' object.\n        \"\"\"\n        return {\"id\": self.id, \"parent\": self.xml_parent}\n\n    ###########################################################\n    # XML Tags\n    ###########################################################\n\n    @property\n    def xml_open_tag(self) -&gt; str:\n        \"\"\"\n        The open tag contains the name of the object but also the attribute tags. This property function concatenates all the attributes in the class along with the opening and closing angle brackets and returns them as a string.\n\n        When the \"tag\" attribute tag is provided, a tags attribute is applied to the object. This allows for selecting, hiding, or displaying multiple elements in the diagram.\n        When the \"tooltip\" attribute tag is provided, a tooltip attribute is applied to the object. This allows for extra information to be displayed when an element is hovered over in the diagram.\n        When using tags or tooltips, the open_tag value and id are shifted to the &lt;UserObject&gt; tag.\n\n\n        Example:\n        &lt;class_name attribute_name=attribute_value&gt;\n\n        Returns:\n            str: The opening tag of the object with all the attributes.\n        \"\"\"\n        if self.tag or self.tooltip:\n            open_user_object_tag = f'&lt;UserObject label=\"{self.value}\" id=\"{self.id}\"'\n            if self.tag:\n                open_user_object_tag += f' tags=\"{self.tag}\"'\n            if self.tooltip:\n                open_user_object_tag += f' tooltip=\"{self.xml_ify(self.tooltip)}\"'\n            open_user_object_tag += \"&gt;\"\n\n            open_tag = \"&lt;\" + self.xml_class\n            for att, value in self.attributes.items():\n                if att == \"id\" or att == \"value\":\n                    continue\n                if value is not None:\n                    xml_parameter = self.xml_ify(str(value))\n                    open_tag = open_tag + \" \" + att + '=\"' + xml_parameter + '\"'\n            return open_user_object_tag + \"\\n\" + open_tag + \"&gt;\"\n        open_tag = \"&lt;\" + self.xml_class\n        for att, value in self.attributes.items():\n            if value is not None:\n                xml_parameter = self.xml_ify(str(value))\n                open_tag = open_tag + \" \" + att + '=\"' + xml_parameter + '\"'\n        return open_tag + \"&gt;\"\n\n    @property\n    def xml_close_tag(self) -&gt; str:\n        \"\"\"\n        The closing tag contains the name of the object wrapped in angle brackets.\n\n        Example:\n        &lt;/class_name&gt;\n\n        Returns:\n            str: The closing tag of the object with all the attributes.\n        \"\"\"\n        if self.tag or self.tooltip:\n            return \"&lt;/{0}&gt;\\n&lt;/UserObject&gt;\".format(self.xml_class)\n        return \"&lt;/{0}&gt;\".format(self.xml_class)\n\n    @property\n    def xml(self) -&gt; str:\n        \"\"\"\n        All drawpyo exportable classes contain an xml property that returns the formatted string of their XML output.\n\n        This default version of the function assumes no inner value so it just returns the opening tag closed with a '/&gt;'. Subclasses that require more printing overload this function with their own implementation.\n\n        Example:\n        &lt;class_name attribute_name=attribute_value/&gt;\n\n        Returns:\n            str: A single XML tag containing the object name, style attributes, and a closer.\n        \"\"\"\n        return self.xml_open_tag[:-1] + \" /&gt;\"\n\n    def xml_ify(self, parameter_string: str) -&gt; str:\n        return self.translate_txt(parameter_string, xmlize)\n\n    @staticmethod\n    def translate_txt(string: str, replacement_dict: Dict[str, str]) -&gt; str:\n        new_str = \"\"\n        for char in string:\n            if char in replacement_dict:\n                new_str = new_str + replacement_dict[char]\n            else:\n                new_str = new_str + char\n        return new_str\n</code></pre>"},{"location":"api/architecture/#src.drawpyo.xml_base.XMLBase.attributes","title":"<code>attributes</code>  <code>property</code>","text":"<p>The most basic attributes of a Draw.io object. Extended by subclasses.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>Dict[str, Any]</code> <p>A dict containing an 'id' and 'xml_parent' object.</p>"},{"location":"api/architecture/#src.drawpyo.xml_base.XMLBase.id","title":"<code>id</code>  <code>property</code>","text":"<p>id is a unique identifier. Draw.io generated diagrams use an ID many more characters but the app isn't picky when parsing so drawpyo just uses Python's built-in id() function as it guarantees unique identifiers.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>Union[int, str]</code> <p>A unique identifier for the Draw.io object</p>"},{"location":"api/architecture/#src.drawpyo.xml_base.XMLBase.xml","title":"<code>xml</code>  <code>property</code>","text":"<p>All drawpyo exportable classes contain an xml property that returns the formatted string of their XML output.</p> <p>This default version of the function assumes no inner value so it just returns the opening tag closed with a '/&gt;'. Subclasses that require more printing overload this function with their own implementation.</p> <p>Example:  <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A single XML tag containing the object name, style attributes, and a closer.</p>"},{"location":"api/architecture/#src.drawpyo.xml_base.XMLBase.xml_close_tag","title":"<code>xml_close_tag</code>  <code>property</code>","text":"<p>The closing tag contains the name of the object wrapped in angle brackets.</p> <p>Example: </p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The closing tag of the object with all the attributes.</p>"},{"location":"api/architecture/#src.drawpyo.xml_base.XMLBase.xml_open_tag","title":"<code>xml_open_tag</code>  <code>property</code>","text":"<p>The open tag contains the name of the object but also the attribute tags. This property function concatenates all the attributes in the class along with the opening and closing angle brackets and returns them as a string.</p> <p>When the \"tag\" attribute tag is provided, a tags attribute is applied to the object. This allows for selecting, hiding, or displaying multiple elements in the diagram. When the \"tooltip\" attribute tag is provided, a tooltip attribute is applied to the object. This allows for extra information to be displayed when an element is hovered over in the diagram. When using tags or tooltips, the open_tag value and id are shifted to the  tag. <p>Example:  <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The opening tag of the object with all the attributes.</p>"},{"location":"api/architecture/#diagrambase","title":"DiagramBase","text":"<p>               Bases: <code>XMLBase</code></p> <p>This class is the base for all diagram objects to inherit from. It defines some general creation methods and properties to make diagram objects printable and useful.</p> Source code in <code>src/drawpyo/diagram/base_diagram.py</code> <pre><code>class DiagramBase(XMLBase):\n    \"\"\"\n    This class is the base for all diagram objects to inherit from. It defines some general creation methods and properties to make diagram objects printable and useful.\n    \"\"\"\n\n    def __init__(self, **kwargs: Any) -&gt; None:\n        super().__init__(**kwargs)\n        self._style_attributes: List[str] = [\"html\"]\n        self.page: Optional[Any] = kwargs.get(\"page\", None)\n        self.xml_parent: Optional[DiagramBase] = kwargs.get(\"xml_parent\", None)\n\n    @classmethod\n    def create_from_library(cls, library: Dict[str, Any], obj: str) -&gt; DiagramBase:\n        return cls()\n\n    # XML_parent property\n    @property\n    def xml_parent_id(self) -&gt; int:\n        if self.xml_parent is not None:\n            return self.xml_parent.id\n        else:\n            return 1\n\n    # Parent object linking\n    @property\n    def xml_parent(self) -&gt; Optional[DiagramBase]:\n        return self._xml_parent\n\n    @xml_parent.setter\n    def xml_parent(self, p: Optional[DiagramBase]) -&gt; None:\n        if p is not None:\n            p.add_object(self)\n            self._xml_parent = p\n        else:\n            self._xml_parent = None\n\n    @xml_parent.deleter\n    def xml_parent(self) -&gt; None:\n        self._xml_parent.remove_object(self)\n        self._xml_parent = None\n\n    # Page property\n    @property\n    def page_id(self) -&gt; int:\n        if self.page is not None:\n            return self.page.id\n        else:\n            return 1\n\n    # page object linking\n    @property\n    def page(self) -&gt; Optional[Any]:\n        return self._page\n\n    @page.setter\n    def page(self, p: Optional[Any]) -&gt; None:\n        if p is not None:\n            p.add_object(self)\n            self._page = p\n        else:\n            self._page = None\n\n    @page.deleter\n    def page(self) -&gt; None:\n        self._page.remove_object(self)\n        self._page = None\n\n    def add_object(self, obj: DiagramBase) -&gt; None:\n        self.page.add_object(obj)\n\n    ###########################################################\n    # Style properties\n    ###########################################################\n    def add_style_attribute(self, style_attr: str) -&gt; None:\n        if style_attr not in self._style_attributes:\n            self._style_attributes.append(style_attr)\n\n    @property\n    def style_attributes(self) -&gt; List[str]:\n        \"\"\"\n        The style attributes are the list of style tags that should be printed into the style XML attribute. This is a subset of the attributes defined on the object method.\n\n        Returns:\n            list: A list of the names of the style_attributes.\n        \"\"\"\n        return self._style_attributes\n\n    @style_attributes.setter\n    def style_attributes(self, value: List[str]) -&gt; None:\n        self._style_attributes = value\n\n    @property\n    def style(self) -&gt; str:\n        \"\"\"\n        This function returns the style string of the object to be appended into the style XML attribute.\n\n        First it searches the object properties called out in\n        self.style_attributes. If the property is initialized to something\n        that isn't None or an empty string, it will add it. Otherwise it\n        searches the base_style defined by the object template.\n\n        Returns:\n            str: The style string of the object.\n\n        \"\"\"\n\n        style_str = \"\"\n        if (\n            hasattr(self, \"baseStyle\")\n            and getattr(self, \"baseStyle\") is not None\n            and getattr(self, \"baseStyle\") != \"\"\n        ):\n            style_str = getattr(self, \"baseStyle\") + \";\"\n\n        # Add style attributes\n        for attribute in self.style_attributes:\n            if hasattr(self, attribute) and getattr(self, attribute) is not None:\n                attr_val = getattr(self, attribute)\n                # reformat different datatypes to strings\n                if isinstance(attr_val, bool):\n                    attr_val = format(attr_val * 1)\n                style_str = style_str + \"{0}={1};\".format(attribute, attr_val)\n\n        # Add style objects\n        if hasattr(self, \"text_format\") and self.text_format is not None:\n            style_str = style_str + self.text_format.style\n        return style_str\n\n    def _add_and_set_style_attrib(self, attrib: str, value: Any) -&gt; None:\n        if hasattr(self, attrib):\n            setattr(self, attrib, value)\n        else:\n            setattr(self, attrib, value)\n            self.add_style_attribute(attrib)\n\n    def apply_style_string(self, style_str: str) -&gt; None:\n        \"\"\"\n        This function will apply a passed in style string to the object. This style string can be obtained from the Draw.io app by selecting Edit Style from the context menu of any object. This function will iterate through the attributes in the style string and assign the corresponding property the value.\n\n        Args:\n            style_str (str): A Draw.io style string\n        \"\"\"\n        for attrib in style_str.split(\";\"):\n            if attrib == \"\":\n                pass\n            elif \"=\" in attrib:\n                a_name = attrib.split(\"=\")[0]\n                a_value = attrib.split(\"=\")[1]\n                if a_value.isdigit():\n                    if \".\" in a_value:\n                        a_value = float(a_value)\n                    else:\n                        a_value = int(a_value)\n                elif a_value == \"True\" or a_value == \"False\":\n                    a_value = bool(a_value)\n\n                self._add_and_set_style_attrib(a_name, a_value)\n            else:\n                self.baseStyle = attrib\n\n    def _apply_style_from_template(self, template: DiagramBase) -&gt; None:\n        for attrib in template.style_attributes:\n            value = getattr(template, attrib)\n            self._add_and_set_style_attrib(attrib, value)\n\n    def apply_attribute_dict(self, attr_dict: Dict[str, Any]) -&gt; None:\n        \"\"\"\n        This function takes in a dictionary of attributes and applies them\n        to the object. These attributes can be style or properties. If the\n        attribute isn't already defined as a property of the class it's\n        assumed to be a style attribute. It will then be added as a property\n        and also appended to the .style_attributes list.\n\n        Parameters\n        ----------\n        attr_dict : dict\n            A dictionary of attributes to set or add to the object.\n\n        Returns\n        -------\n        None.\n\n        \"\"\"\n        for attr, val in attr_dict.items():\n            self._add_and_set_style_attrib(attr, val)\n\n    @classmethod\n    def from_style_string(cls, style_string: str) -&gt; DiagramBase:\n        \"\"\"\n        This classmethod allows the intantiation of an object from a style\n        string. This is useful since Draw.io allows copying the style string\n        out of an object in their UI. This string can then be copied into the\n        Python environment and further objects created that match the style.\n\n        Args:\n            style_string (str): A Draw.io style string\n\n        Returns:\n            DiagramBase: A DiagramBase or subclass instantiated with the style from the Draw.io string\n        \"\"\"\n        new_obj = cls()\n        new_obj.apply_style_string(style_string)\n        return new_obj\n</code></pre>"},{"location":"api/architecture/#src.drawpyo.diagram.base_diagram.DiagramBase.style","title":"<code>style</code>  <code>property</code>","text":"<p>This function returns the style string of the object to be appended into the style XML attribute.</p> <p>First it searches the object properties called out in self.style_attributes. If the property is initialized to something that isn't None or an empty string, it will add it. Otherwise it searches the base_style defined by the object template.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The style string of the object.</p>"},{"location":"api/architecture/#src.drawpyo.diagram.base_diagram.DiagramBase.style_attributes","title":"<code>style_attributes</code>  <code>property</code> <code>writable</code>","text":"<p>The style attributes are the list of style tags that should be printed into the style XML attribute. This is a subset of the attributes defined on the object method.</p> <p>Returns:</p> Name Type Description <code>list</code> <code>List[str]</code> <p>A list of the names of the style_attributes.</p>"},{"location":"api/architecture/#src.drawpyo.diagram.base_diagram.DiagramBase.apply_attribute_dict","title":"<code>apply_attribute_dict(attr_dict)</code>","text":"<p>This function takes in a dictionary of attributes and applies them to the object. These attributes can be style or properties. If the attribute isn't already defined as a property of the class it's assumed to be a style attribute. It will then be added as a property and also appended to the .style_attributes list.</p>"},{"location":"api/architecture/#src.drawpyo.diagram.base_diagram.DiagramBase.apply_attribute_dict--parameters","title":"Parameters","text":"<p>attr_dict : dict     A dictionary of attributes to set or add to the object.</p>"},{"location":"api/architecture/#src.drawpyo.diagram.base_diagram.DiagramBase.apply_attribute_dict--returns","title":"Returns","text":"<p>None.</p> Source code in <code>src/drawpyo/diagram/base_diagram.py</code> <pre><code>def apply_attribute_dict(self, attr_dict: Dict[str, Any]) -&gt; None:\n    \"\"\"\n    This function takes in a dictionary of attributes and applies them\n    to the object. These attributes can be style or properties. If the\n    attribute isn't already defined as a property of the class it's\n    assumed to be a style attribute. It will then be added as a property\n    and also appended to the .style_attributes list.\n\n    Parameters\n    ----------\n    attr_dict : dict\n        A dictionary of attributes to set or add to the object.\n\n    Returns\n    -------\n    None.\n\n    \"\"\"\n    for attr, val in attr_dict.items():\n        self._add_and_set_style_attrib(attr, val)\n</code></pre>"},{"location":"api/architecture/#src.drawpyo.diagram.base_diagram.DiagramBase.apply_style_string","title":"<code>apply_style_string(style_str)</code>","text":"<p>This function will apply a passed in style string to the object. This style string can be obtained from the Draw.io app by selecting Edit Style from the context menu of any object. This function will iterate through the attributes in the style string and assign the corresponding property the value.</p> <p>Parameters:</p> Name Type Description Default <code>style_str</code> <code>str</code> <p>A Draw.io style string</p> required Source code in <code>src/drawpyo/diagram/base_diagram.py</code> <pre><code>def apply_style_string(self, style_str: str) -&gt; None:\n    \"\"\"\n    This function will apply a passed in style string to the object. This style string can be obtained from the Draw.io app by selecting Edit Style from the context menu of any object. This function will iterate through the attributes in the style string and assign the corresponding property the value.\n\n    Args:\n        style_str (str): A Draw.io style string\n    \"\"\"\n    for attrib in style_str.split(\";\"):\n        if attrib == \"\":\n            pass\n        elif \"=\" in attrib:\n            a_name = attrib.split(\"=\")[0]\n            a_value = attrib.split(\"=\")[1]\n            if a_value.isdigit():\n                if \".\" in a_value:\n                    a_value = float(a_value)\n                else:\n                    a_value = int(a_value)\n            elif a_value == \"True\" or a_value == \"False\":\n                a_value = bool(a_value)\n\n            self._add_and_set_style_attrib(a_name, a_value)\n        else:\n            self.baseStyle = attrib\n</code></pre>"},{"location":"api/architecture/#src.drawpyo.diagram.base_diagram.DiagramBase.from_style_string","title":"<code>from_style_string(style_string)</code>  <code>classmethod</code>","text":"<p>This classmethod allows the intantiation of an object from a style string. This is useful since Draw.io allows copying the style string out of an object in their UI. This string can then be copied into the Python environment and further objects created that match the style.</p> <p>Parameters:</p> Name Type Description Default <code>style_string</code> <code>str</code> <p>A Draw.io style string</p> required <p>Returns:</p> Name Type Description <code>DiagramBase</code> <code>DiagramBase</code> <p>A DiagramBase or subclass instantiated with the style from the Draw.io string</p> Source code in <code>src/drawpyo/diagram/base_diagram.py</code> <pre><code>@classmethod\ndef from_style_string(cls, style_string: str) -&gt; DiagramBase:\n    \"\"\"\n    This classmethod allows the intantiation of an object from a style\n    string. This is useful since Draw.io allows copying the style string\n    out of an object in their UI. This string can then be copied into the\n    Python environment and further objects created that match the style.\n\n    Args:\n        style_string (str): A Draw.io style string\n\n    Returns:\n        DiagramBase: A DiagramBase or subclass instantiated with the style from the Draw.io string\n    \"\"\"\n    new_obj = cls()\n    new_obj.apply_style_string(style_string)\n    return new_obj\n</code></pre>"},{"location":"api/color_scheme/","title":"Color Scheme","text":""},{"location":"api/color_scheme/#src.drawpyo.utils.color_scheme.ColorScheme","title":"<code>src.drawpyo.utils.color_scheme.ColorScheme</code>","text":"<p>Represents a set of colors used for an object's fill, stroke and font.</p> A color can be <p>\u2022 None \u2022 A hex string \u2022 A DefaultColor</p> Source code in <code>src/drawpyo/utils/color_scheme.py</code> <pre><code>class ColorScheme:\n    \"\"\"\n    Represents a set of colors used for an object's fill, stroke and font.\n\n    A color can be:\n        \u2022 None\n        \u2022 A hex string\n        \u2022 A DefaultColor\n    \"\"\"\n\n    HEX_PATTERN = re.compile(r\"^#[0-9A-Fa-f]{6}$\")\n\n    ###########################################################\n    # Initialization\n    ###########################################################\n\n    def __init__(\n        self,\n        fill_color: ColorType = None,\n        stroke_color: ColorType = None,\n        font_color: ColorType = None,\n    ) -&gt; None:\n        self.fill_color: ColorType = self._validated(fill_color)\n        self.stroke_color: ColorType = self._validated(stroke_color)\n        self.font_color: ColorType = self._validated(font_color)\n        logger.info(f\"\ud83c\udfa8 ColorScheme created: {self.__repr__()}\")\n\n    ###########################################################\n    # Public Setters\n    ###########################################################\n\n    def set_fill_color(self, color: ColorType) -&gt; None:\n        self.fill_color = self._validated(color)\n\n    def set_stroke_color(self, color: ColorType) -&gt; None:\n        self.stroke_color = self._validated(color)\n\n    def set_font_color(self, color: ColorType) -&gt; None:\n        self.font_color = self._validated(color)\n\n    ###########################################################\n    # Validation\n    ###########################################################\n\n    def _validated(self, color: ColorType) -&gt; ColorType:\n        \"\"\"Validate hex strings or DefaultColor enums.\"\"\"\n        if color is None:\n            return None\n\n        if isinstance(color, StandardColor):\n            return color.value\n\n        if isinstance(color, str):\n            if not self.is_valid_hex(color):\n                raise ValueError(\n                    f\"Invalid color '{color}'. \"\n                    f\"Expected '#RRGGBB' (example: #A1B2C3).\"\n                )\n            return color.upper()\n\n        raise TypeError(\n            f\"Color must be a hex string like '#AABBCC', None, or a DefaultColor enum. \"\n            f\"Received: {type(color)}\"\n        )\n\n    @classmethod\n    def is_valid_hex(cls, value: str) -&gt; bool:\n        \"\"\"Return True if string is a valid #RRGGBB hex color.\"\"\"\n        return bool(cls.HEX_PATTERN.match(value))\n\n    ###########################################################\n    # Utility\n    ###########################################################\n\n    def __repr__(self) -&gt; str:\n        return (\n            f\"fill: {self.fill_color} \"\n            f\"| stroke: {self.stroke_color} \"\n            f\"| font: {self.font_color}\"\n        )\n</code></pre>"},{"location":"api/color_scheme/#src.drawpyo.utils.color_scheme.ColorScheme.is_valid_hex","title":"<code>is_valid_hex(value)</code>  <code>classmethod</code>","text":"<p>Return True if string is a valid #RRGGBB hex color.</p> Source code in <code>src/drawpyo/utils/color_scheme.py</code> <pre><code>@classmethod\ndef is_valid_hex(cls, value: str) -&gt; bool:\n    \"\"\"Return True if string is a valid #RRGGBB hex color.\"\"\"\n    return bool(cls.HEX_PATTERN.match(value))\n</code></pre>"},{"location":"api/edges/","title":"Edges","text":""},{"location":"api/edges/#src.drawpyo.diagram.edges.Edge","title":"<code>src.drawpyo.diagram.edges.Edge</code>","text":"<p>               Bases: <code>DiagramBase</code></p> <p>The Edge class is the simplest class for defining an edge or an arrow in a Draw.io diagram.</p> <p>The three primary styling inputs are the waypoints, connections, and pattern. These are how edges are styled in the Draw.io app, with dropdown menus for each one. But it's not how the style string is assembled in the XML. To abstract this, the Edge class loads a database called edge_styles.toml. The database maps the options in each dropdown to the style strings they correspond to. The Edge class then assembles the style strings on export.</p> <p>More information about edges are in the Usage documents at Usage - Edges.</p> Source code in <code>src/drawpyo/diagram/edges.py</code> <pre><code>class Edge(DiagramBase):\n    \"\"\"The Edge class is the simplest class for defining an edge or an arrow in a Draw.io diagram.\n\n    The three primary styling inputs are the waypoints, connections, and pattern. These are how edges are styled in the Draw.io app, with dropdown menus for each one. But it's not how the style string is assembled in the XML. To abstract this, the Edge class loads a database called edge_styles.toml. The database maps the options in each dropdown to the style strings they correspond to. The Edge class then assembles the style strings on export.\n\n    More information about edges are in the Usage documents at [Usage - Edges](../../usage/edges).\n    \"\"\"\n\n    def __init__(self, **kwargs: Any) -&gt; None:\n        \"\"\"Edges can be initialized with almost all styling parameters as args.\n        See [Usage - Edges](../../usage/edges) for more information and the options for each parameter.\n\n        Args:\n            source (DiagramBase): The Draw.io object that the edge originates from\n            target (DiagramBase): The Draw.io object that the edge points to\n            label (str): The text to place on the edge.\n            label_position (float): Where along the edge the label is positioned. -1 is the source, 1 is the target, 0 is the center\n            label_offset (int): How far the label is offset away from the axis of the edge in pixels\n            waypoints (str): How the edge should be styled in Draw.io\n            connection (str): What type of style the edge should be rendered with\n            pattern (str): How the line of the edge should be rendered\n            shadow (bool, optional): Add a shadow to the edge\n            rounded (bool): Whether the corner of the line should be rounded\n            flowAnimation (bool): Add a marching ants animation along the edge\n            sketch (bool, optional): Add sketch styling to the edge\n            line_end_target (str): What graphic the edge should be rendered with at the target\n            line_end_source (str): What graphic the edge should be rendered with at the source\n            endFill_target (boolean): Whether the target graphic should be filled\n            endFill_source (boolean): Whether the source graphic should be filled\n            endSize (int): The size of the end arrow in points\n            startSize (int): The size of the start arrow in points\n            jettySize (str or int): Length of the straight sections at the end of the edge. \"auto\" or a number\n            targetPerimeterSpacing (int): The negative or positive spacing between the target and end of the edge (points)\n            sourcePerimeterSpacing (int): The negative or positive spacing between the source and end of the edge (points)\n            entryX (int): From where along the X axis on the source object the edge originates (0-1)\n            entryY (int): From where along the Y axis on the source object the edge originates (0-1)\n            entryDx (int): Applies an offset in pixels to the X axis entry point\n            entryDy (int): Applies an offset in pixels to the Y axis entry point\n            exitX (int): From where along the X axis on the target object the edge originates (0-1)\n            exitY (int): From where along the Y axis on the target object the edge originates (0-1)\n            exitDx (int): Applies an offset in pixels to the X axis exit point\n            exitDy (int): Applies an offset in pixels to the Y axis exit point\n            color_scheme (ColorScheme, optional): Bundled set of color specifications. Defaults to None.\n            strokeColor (str): The color of the border of the edge ('none', 'default', or hex color code)\n            strokeWidth (int): The width of the border of the the edge within range (1-999)\n            fillColor (str): The color of the fill of the edge ('none', 'default', or hex color code)\n            jumpStyle (str): The line jump style ('arc', 'gap', 'sharp', 'line')\n            jumpSize (int): The size of the line jumps in points.\n            opacity (int): The opacity of the edge (0-100)\n        \"\"\"\n        super().__init__(**kwargs)\n        self.xml_class: str = \"mxCell\"\n\n        # Style\n        self.color_scheme: Optional[ColorScheme] = kwargs.get(\"color_scheme\", None)\n        self.text_format: Optional[TextFormat] = kwargs.get(\"text_format\", TextFormat())\n        if not self.text_format.fontColor and self.color_scheme:\n            self.text_format.fontColor = self.color_scheme.font_color\n        self.waypoints: Optional[str] = kwargs.get(\"waypoints\", \"orthogonal\")\n        self.connection: Optional[str] = kwargs.get(\"connection\", \"line\")\n        self.pattern: Optional[str] = kwargs.get(\"pattern\", \"solid\")\n        self.opacity: Optional[int] = kwargs.get(\"opacity\", None)\n        self.strokeWidth: Optional[int] = kwargs.get(\"strokeWidth\", None)\n        self.strokeColor: Optional[Union[str, StandardColor]] = kwargs.get(\n            \"stroke_color\"\n        ) or (self.color_scheme.stroke_color if self.color_scheme else None)\n        self.fillColor: Optional[Union[str, StandardColor]] = kwargs.get(\n            \"fill_color\"\n        ) or (self.color_scheme.fill_color if self.color_scheme else None)\n\n        # Line end\n        self.line_end_target: Optional[str] = kwargs.get(\"line_end_target\", None)\n        self.line_end_source: Optional[str] = kwargs.get(\"line_end_source\", None)\n        self.endFill_target: bool = kwargs.get(\"endFill_target\", False)\n        self.endFill_source: bool = kwargs.get(\"endFill_source\", False)\n        self.endSize: Optional[int] = kwargs.get(\"endSize\", None)\n        self.startSize: Optional[int] = kwargs.get(\"startSize\", None)\n\n        self.rounded: int = kwargs.get(\"rounded\", 0)\n        self.sketch: Optional[bool] = kwargs.get(\"sketch\", None)\n        self.shadow: Optional[bool] = kwargs.get(\"shadow\", None)\n        self.flowAnimation: Optional[bool] = kwargs.get(\"flowAnimation\", None)\n\n        self._jumpStyle: Optional[str] = None\n        self.jumpStyle = kwargs.get(\"jumpStyle\", None)\n        self.jumpSize: Optional[int] = kwargs.get(\"jumpSize\", None)\n\n        # Connection and geometry\n        self.jettySize: Union[str, int] = kwargs.get(\"jettySize\", \"auto\")\n        self.geometry: EdgeGeometry = EdgeGeometry()\n        self.edge: int = kwargs.get(\"edge\", 1)\n        self.targetPerimeterSpacing: Optional[int] = kwargs.get(\n            \"targetPerimeterSpacing\", None\n        )\n        self.sourcePerimeterSpacing: Optional[int] = kwargs.get(\n            \"sourcePerimeterSpacing\", None\n        )\n        self._source: Optional[DiagramBase] = None\n        self.source = kwargs.get(\"source\", None)\n        self._target: Optional[DiagramBase] = None\n        self.target = kwargs.get(\"target\", None)\n        self.entryX: Optional[float] = kwargs.get(\"entryX\", None)\n        self.entryY: Optional[float] = kwargs.get(\"entryY\", None)\n        self.entryDx: Optional[int] = kwargs.get(\"entryDx\", None)\n        self.entryDy: Optional[int] = kwargs.get(\"entryDy\", None)\n        self.exitX: Optional[float] = kwargs.get(\"exitX\", None)\n        self.exitY: Optional[float] = kwargs.get(\"exitY\", None)\n        self.exitDx: Optional[int] = kwargs.get(\"exitDx\", None)\n        self.exitDy: Optional[int] = kwargs.get(\"exitDy\", None)\n\n        # Label\n        self.label: Optional[str] = kwargs.get(\"label\", None)\n        self.edge_axis_offset: Optional[int] = kwargs.get(\"edge_offset\", None)\n        self.label_offset: Optional[int] = kwargs.get(\"label_offset\", None)\n        self.label_position: Optional[float] = kwargs.get(\"label_position\", None)\n\n        logger.debug(f\"\u27a1\ufe0f Edge created: {self.__repr__()}\")\n\n    def __repr__(self) -&gt; str:\n        \"\"\"\n        A concise and informative representation of the edge for debugging.\n        \"\"\"\n        cls = self.__class__.__name__\n        parts = []\n\n        # Source/Target\n        parts.append(f\"source: '{self.source.value if self.source else None}'\")\n        parts.append(f\"target: '{self.target.value if self.target else None}'\")\n\n        # Label\n        if self.label:\n            parts.append(f\"label={self.label!r}\")\n\n        # Entry/Exit geometry (only show if anything is set)\n        geom_parts = []\n        for attr in (\n            \"entryX\",\n            \"entryY\",\n            \"entryDx\",\n            \"entryDy\",\n            \"exitX\",\n            \"exitY\",\n            \"exitDx\",\n            \"exitDy\",\n        ):\n            val = getattr(self, attr, None)\n            if val not in (None, 0):\n                geom_parts.append(f\"{attr}={val}\")\n        if geom_parts:\n            parts.append(\"geom={\" + \", \".join(geom_parts) + \"}\")\n\n        return f\"{cls}(\" + \", \".join(parts) + \")\"\n\n    def __str__(self) -&gt; str:\n        return self.__repr__()\n\n    def remove(self) -&gt; None:\n        \"\"\"This function removes references to the Edge from its source and target objects then deletes the Edge.\"\"\"\n        if self.source is not None:\n            self.source.remove_out_edge(self)\n        if self.target is not None:\n            self.target.remove_in_edge(self)\n        del self\n\n    @property\n    def attributes(self) -&gt; Dict[str, Any]:\n        \"\"\"Returns the XML attributes to be added to the tag for the object\n\n        Returns:\n            dict: Dictionary of object attributes and their values\n        \"\"\"\n        base_attr_dict: Dict[str, Any] = {\n            \"id\": self.id,\n            \"style\": self.style,\n            \"edge\": self.edge,\n            \"parent\": self.xml_parent_id,\n            \"source\": self.source_id,\n            \"target\": self.target_id,\n        }\n        if self.value is not None:\n            base_attr_dict[\"value\"] = self.value\n        return base_attr_dict\n\n    ###########################################################\n    # Source and Target Linking\n    ###########################################################\n\n    # Source\n    @property\n    def source(self) -&gt; Optional[DiagramBase]:\n        \"\"\"The source object of the edge. Automatically adds the edge to the object when set and removes it when deleted.\n\n        Returns:\n            BaseDiagram: source object of the edge\n        \"\"\"\n        return self._source\n\n    @source.setter\n    def source(self, f: Optional[DiagramBase]) -&gt; None:\n        if f is not None:\n            f.add_out_edge(self)\n            self._source = f\n\n    @source.deleter\n    def source(self) -&gt; None:\n        self._source.remove_out_edge(self)\n        self._source = None\n\n    @property\n    def source_id(self) -&gt; Union[int, Any]:\n        \"\"\"The ID of the source object or 1 if no source is set\n\n        Returns:\n            int: Source object ID\n        \"\"\"\n        if self.source is not None:\n            return self.source.id\n        else:\n            return 1\n\n    # Target\n    @property\n    def target(self) -&gt; Optional[DiagramBase]:\n        \"\"\"The target object of the edge. Automatically adds the edge to the object when set and removes it when deleted.\n\n        Returns:\n            BaseDiagram: target object of the edge\n        \"\"\"\n        return self._target\n\n    @target.setter\n    def target(self, f: Optional[DiagramBase]) -&gt; None:\n        if f is not None:\n            f.add_in_edge(self)\n            self._target = f\n\n    @target.deleter\n    def target(self) -&gt; None:\n        self._target.remove_in_edge(self)\n        self._target = None\n\n    @property\n    def target_id(self) -&gt; Union[int, Any]:\n        \"\"\"The ID of the target object or 1 if no target is set\n\n        Returns:\n            int: Target object ID\n        \"\"\"\n        if self.target is not None:\n            return self.target.id\n        else:\n            return 1\n\n    def add_point(self, x: int, y: int) -&gt; None:\n        \"\"\"Add a point to the edge\n\n        Args:\n            x (int): The x coordinate of the point in pixels\n            y (int): The y coordinate of the point in pixels\n        \"\"\"\n        self.geometry.points.append(Point(x=x, y=y))\n\n    def add_point_pos(self, position: Tuple[int, int]) -&gt; None:\n        \"\"\"Add a point to the edge by position tuple\n\n        Args:\n            position (tuple): A tuple of ints describing the x and y coordinates in pixels\n        \"\"\"\n        self.geometry.points.append(Point(x=position[0], y=position[1]))\n\n    ###########################################################\n    # Style properties\n    ###########################################################\n\n    @property\n    def style_attributes(self) -&gt; List[str]:\n        \"\"\"The style attributes to add to the style tag in the XML\n\n        Returns:\n            list: A list of style attributes\n        \"\"\"\n        return [\n            \"rounded\",\n            \"sketch\",\n            \"shadow\",\n            \"flowAnimation\",\n            \"jettySize\",\n            \"entryX\",\n            \"entryY\",\n            \"entryDx\",\n            \"entryDy\",\n            \"exitX\",\n            \"exitY\",\n            \"exitDx\",\n            \"exitDy\",\n            \"startArrow\",\n            \"endArrow\",\n            \"startFill\",\n            \"endFill\",\n            \"strokeColor\",\n            \"strokeWidth\",\n            \"fillColor\",\n            \"jumpStyle\",\n            \"jumpSize\",\n            \"targetPerimeterSpacing\",\n            \"sourcePerimeterSpacing\",\n            \"endSize\",\n            \"startSize\",\n            \"opacity\",\n        ]\n\n    @property\n    def baseStyle(self) -&gt; Optional[str]:\n        \"\"\"Generates the baseStyle string from the connection style, waypoint style, pattern style, and base style string.\n\n        Returns:\n            str: Concatenated baseStyle string\n        \"\"\"\n        style_str: List[str] = []\n        connection_style: Optional[str] = style_str_from_dict(\n            connection_db[self.connection]\n        )\n        if connection_style is not None and connection_style != \"\":\n            style_str.append(connection_style)\n\n        waypoint_style: Optional[str] = style_str_from_dict(\n            waypoints_db[self.waypoints]\n        )\n        if waypoint_style is not None and waypoint_style != \"\":\n            style_str.append(waypoint_style)\n\n        pattern_style: Optional[str] = style_str_from_dict(pattern_db[self.pattern])\n        if pattern_style is not None and pattern_style != \"\":\n            style_str.append(pattern_style)\n\n        if len(style_str) == 0:\n            return None\n        else:\n            return \";\".join(style_str)\n\n    @property\n    def startArrow(self) -&gt; Optional[str]:\n        \"\"\"What graphic the edge should be rendered with at the source\n\n        Returns:\n            str: The source edge graphic\n        \"\"\"\n        return self.line_end_source\n\n    @startArrow.setter\n    def startArrow(self, val: Optional[str]) -&gt; None:\n        self.line_end_source = val\n\n    @property\n    def startFill(self) -&gt; Optional[bool]:\n        \"\"\"Whether the graphic at the source should be filled\n\n        Returns:\n            bool: The source graphic fill\n        \"\"\"\n        if line_ends_db[self.line_end_source][\"fillable\"]:\n            return self.endFill_source\n        else:\n            return None\n\n    @property\n    def endArrow(self) -&gt; Optional[str]:\n        \"\"\"What graphic the edge should be rendered with at the target\n\n        Returns:\n            str: The target edge graphic\n        \"\"\"\n        return self.line_end_target\n\n    @endArrow.setter\n    def endArrow(self, val: Optional[str]) -&gt; None:\n        self.line_end_target = val\n\n    @property\n    def endFill(self) -&gt; Optional[bool]:\n        \"\"\"Whether the graphic at the target should be filled\n\n        Returns:\n            bool: The target graphic fill\n        \"\"\"\n        if line_ends_db[self.line_end_target][\"fillable\"]:\n            return self.endFill_target\n        else:\n            return None\n\n    # Base Line Style\n\n    # Waypoints\n    @property\n    def waypoints(self) -&gt; str:\n        \"\"\"The waypoint style. Checks if the passed in value is in the TOML database of waypoints before setting and throws a ValueError if not.\n\n        Returns:\n            str: The style of the waypoints\n        \"\"\"\n        return self._waypoints\n\n    @waypoints.setter\n    def waypoints(self, value: str) -&gt; None:\n        if value in waypoints_db.keys():\n            self._waypoints = value\n        else:\n            raise ValueError(\"{0} is not an allowed value of waypoints\")\n\n    # Connection\n    @property\n    def connection(self) -&gt; str:\n        \"\"\"The connection style. Checks if the passed in value is in the TOML database of connections before setting and throws a ValueError if not.\n\n        Returns:\n            str: The style of the connections\n        \"\"\"\n        return self._connection\n\n    @connection.setter\n    def connection(self, value: str) -&gt; None:\n        if value in connection_db.keys():\n            self._connection = value\n        else:\n            raise ValueError(\"{0} is not an allowed value of connection\".format(value))\n\n    # Pattern\n    @property\n    def pattern(self) -&gt; str:\n        \"\"\"The pattern style. Checks if the passed in value is in the TOML database of patterns before setting and throws a ValueError if not.\n\n        Returns:\n            str: The style of the patterns\n        \"\"\"\n        return self._pattern\n\n    @pattern.setter\n    def pattern(self, value: str) -&gt; None:\n        if value in pattern_db.keys():\n            self._pattern = value\n        else:\n            raise ValueError(\"{0} is not an allowed value of pattern\")\n\n    # Color properties (enforce value)\n    ## strokeColor\n    @property\n    def strokeColor(self) -&gt; Optional[str]:\n        return self._strokeColor\n\n    @strokeColor.setter\n    def strokeColor(self, value: Optional[str]) -&gt; None:\n        self._strokeColor = color_input_check(value)\n\n    @strokeColor.deleter\n    def strokeColor(self) -&gt; None:\n        self._strokeColor = None\n\n    ## strokeWidth\n    @property\n    def strokeWidth(self) -&gt; Optional[int]:\n        return self._strokeWidth\n\n    @strokeWidth.setter\n    def strokeWidth(self, value: Optional[int]) -&gt; None:\n        self._strokeWidth = width_input_check(value)\n\n    @strokeWidth.deleter\n    def strokeWidth(self) -&gt; None:\n        self._strokeWidth = None\n\n    # fillColor\n    @property\n    def fillColor(self) -&gt; Optional[str]:\n        return self._fillColor\n\n    @fillColor.setter\n    def fillColor(self, value: Optional[str]) -&gt; None:\n        self._fillColor = color_input_check(value)\n\n    @fillColor.deleter\n    def fillColor(self) -&gt; None:\n        self._fillColor = None\n\n    # Jump style (enforce value)\n    @property\n    def jumpStyle(self) -&gt; Optional[str]:\n        return self._jumpStyle\n\n    @jumpStyle.setter\n    def jumpStyle(self, value: Optional[str]) -&gt; None:\n        if value in [None, \"arc\", \"gap\", \"sharp\", \"line\"]:\n            self._jumpStyle = value\n        else:\n            raise ValueError(f\"'{value}' is not a permitted jumpStyle value!\")\n\n    @jumpStyle.deleter\n    def jumpStyle(self) -&gt; None:\n        self._jumpStyle = None\n\n    ###########################################################\n    # XML Generation\n    ###########################################################\n\n    @property\n    def label(self) -&gt; Optional[str]:\n        \"\"\"The text to place on the label, aka its value.\"\"\"\n        return self.value\n\n    @label.setter\n    def label(self, value: Optional[str]) -&gt; None:\n        self.value = value\n\n    @label.deleter\n    def label(self) -&gt; None:\n        self.value = None\n\n    @property\n    def label_offset(self) -&gt; Optional[int]:\n        \"\"\"How far the label is offset away from the axis of the edge in pixels\"\"\"\n        return self.geometry.y\n\n    @label_offset.setter\n    def label_offset(self, value: Optional[int]) -&gt; None:\n        self.geometry.y = value\n\n    @label_offset.deleter\n    def label_offset(self) -&gt; None:\n        self.geometry.y = None\n\n    @property\n    def label_position(self) -&gt; Optional[float]:\n        \"\"\"Where along the edge the label is positioned. -1 is the source, 1 is the target, 0 is the center.\"\"\"\n        return self.geometry.x\n\n    @label_position.setter\n    def label_position(self, value: Optional[float]) -&gt; None:\n        self.geometry.x = value\n\n    @label_position.deleter\n    def label_position(self) -&gt; None:\n        self.geometry.x = None\n\n    @property\n    def xml(self) -&gt; str:\n        \"\"\"The opening and closing XML tags with the styling attributes included.\n\n        Returns:\n            str: _description_\n        \"\"\"\n        tag: str = (\n            self.xml_open_tag + \"\\n  \" + self.geometry.xml + \"\\n\" + self.xml_close_tag\n        )\n        return tag\n</code></pre>"},{"location":"api/edges/#src.drawpyo.diagram.edges.Edge.attributes","title":"<code>attributes</code>  <code>property</code>","text":"<p>Returns the XML attributes to be added to the tag for the object</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>Dict[str, Any]</code> <p>Dictionary of object attributes and their values</p>"},{"location":"api/edges/#src.drawpyo.diagram.edges.Edge.baseStyle","title":"<code>baseStyle</code>  <code>property</code>","text":"<p>Generates the baseStyle string from the connection style, waypoint style, pattern style, and base style string.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>Optional[str]</code> <p>Concatenated baseStyle string</p>"},{"location":"api/edges/#src.drawpyo.diagram.edges.Edge.connection","title":"<code>connection</code>  <code>property</code> <code>writable</code>","text":"<p>The connection style. Checks if the passed in value is in the TOML database of connections before setting and throws a ValueError if not.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The style of the connections</p>"},{"location":"api/edges/#src.drawpyo.diagram.edges.Edge.endArrow","title":"<code>endArrow</code>  <code>property</code> <code>writable</code>","text":"<p>What graphic the edge should be rendered with at the target</p> <p>Returns:</p> Name Type Description <code>str</code> <code>Optional[str]</code> <p>The target edge graphic</p>"},{"location":"api/edges/#src.drawpyo.diagram.edges.Edge.endFill","title":"<code>endFill</code>  <code>property</code>","text":"<p>Whether the graphic at the target should be filled</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>Optional[bool]</code> <p>The target graphic fill</p>"},{"location":"api/edges/#src.drawpyo.diagram.edges.Edge.label","title":"<code>label</code>  <code>deletable</code> <code>property</code> <code>writable</code>","text":"<p>The text to place on the label, aka its value.</p>"},{"location":"api/edges/#src.drawpyo.diagram.edges.Edge.label_offset","title":"<code>label_offset</code>  <code>deletable</code> <code>property</code> <code>writable</code>","text":"<p>How far the label is offset away from the axis of the edge in pixels</p>"},{"location":"api/edges/#src.drawpyo.diagram.edges.Edge.label_position","title":"<code>label_position</code>  <code>deletable</code> <code>property</code> <code>writable</code>","text":"<p>Where along the edge the label is positioned. -1 is the source, 1 is the target, 0 is the center.</p>"},{"location":"api/edges/#src.drawpyo.diagram.edges.Edge.pattern","title":"<code>pattern</code>  <code>property</code> <code>writable</code>","text":"<p>The pattern style. Checks if the passed in value is in the TOML database of patterns before setting and throws a ValueError if not.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The style of the patterns</p>"},{"location":"api/edges/#src.drawpyo.diagram.edges.Edge.source","title":"<code>source</code>  <code>deletable</code> <code>property</code> <code>writable</code>","text":"<p>The source object of the edge. Automatically adds the edge to the object when set and removes it when deleted.</p> <p>Returns:</p> Name Type Description <code>BaseDiagram</code> <code>Optional[DiagramBase]</code> <p>source object of the edge</p>"},{"location":"api/edges/#src.drawpyo.diagram.edges.Edge.source_id","title":"<code>source_id</code>  <code>property</code>","text":"<p>The ID of the source object or 1 if no source is set</p> <p>Returns:</p> Name Type Description <code>int</code> <code>Union[int, Any]</code> <p>Source object ID</p>"},{"location":"api/edges/#src.drawpyo.diagram.edges.Edge.startArrow","title":"<code>startArrow</code>  <code>property</code> <code>writable</code>","text":"<p>What graphic the edge should be rendered with at the source</p> <p>Returns:</p> Name Type Description <code>str</code> <code>Optional[str]</code> <p>The source edge graphic</p>"},{"location":"api/edges/#src.drawpyo.diagram.edges.Edge.startFill","title":"<code>startFill</code>  <code>property</code>","text":"<p>Whether the graphic at the source should be filled</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>Optional[bool]</code> <p>The source graphic fill</p>"},{"location":"api/edges/#src.drawpyo.diagram.edges.Edge.style_attributes","title":"<code>style_attributes</code>  <code>property</code>","text":"<p>The style attributes to add to the style tag in the XML</p> <p>Returns:</p> Name Type Description <code>list</code> <code>List[str]</code> <p>A list of style attributes</p>"},{"location":"api/edges/#src.drawpyo.diagram.edges.Edge.target","title":"<code>target</code>  <code>deletable</code> <code>property</code> <code>writable</code>","text":"<p>The target object of the edge. Automatically adds the edge to the object when set and removes it when deleted.</p> <p>Returns:</p> Name Type Description <code>BaseDiagram</code> <code>Optional[DiagramBase]</code> <p>target object of the edge</p>"},{"location":"api/edges/#src.drawpyo.diagram.edges.Edge.target_id","title":"<code>target_id</code>  <code>property</code>","text":"<p>The ID of the target object or 1 if no target is set</p> <p>Returns:</p> Name Type Description <code>int</code> <code>Union[int, Any]</code> <p>Target object ID</p>"},{"location":"api/edges/#src.drawpyo.diagram.edges.Edge.waypoints","title":"<code>waypoints</code>  <code>property</code> <code>writable</code>","text":"<p>The waypoint style. Checks if the passed in value is in the TOML database of waypoints before setting and throws a ValueError if not.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The style of the waypoints</p>"},{"location":"api/edges/#src.drawpyo.diagram.edges.Edge.xml","title":"<code>xml</code>  <code>property</code>","text":"<p>The opening and closing XML tags with the styling attributes included.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>description</p>"},{"location":"api/edges/#src.drawpyo.diagram.edges.Edge.__init__","title":"<code>__init__(**kwargs)</code>","text":"<p>Edges can be initialized with almost all styling parameters as args. See Usage - Edges for more information and the options for each parameter.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>DiagramBase</code> <p>The Draw.io object that the edge originates from</p> required <code>target</code> <code>DiagramBase</code> <p>The Draw.io object that the edge points to</p> required <code>label</code> <code>str</code> <p>The text to place on the edge.</p> required <code>label_position</code> <code>float</code> <p>Where along the edge the label is positioned. -1 is the source, 1 is the target, 0 is the center</p> required <code>label_offset</code> <code>int</code> <p>How far the label is offset away from the axis of the edge in pixels</p> required <code>waypoints</code> <code>str</code> <p>How the edge should be styled in Draw.io</p> required <code>connection</code> <code>str</code> <p>What type of style the edge should be rendered with</p> required <code>pattern</code> <code>str</code> <p>How the line of the edge should be rendered</p> required <code>shadow</code> <code>bool</code> <p>Add a shadow to the edge</p> required <code>rounded</code> <code>bool</code> <p>Whether the corner of the line should be rounded</p> required <code>flowAnimation</code> <code>bool</code> <p>Add a marching ants animation along the edge</p> required <code>sketch</code> <code>bool</code> <p>Add sketch styling to the edge</p> required <code>line_end_target</code> <code>str</code> <p>What graphic the edge should be rendered with at the target</p> required <code>line_end_source</code> <code>str</code> <p>What graphic the edge should be rendered with at the source</p> required <code>endFill_target</code> <code>boolean</code> <p>Whether the target graphic should be filled</p> required <code>endFill_source</code> <code>boolean</code> <p>Whether the source graphic should be filled</p> required <code>endSize</code> <code>int</code> <p>The size of the end arrow in points</p> required <code>startSize</code> <code>int</code> <p>The size of the start arrow in points</p> required <code>jettySize</code> <code>str or int</code> <p>Length of the straight sections at the end of the edge. \"auto\" or a number</p> required <code>targetPerimeterSpacing</code> <code>int</code> <p>The negative or positive spacing between the target and end of the edge (points)</p> required <code>sourcePerimeterSpacing</code> <code>int</code> <p>The negative or positive spacing between the source and end of the edge (points)</p> required <code>entryX</code> <code>int</code> <p>From where along the X axis on the source object the edge originates (0-1)</p> required <code>entryY</code> <code>int</code> <p>From where along the Y axis on the source object the edge originates (0-1)</p> required <code>entryDx</code> <code>int</code> <p>Applies an offset in pixels to the X axis entry point</p> required <code>entryDy</code> <code>int</code> <p>Applies an offset in pixels to the Y axis entry point</p> required <code>exitX</code> <code>int</code> <p>From where along the X axis on the target object the edge originates (0-1)</p> required <code>exitY</code> <code>int</code> <p>From where along the Y axis on the target object the edge originates (0-1)</p> required <code>exitDx</code> <code>int</code> <p>Applies an offset in pixels to the X axis exit point</p> required <code>exitDy</code> <code>int</code> <p>Applies an offset in pixels to the Y axis exit point</p> required <code>color_scheme</code> <code>ColorScheme</code> <p>Bundled set of color specifications. Defaults to None.</p> required <code>strokeColor</code> <code>str</code> <p>The color of the border of the edge ('none', 'default', or hex color code)</p> required <code>strokeWidth</code> <code>int</code> <p>The width of the border of the the edge within range (1-999)</p> required <code>fillColor</code> <code>str</code> <p>The color of the fill of the edge ('none', 'default', or hex color code)</p> required <code>jumpStyle</code> <code>str</code> <p>The line jump style ('arc', 'gap', 'sharp', 'line')</p> required <code>jumpSize</code> <code>int</code> <p>The size of the line jumps in points.</p> required <code>opacity</code> <code>int</code> <p>The opacity of the edge (0-100)</p> required Source code in <code>src/drawpyo/diagram/edges.py</code> <pre><code>def __init__(self, **kwargs: Any) -&gt; None:\n    \"\"\"Edges can be initialized with almost all styling parameters as args.\n    See [Usage - Edges](../../usage/edges) for more information and the options for each parameter.\n\n    Args:\n        source (DiagramBase): The Draw.io object that the edge originates from\n        target (DiagramBase): The Draw.io object that the edge points to\n        label (str): The text to place on the edge.\n        label_position (float): Where along the edge the label is positioned. -1 is the source, 1 is the target, 0 is the center\n        label_offset (int): How far the label is offset away from the axis of the edge in pixels\n        waypoints (str): How the edge should be styled in Draw.io\n        connection (str): What type of style the edge should be rendered with\n        pattern (str): How the line of the edge should be rendered\n        shadow (bool, optional): Add a shadow to the edge\n        rounded (bool): Whether the corner of the line should be rounded\n        flowAnimation (bool): Add a marching ants animation along the edge\n        sketch (bool, optional): Add sketch styling to the edge\n        line_end_target (str): What graphic the edge should be rendered with at the target\n        line_end_source (str): What graphic the edge should be rendered with at the source\n        endFill_target (boolean): Whether the target graphic should be filled\n        endFill_source (boolean): Whether the source graphic should be filled\n        endSize (int): The size of the end arrow in points\n        startSize (int): The size of the start arrow in points\n        jettySize (str or int): Length of the straight sections at the end of the edge. \"auto\" or a number\n        targetPerimeterSpacing (int): The negative or positive spacing between the target and end of the edge (points)\n        sourcePerimeterSpacing (int): The negative or positive spacing between the source and end of the edge (points)\n        entryX (int): From where along the X axis on the source object the edge originates (0-1)\n        entryY (int): From where along the Y axis on the source object the edge originates (0-1)\n        entryDx (int): Applies an offset in pixels to the X axis entry point\n        entryDy (int): Applies an offset in pixels to the Y axis entry point\n        exitX (int): From where along the X axis on the target object the edge originates (0-1)\n        exitY (int): From where along the Y axis on the target object the edge originates (0-1)\n        exitDx (int): Applies an offset in pixels to the X axis exit point\n        exitDy (int): Applies an offset in pixels to the Y axis exit point\n        color_scheme (ColorScheme, optional): Bundled set of color specifications. Defaults to None.\n        strokeColor (str): The color of the border of the edge ('none', 'default', or hex color code)\n        strokeWidth (int): The width of the border of the the edge within range (1-999)\n        fillColor (str): The color of the fill of the edge ('none', 'default', or hex color code)\n        jumpStyle (str): The line jump style ('arc', 'gap', 'sharp', 'line')\n        jumpSize (int): The size of the line jumps in points.\n        opacity (int): The opacity of the edge (0-100)\n    \"\"\"\n    super().__init__(**kwargs)\n    self.xml_class: str = \"mxCell\"\n\n    # Style\n    self.color_scheme: Optional[ColorScheme] = kwargs.get(\"color_scheme\", None)\n    self.text_format: Optional[TextFormat] = kwargs.get(\"text_format\", TextFormat())\n    if not self.text_format.fontColor and self.color_scheme:\n        self.text_format.fontColor = self.color_scheme.font_color\n    self.waypoints: Optional[str] = kwargs.get(\"waypoints\", \"orthogonal\")\n    self.connection: Optional[str] = kwargs.get(\"connection\", \"line\")\n    self.pattern: Optional[str] = kwargs.get(\"pattern\", \"solid\")\n    self.opacity: Optional[int] = kwargs.get(\"opacity\", None)\n    self.strokeWidth: Optional[int] = kwargs.get(\"strokeWidth\", None)\n    self.strokeColor: Optional[Union[str, StandardColor]] = kwargs.get(\n        \"stroke_color\"\n    ) or (self.color_scheme.stroke_color if self.color_scheme else None)\n    self.fillColor: Optional[Union[str, StandardColor]] = kwargs.get(\n        \"fill_color\"\n    ) or (self.color_scheme.fill_color if self.color_scheme else None)\n\n    # Line end\n    self.line_end_target: Optional[str] = kwargs.get(\"line_end_target\", None)\n    self.line_end_source: Optional[str] = kwargs.get(\"line_end_source\", None)\n    self.endFill_target: bool = kwargs.get(\"endFill_target\", False)\n    self.endFill_source: bool = kwargs.get(\"endFill_source\", False)\n    self.endSize: Optional[int] = kwargs.get(\"endSize\", None)\n    self.startSize: Optional[int] = kwargs.get(\"startSize\", None)\n\n    self.rounded: int = kwargs.get(\"rounded\", 0)\n    self.sketch: Optional[bool] = kwargs.get(\"sketch\", None)\n    self.shadow: Optional[bool] = kwargs.get(\"shadow\", None)\n    self.flowAnimation: Optional[bool] = kwargs.get(\"flowAnimation\", None)\n\n    self._jumpStyle: Optional[str] = None\n    self.jumpStyle = kwargs.get(\"jumpStyle\", None)\n    self.jumpSize: Optional[int] = kwargs.get(\"jumpSize\", None)\n\n    # Connection and geometry\n    self.jettySize: Union[str, int] = kwargs.get(\"jettySize\", \"auto\")\n    self.geometry: EdgeGeometry = EdgeGeometry()\n    self.edge: int = kwargs.get(\"edge\", 1)\n    self.targetPerimeterSpacing: Optional[int] = kwargs.get(\n        \"targetPerimeterSpacing\", None\n    )\n    self.sourcePerimeterSpacing: Optional[int] = kwargs.get(\n        \"sourcePerimeterSpacing\", None\n    )\n    self._source: Optional[DiagramBase] = None\n    self.source = kwargs.get(\"source\", None)\n    self._target: Optional[DiagramBase] = None\n    self.target = kwargs.get(\"target\", None)\n    self.entryX: Optional[float] = kwargs.get(\"entryX\", None)\n    self.entryY: Optional[float] = kwargs.get(\"entryY\", None)\n    self.entryDx: Optional[int] = kwargs.get(\"entryDx\", None)\n    self.entryDy: Optional[int] = kwargs.get(\"entryDy\", None)\n    self.exitX: Optional[float] = kwargs.get(\"exitX\", None)\n    self.exitY: Optional[float] = kwargs.get(\"exitY\", None)\n    self.exitDx: Optional[int] = kwargs.get(\"exitDx\", None)\n    self.exitDy: Optional[int] = kwargs.get(\"exitDy\", None)\n\n    # Label\n    self.label: Optional[str] = kwargs.get(\"label\", None)\n    self.edge_axis_offset: Optional[int] = kwargs.get(\"edge_offset\", None)\n    self.label_offset: Optional[int] = kwargs.get(\"label_offset\", None)\n    self.label_position: Optional[float] = kwargs.get(\"label_position\", None)\n\n    logger.debug(f\"\u27a1\ufe0f Edge created: {self.__repr__()}\")\n</code></pre>"},{"location":"api/edges/#src.drawpyo.diagram.edges.Edge.__repr__","title":"<code>__repr__()</code>","text":"<p>A concise and informative representation of the edge for debugging.</p> Source code in <code>src/drawpyo/diagram/edges.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"\n    A concise and informative representation of the edge for debugging.\n    \"\"\"\n    cls = self.__class__.__name__\n    parts = []\n\n    # Source/Target\n    parts.append(f\"source: '{self.source.value if self.source else None}'\")\n    parts.append(f\"target: '{self.target.value if self.target else None}'\")\n\n    # Label\n    if self.label:\n        parts.append(f\"label={self.label!r}\")\n\n    # Entry/Exit geometry (only show if anything is set)\n    geom_parts = []\n    for attr in (\n        \"entryX\",\n        \"entryY\",\n        \"entryDx\",\n        \"entryDy\",\n        \"exitX\",\n        \"exitY\",\n        \"exitDx\",\n        \"exitDy\",\n    ):\n        val = getattr(self, attr, None)\n        if val not in (None, 0):\n            geom_parts.append(f\"{attr}={val}\")\n    if geom_parts:\n        parts.append(\"geom={\" + \", \".join(geom_parts) + \"}\")\n\n    return f\"{cls}(\" + \", \".join(parts) + \")\"\n</code></pre>"},{"location":"api/edges/#src.drawpyo.diagram.edges.Edge.add_point","title":"<code>add_point(x, y)</code>","text":"<p>Add a point to the edge</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>int</code> <p>The x coordinate of the point in pixels</p> required <code>y</code> <code>int</code> <p>The y coordinate of the point in pixels</p> required Source code in <code>src/drawpyo/diagram/edges.py</code> <pre><code>def add_point(self, x: int, y: int) -&gt; None:\n    \"\"\"Add a point to the edge\n\n    Args:\n        x (int): The x coordinate of the point in pixels\n        y (int): The y coordinate of the point in pixels\n    \"\"\"\n    self.geometry.points.append(Point(x=x, y=y))\n</code></pre>"},{"location":"api/edges/#src.drawpyo.diagram.edges.Edge.add_point_pos","title":"<code>add_point_pos(position)</code>","text":"<p>Add a point to the edge by position tuple</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>tuple</code> <p>A tuple of ints describing the x and y coordinates in pixels</p> required Source code in <code>src/drawpyo/diagram/edges.py</code> <pre><code>def add_point_pos(self, position: Tuple[int, int]) -&gt; None:\n    \"\"\"Add a point to the edge by position tuple\n\n    Args:\n        position (tuple): A tuple of ints describing the x and y coordinates in pixels\n    \"\"\"\n    self.geometry.points.append(Point(x=position[0], y=position[1]))\n</code></pre>"},{"location":"api/edges/#src.drawpyo.diagram.edges.Edge.remove","title":"<code>remove()</code>","text":"<p>This function removes references to the Edge from its source and target objects then deletes the Edge.</p> Source code in <code>src/drawpyo/diagram/edges.py</code> <pre><code>def remove(self) -&gt; None:\n    \"\"\"This function removes references to the Edge from its source and target objects then deletes the Edge.\"\"\"\n    if self.source is not None:\n        self.source.remove_out_edge(self)\n    if self.target is not None:\n        self.target.remove_in_edge(self)\n    del self\n</code></pre>"},{"location":"api/extended_objects/","title":"Extended Objects","text":""},{"location":"api/extended_objects/#list","title":"List","text":""},{"location":"api/extended_objects/#src.drawpyo.diagram.extended_objects.List","title":"<code>src.drawpyo.diagram.extended_objects.List</code>","text":"<p>               Bases: <code>Object</code></p> Source code in <code>src/drawpyo/diagram/extended_objects.py</code> <pre><code>class List(Object):\n    def __init__(\n        self, title: str = \"List\", list_items: ListType[str] = [], **kwargs: Any\n    ) -&gt; None:\n        \"\"\"The List object wraps the basic Object type but allows easier managing of a list object and its members. All of the arguments and keyword arguments for Object are available here as well.\n\n        Args:\n            title (str, optional): The name in the heading of the list. Defaults to \"List\".\n            list_items (list of strings, optional): A Python list of strings denoting the items. Defaults to empty.\n        \"\"\"\n        super().__init__(value=title, **kwargs)\n        self.format_as_library_object(library=\"general\", obj_name=\"list\")\n        self.autosizing: bool = kwargs.get(\"autosizing\", True)\n        self.width: Union[int, float] = kwargs.get(\"width\", 120)\n        self.list_items: Optional[List[str]] = list_items\n\n    @property\n    def list_items(self) -&gt; ListType[str]:\n        \"\"\"A Python list of strings of the objects in the list.\n\n        Returns:\n            list of strings: The list items\n        \"\"\"\n        return [child.value for child in self.children]\n\n    @list_items.setter\n    def list_items(self, value: ListType[str]) -&gt; None:\n        if not isinstance(value, list):\n            raise TypeError(\"list_items must be a list!\")\n        self.children = []\n        for item in value:\n            self.add_item(item)\n\n    def add_item(self, item_text: str) -&gt; None:\n        \"\"\"This function creates a new Draw.io text item and adds it to the end of the list.\n\n        Args:\n            item_text (string): The name of the item to add.\n        \"\"\"\n        new_item = object_from_library(\n            library=\"general\", obj_name=\"list_item\", page=self.page\n        )\n        new_item.value = item_text\n        new_item.parent = self\n        new_item.width = self.width\n        new_item.geometry.y = len(self.list_items) * new_item.height\n        if self.autosizing:\n            self.autosize()\n\n    def remove_item(self, item_text: str) -&gt; None:\n        \"\"\"This function removes any list items matching the text passed into the function.\n\n        Args:\n            item_text (string): The text of the list item to remove.\n        \"\"\"\n        for child in self.children:\n            if child.value == item_text:\n                self.remove_object(child)\n                self.page.remove_object(child)\n                del child\n        if self.autosizing:\n            self.autosize()\n\n    def autosize(self) -&gt; None:\n        \"\"\"This function resizes the parent List object to match the length of the list of items. It also restacks the list items to fill any gaps from deleted items.\"\"\"\n        y_pos = self.startSize\n        for child in self.children:\n            child.geometry.y = y_pos\n            y_pos = y_pos + child.height\n        self.height = self.startSize + sum(child.height for child in self.children)\n        self.width = min(child.width for child in self.children)\n\n    @property\n    def width(self) -&gt; Union[int, float]:\n        \"\"\"The width of the object. The difference between List's width and Object's width is that when the List.width is set all of the child objects will be set to the same width.\n\n        Returns:\n            Union[int, float]: The width of the list object\n        \"\"\"\n        return self.geometry.width\n\n    @width.setter\n    def width(self, value: Union[int, float]) -&gt; None:\n        for child in self.children:\n            child.width = value\n        self.geometry.width = value\n        self.update_parent()\n</code></pre>"},{"location":"api/extended_objects/#src.drawpyo.diagram.extended_objects.List.list_items","title":"<code>list_items</code>  <code>property</code> <code>writable</code>","text":"<p>A Python list of strings of the objects in the list.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>list of strings: The list items</p>"},{"location":"api/extended_objects/#src.drawpyo.diagram.extended_objects.List.width","title":"<code>width</code>  <code>property</code> <code>writable</code>","text":"<p>The width of the object. The difference between List's width and Object's width is that when the List.width is set all of the child objects will be set to the same width.</p> <p>Returns:</p> Type Description <code>Union[int, float]</code> <p>Union[int, float]: The width of the list object</p>"},{"location":"api/extended_objects/#src.drawpyo.diagram.extended_objects.List.__init__","title":"<code>__init__(title='List', list_items=[], **kwargs)</code>","text":"<p>The List object wraps the basic Object type but allows easier managing of a list object and its members. All of the arguments and keyword arguments for Object are available here as well.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>The name in the heading of the list. Defaults to \"List\".</p> <code>'List'</code> <code>list_items</code> <code>list of strings</code> <p>A Python list of strings denoting the items. Defaults to empty.</p> <code>[]</code> Source code in <code>src/drawpyo/diagram/extended_objects.py</code> <pre><code>def __init__(\n    self, title: str = \"List\", list_items: ListType[str] = [], **kwargs: Any\n) -&gt; None:\n    \"\"\"The List object wraps the basic Object type but allows easier managing of a list object and its members. All of the arguments and keyword arguments for Object are available here as well.\n\n    Args:\n        title (str, optional): The name in the heading of the list. Defaults to \"List\".\n        list_items (list of strings, optional): A Python list of strings denoting the items. Defaults to empty.\n    \"\"\"\n    super().__init__(value=title, **kwargs)\n    self.format_as_library_object(library=\"general\", obj_name=\"list\")\n    self.autosizing: bool = kwargs.get(\"autosizing\", True)\n    self.width: Union[int, float] = kwargs.get(\"width\", 120)\n    self.list_items: Optional[List[str]] = list_items\n</code></pre>"},{"location":"api/extended_objects/#src.drawpyo.diagram.extended_objects.List.add_item","title":"<code>add_item(item_text)</code>","text":"<p>This function creates a new Draw.io text item and adds it to the end of the list.</p> <p>Parameters:</p> Name Type Description Default <code>item_text</code> <code>string</code> <p>The name of the item to add.</p> required Source code in <code>src/drawpyo/diagram/extended_objects.py</code> <pre><code>def add_item(self, item_text: str) -&gt; None:\n    \"\"\"This function creates a new Draw.io text item and adds it to the end of the list.\n\n    Args:\n        item_text (string): The name of the item to add.\n    \"\"\"\n    new_item = object_from_library(\n        library=\"general\", obj_name=\"list_item\", page=self.page\n    )\n    new_item.value = item_text\n    new_item.parent = self\n    new_item.width = self.width\n    new_item.geometry.y = len(self.list_items) * new_item.height\n    if self.autosizing:\n        self.autosize()\n</code></pre>"},{"location":"api/extended_objects/#src.drawpyo.diagram.extended_objects.List.autosize","title":"<code>autosize()</code>","text":"<p>This function resizes the parent List object to match the length of the list of items. It also restacks the list items to fill any gaps from deleted items.</p> Source code in <code>src/drawpyo/diagram/extended_objects.py</code> <pre><code>def autosize(self) -&gt; None:\n    \"\"\"This function resizes the parent List object to match the length of the list of items. It also restacks the list items to fill any gaps from deleted items.\"\"\"\n    y_pos = self.startSize\n    for child in self.children:\n        child.geometry.y = y_pos\n        y_pos = y_pos + child.height\n    self.height = self.startSize + sum(child.height for child in self.children)\n    self.width = min(child.width for child in self.children)\n</code></pre>"},{"location":"api/extended_objects/#src.drawpyo.diagram.extended_objects.List.remove_item","title":"<code>remove_item(item_text)</code>","text":"<p>This function removes any list items matching the text passed into the function.</p> <p>Parameters:</p> Name Type Description Default <code>item_text</code> <code>string</code> <p>The text of the list item to remove.</p> required Source code in <code>src/drawpyo/diagram/extended_objects.py</code> <pre><code>def remove_item(self, item_text: str) -&gt; None:\n    \"\"\"This function removes any list items matching the text passed into the function.\n\n    Args:\n        item_text (string): The text of the list item to remove.\n    \"\"\"\n    for child in self.children:\n        if child.value == item_text:\n            self.remove_object(child)\n            self.page.remove_object(child)\n            del child\n    if self.autosizing:\n        self.autosize()\n</code></pre>"},{"location":"api/extended_objects/#pie-slice","title":"Pie Slice","text":""},{"location":"api/extended_objects/#src.drawpyo.diagram.extended_objects.PieSlice","title":"<code>src.drawpyo.diagram.extended_objects.PieSlice</code>","text":"<p>               Bases: <code>Object</code></p> Source code in <code>src/drawpyo/diagram/extended_objects.py</code> <pre><code>class PieSlice(Object):\n    def __init__(\n        self,\n        value: str = \"\",\n        slice_value: float = 2.0,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"The PieSlice object wraps the basic Object type but allows easier managing of a pie chart slice. All of the arguments and keyword arguments for Object are available here as well.\n\n        Args:\n            title (str, optional): The name of the pie slice. Defaults to \"Slice\".\n            slice_value (float, optional): The numeric value of the pie slice. Defaults to 1.0.\n            startAngle (float, optional): The starting angle of the pie slice in degrees. Defaults to 0.0.\n        \"\"\"\n        super().__init__(value=value, **kwargs)\n        self.format_as_library_object(library=\"infographics\", obj_name=\"pie\")\n        self._style_attributes.append(\"startAngle\")\n        self._style_attributes.append(\"endAngle\")\n        self.slice_value: float = slice_value\n        self.size: Union[int, float] = kwargs.get(\"size\", 120)\n        self.startAngle: float = kwargs.get(\"startAngle\", 0.0)\n        self.endAngle: float = (self.startAngle + slice_value) % 1\n\n    @property\n    def size(self) -&gt; Union[int, float]:\n        \"\"\"The size (width and height) of the pie slice.\n\n        Returns:\n            Union[int, float]: The size\n        \"\"\"\n        return self.geometry.width\n\n    @size.setter\n    def size(self, value: Union[int, float]) -&gt; None:\n        self.geometry.width = float(value)\n        self.geometry.height = float(value)\n        self.update_parent()\n</code></pre>"},{"location":"api/extended_objects/#src.drawpyo.diagram.extended_objects.PieSlice.size","title":"<code>size</code>  <code>property</code> <code>writable</code>","text":"<p>The size (width and height) of the pie slice.</p> <p>Returns:</p> Type Description <code>Union[int, float]</code> <p>Union[int, float]: The size</p>"},{"location":"api/extended_objects/#src.drawpyo.diagram.extended_objects.PieSlice.__init__","title":"<code>__init__(value='', slice_value=2.0, **kwargs)</code>","text":"<p>The PieSlice object wraps the basic Object type but allows easier managing of a pie chart slice. All of the arguments and keyword arguments for Object are available here as well.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>The name of the pie slice. Defaults to \"Slice\".</p> required <code>slice_value</code> <code>float</code> <p>The numeric value of the pie slice. Defaults to 1.0.</p> <code>2.0</code> <code>startAngle</code> <code>float</code> <p>The starting angle of the pie slice in degrees. Defaults to 0.0.</p> required Source code in <code>src/drawpyo/diagram/extended_objects.py</code> <pre><code>def __init__(\n    self,\n    value: str = \"\",\n    slice_value: float = 2.0,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"The PieSlice object wraps the basic Object type but allows easier managing of a pie chart slice. All of the arguments and keyword arguments for Object are available here as well.\n\n    Args:\n        title (str, optional): The name of the pie slice. Defaults to \"Slice\".\n        slice_value (float, optional): The numeric value of the pie slice. Defaults to 1.0.\n        startAngle (float, optional): The starting angle of the pie slice in degrees. Defaults to 0.0.\n    \"\"\"\n    super().__init__(value=value, **kwargs)\n    self.format_as_library_object(library=\"infographics\", obj_name=\"pie\")\n    self._style_attributes.append(\"startAngle\")\n    self._style_attributes.append(\"endAngle\")\n    self.slice_value: float = slice_value\n    self.size: Union[int, float] = kwargs.get(\"size\", 120)\n    self.startAngle: float = kwargs.get(\"startAngle\", 0.0)\n    self.endAngle: float = (self.startAngle + slice_value) % 1\n</code></pre>"},{"location":"api/file/","title":"File","text":""},{"location":"api/file/#src.drawpyo.file.File","title":"<code>src.drawpyo.file.File</code>","text":"<p>               Bases: <code>XMLBase</code></p> <p>The File class defines a Draw.io file, its properties, and the methods required for saving it.</p> Source code in <code>src/drawpyo/file.py</code> <pre><code>class File(XMLBase):\n    \"\"\"The File class defines a Draw.io file, its properties, and the methods required for saving it.\"\"\"\n\n    def __init__(\n        self,\n        file_name: str = \"Drawpyo Diagram.drawio\",\n        file_path: str = path.join(path.expanduser(\"~\"), \"Drawpyo Charts\"),\n    ) -&gt; None:\n        \"\"\"To initiate a File object, pass in a name and path or leave it to the defaults.\n\n        Args:\n            file_name (str, optional): The name of the file.\n            file_path (str, optional): The location where the file will be saved.\n        \"\"\"\n\n        super().__init__()\n\n        self.pages: List[Page] = []\n        self.file_name: str = file_name\n        self.file_path: str = file_path\n\n        # Attributes\n        self.host: str = \"Drawpyo\"\n        self.type: str = \"device\"\n        self.version: str = \"21.6.5\"  # This is the version of the Draw.io spec\n        self.xml_class: str = \"mxfile\"\n\n        logger.info(f\"\ud83d\uddc3\ufe0f File created: '{self.__repr__()}'\")\n\n    def __repr__(self) -&gt; str:\n        return f\"drawpyo File - {self.file_name}\"\n\n    @property\n    def attributes(self) -&gt; Dict[str, Optional[str]]:\n        return {\n            \"host\": self.host,\n            \"modified\": self.modified,\n            \"agent\": self.agent,\n            \"etag\": self.etag,\n            \"version\": self.version,\n            \"type\": self.type,\n        }\n\n    def add_page(self, page: Page) -&gt; None:\n        \"\"\"Add a page to the file.\n\n        Args:\n            page (drawpyo.diagram.Page): A Page object\n        \"\"\"\n        page._file = self\n        self.pages.append(page)\n\n    def remove_page(self, page: Union[Page, str, int]) -&gt; None:\n        \"\"\"Remove a page from the file. The page argument can be either a Page object, the integer number of the page, or the string name of the page.\n\n        Args:\n            page (drawpyo.diagram.Page or str or int): A Page object that's currently contained in the file\n        \"\"\"\n        logger.info(f\"\ud83d\uddd1\ufe0f Page deleted: '{page.__repr__()}'\")\n        if isinstance(page, int):\n            del self.pages[page]\n        elif isinstance(page, str):\n            for pg in self.pages:\n                if pg.name == page:\n                    self.pages.remove(pg)\n        elif isinstance(page, Page):\n            self.pages.remove(page)\n\n    def stats(self) -&gt; str:\n        \"\"\"This function returns a string summarizing the file's properties.\n\n        Returns:\n            str: A summary of the file's properties\n        \"\"\"\n        object_count = 0\n        for page in self.pages:\n            object_count += len(page.objects)\n        return f\"Pages: {len(self.pages)} | Objects: {object_count}\"\n\n    ###########################################################\n    # File Properties\n    ###########################################################\n\n    @property\n    def modified(self) -&gt; str:\n        return datetime.now().strftime(\"%Y-%m-%dT%H:%M:%S\")\n\n    @property\n    def agent(self) -&gt; str:\n        python_version = f\"{version_info.major}.{version_info.minor}\"\n        drawpyo_version = f\"0.23\"\n        return f\"Python {python_version}, Drawpyo {drawpyo_version}\"\n\n    @property\n    def etag(self) -&gt; None:\n        # etag is in the Draw.io spec but not sure how it's used or if I need to create it\n        return None\n\n    ###########################################################\n    # XML Generation\n    ###########################################################\n\n    @property\n    def xml(self) -&gt; str:\n        \"\"\"This function goes through each page in the file, retrieves its XML, and appends it to a list, then wraps that list in the file's open and close tags.\n\n        Returns:\n            str: The XML data for the file and all the pages in it\n        \"\"\"\n        xml_string = self.xml_open_tag\n        for diag in self.pages:\n            xml_string = xml_string + \"\\n  \" + diag.xml\n        xml_string = xml_string + \"\\n\" + self.xml_close_tag\n        return xml_string\n\n    ###########################################################\n    # File Handling\n    ###########################################################\n    def write(self, **kwargs: Any) -&gt; str:\n        \"\"\"This function write the file to disc at the path and name specified.\n\n        Args:\n            file_path (str, opt): The path to save the file in\n            file_name (str, opt): The name of the file\n            overwrite (bool, opt): Whether to overwrite an existing file or not\n\n        Returns:\n            str: The full path to the written file\n        \"\"\"\n\n        # Check if file_path or file_name were passed in, or are preexisting\n        self.file_path = kwargs.get(\"file_path\", self.file_path)\n\n        self.file_name = kwargs.get(\"file_name\", self.file_name)\n\n        overwrite: bool = kwargs.get(\"overwrite\", True)\n        if overwrite:\n            write_mode = \"w\"\n        else:\n            write_mode = \"x\"\n\n        if not path.exists(self.file_path):\n            makedirs(self.file_path)\n\n        with open(\n            path.join(self.file_path, self.file_name), write_mode, encoding=\"utf-8\"\n        ) as f:\n            f.write(self.xml)\n            logger.info(f\"\ud83d\udcc8 File contents: '{self.stats()}'\")\n            logger.info(f\"\ud83d\udcbe Saved file: '{self.file_name}' at '{self.file_path}'\")\n\n        return path.join(self.file_path, self.file_name)\n</code></pre>"},{"location":"api/file/#src.drawpyo.file.File.xml","title":"<code>xml</code>  <code>property</code>","text":"<p>This function goes through each page in the file, retrieves its XML, and appends it to a list, then wraps that list in the file's open and close tags.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The XML data for the file and all the pages in it</p>"},{"location":"api/file/#src.drawpyo.file.File.__init__","title":"<code>__init__(file_name='Drawpyo Diagram.drawio', file_path=path.join(path.expanduser('~'), 'Drawpyo Charts'))</code>","text":"<p>To initiate a File object, pass in a name and path or leave it to the defaults.</p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <code>str</code> <p>The name of the file.</p> <code>'Drawpyo Diagram.drawio'</code> <code>file_path</code> <code>str</code> <p>The location where the file will be saved.</p> <code>join(expanduser('~'), 'Drawpyo Charts')</code> Source code in <code>src/drawpyo/file.py</code> <pre><code>def __init__(\n    self,\n    file_name: str = \"Drawpyo Diagram.drawio\",\n    file_path: str = path.join(path.expanduser(\"~\"), \"Drawpyo Charts\"),\n) -&gt; None:\n    \"\"\"To initiate a File object, pass in a name and path or leave it to the defaults.\n\n    Args:\n        file_name (str, optional): The name of the file.\n        file_path (str, optional): The location where the file will be saved.\n    \"\"\"\n\n    super().__init__()\n\n    self.pages: List[Page] = []\n    self.file_name: str = file_name\n    self.file_path: str = file_path\n\n    # Attributes\n    self.host: str = \"Drawpyo\"\n    self.type: str = \"device\"\n    self.version: str = \"21.6.5\"  # This is the version of the Draw.io spec\n    self.xml_class: str = \"mxfile\"\n\n    logger.info(f\"\ud83d\uddc3\ufe0f File created: '{self.__repr__()}'\")\n</code></pre>"},{"location":"api/file/#src.drawpyo.file.File.add_page","title":"<code>add_page(page)</code>","text":"<p>Add a page to the file.</p> <p>Parameters:</p> Name Type Description Default <code>page</code> <code>Page</code> <p>A Page object</p> required Source code in <code>src/drawpyo/file.py</code> <pre><code>def add_page(self, page: Page) -&gt; None:\n    \"\"\"Add a page to the file.\n\n    Args:\n        page (drawpyo.diagram.Page): A Page object\n    \"\"\"\n    page._file = self\n    self.pages.append(page)\n</code></pre>"},{"location":"api/file/#src.drawpyo.file.File.remove_page","title":"<code>remove_page(page)</code>","text":"<p>Remove a page from the file. The page argument can be either a Page object, the integer number of the page, or the string name of the page.</p> <p>Parameters:</p> Name Type Description Default <code>page</code> <code>Page or str or int</code> <p>A Page object that's currently contained in the file</p> required Source code in <code>src/drawpyo/file.py</code> <pre><code>def remove_page(self, page: Union[Page, str, int]) -&gt; None:\n    \"\"\"Remove a page from the file. The page argument can be either a Page object, the integer number of the page, or the string name of the page.\n\n    Args:\n        page (drawpyo.diagram.Page or str or int): A Page object that's currently contained in the file\n    \"\"\"\n    logger.info(f\"\ud83d\uddd1\ufe0f Page deleted: '{page.__repr__()}'\")\n    if isinstance(page, int):\n        del self.pages[page]\n    elif isinstance(page, str):\n        for pg in self.pages:\n            if pg.name == page:\n                self.pages.remove(pg)\n    elif isinstance(page, Page):\n        self.pages.remove(page)\n</code></pre>"},{"location":"api/file/#src.drawpyo.file.File.stats","title":"<code>stats()</code>","text":"<p>This function returns a string summarizing the file's properties.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A summary of the file's properties</p> Source code in <code>src/drawpyo/file.py</code> <pre><code>def stats(self) -&gt; str:\n    \"\"\"This function returns a string summarizing the file's properties.\n\n    Returns:\n        str: A summary of the file's properties\n    \"\"\"\n    object_count = 0\n    for page in self.pages:\n        object_count += len(page.objects)\n    return f\"Pages: {len(self.pages)} | Objects: {object_count}\"\n</code></pre>"},{"location":"api/file/#src.drawpyo.file.File.write","title":"<code>write(**kwargs)</code>","text":"<p>This function write the file to disc at the path and name specified.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>(str, opt)</code> <p>The path to save the file in</p> required <code>file_name</code> <code>(str, opt)</code> <p>The name of the file</p> required <code>overwrite</code> <code>(bool, opt)</code> <p>Whether to overwrite an existing file or not</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The full path to the written file</p> Source code in <code>src/drawpyo/file.py</code> <pre><code>def write(self, **kwargs: Any) -&gt; str:\n    \"\"\"This function write the file to disc at the path and name specified.\n\n    Args:\n        file_path (str, opt): The path to save the file in\n        file_name (str, opt): The name of the file\n        overwrite (bool, opt): Whether to overwrite an existing file or not\n\n    Returns:\n        str: The full path to the written file\n    \"\"\"\n\n    # Check if file_path or file_name were passed in, or are preexisting\n    self.file_path = kwargs.get(\"file_path\", self.file_path)\n\n    self.file_name = kwargs.get(\"file_name\", self.file_name)\n\n    overwrite: bool = kwargs.get(\"overwrite\", True)\n    if overwrite:\n        write_mode = \"w\"\n    else:\n        write_mode = \"x\"\n\n    if not path.exists(self.file_path):\n        makedirs(self.file_path)\n\n    with open(\n        path.join(self.file_path, self.file_name), write_mode, encoding=\"utf-8\"\n    ) as f:\n        f.write(self.xml)\n        logger.info(f\"\ud83d\udcc8 File contents: '{self.stats()}'\")\n        logger.info(f\"\ud83d\udcbe Saved file: '{self.file_name}' at '{self.file_path}'\")\n\n    return path.join(self.file_path, self.file_name)\n</code></pre>"},{"location":"api/objects/","title":"Objects","text":""},{"location":"api/objects/#object-creation","title":"Object Creation","text":""},{"location":"api/objects/#object_from_library","title":"object_from_library","text":""},{"location":"api/objects/#src.drawpyo.diagram.objects.object_from_library","title":"<code>src.drawpyo.diagram.objects.object_from_library(library, obj_name, **kwargs)</code>","text":"<p>This function generates an Object from a library. The library can either be custom imported from a TOML or the name of one of the built-in Draw.io libraries.</p> <p>Any keyword arguments that can be passed in to a Object creation can be passed into this function and it will format the base object. These keyword arguments will overwrite any attributes defined in the library.</p> <p>Parameters:</p> Name Type Description Default <code>library</code> <code>str or dict</code> <p>The library containing the object</p> required <code>obj_name</code> <code>str</code> <p>The name of the object in the library to generate</p> required <p>Returns:</p> Name Type Description <code>Object</code> <code>Object</code> <p>An object with the style from the library</p> Source code in <code>src/drawpyo/diagram/objects.py</code> <pre><code>def object_from_library(\n    library: Union[str, Dict[str, Any]], obj_name: str, **kwargs: Any\n) -&gt; \"Object\":\n    \"\"\"This function generates an Object from a library. The library can either be custom imported from a TOML or the name of one of the built-in Draw.io libraries.\n\n    Any keyword arguments that can be passed in to a Object creation can be passed into this function and it will format the base object. These keyword arguments will overwrite any attributes defined in the library.\n\n    Args:\n        library (str or dict): The library containing the object\n        obj_name (str): The name of the object in the library to generate\n\n    Returns:\n        Object: An object with the style from the library\n    \"\"\"\n    new_obj: Object = Object(**kwargs)\n    new_obj.format_as_library_object(library, obj_name)\n    new_obj.apply_attribute_dict(kwargs)\n    return new_obj\n</code></pre>"},{"location":"api/objects/#object","title":"Object","text":""},{"location":"api/objects/#src.drawpyo.diagram.objects.Object","title":"<code>src.drawpyo.diagram.objects.Object</code>","text":"<p>               Bases: <code>DiagramBase</code></p> <p>The Object class is the base object for all shapes in Draw.io.</p> <p>More information about objects are in the Usage documents at Usage - Objects.</p> Source code in <code>src/drawpyo/diagram/objects.py</code> <pre><code>class Object(DiagramBase):\n    \"\"\"\n    The Object class is the base object for all shapes in Draw.io.\n\n    More information about objects are in the Usage documents at [Usage - Objects](../../usage/objects).\n    \"\"\"\n\n    ###########################################################\n    # Initialization Functions\n    ###########################################################\n\n    def __init__(\n        self, value: str = \"\", position: Tuple[int, int] = (0, 0), **kwargs: Any\n    ) -&gt; None:\n        \"\"\"A Object can be initialized with as many or as few of its styling attributes as is desired.\n\n        Args:\n            value (str, optional): The text to fill the object with. Defaults to \"\".\n            position (tuple, optional): The position of the object in pixels, in (X, Y). Defaults to (0, 0).\n\n        Keyword Args:\n            aspect (optional): Aspect ratio handling. Defaults to None.\n            autocontract (bool, optional): Whether to contract to fit the child objects. Defaults to False.\n            autosize_margin (int, optional): What margin in pixels to leave around the child objects. Defaults to 20.\n            autosize_to_children (bool, optional): Whether to autoexpand when child objects are added. Defaults to False.\n            baseStyle (optional): Base style for the object. Defaults to None.\n            children (list of Objects, optional): The subobjects to add to this object as a parent. Defaults to [].\n            color_scheme (ColorScheme, optional): Bundled set of color specifications. Defaults to None.\n            comic (bool, optional): Add comic styling to the object. Defaults to None.\n            fillColor (Union[str, StandardColor], optional): The object fill color. Defaults to None.\n            glass (bool, optional): Apply glass styling to the object. Defaults to None.\n            height (int, optional): The height of the object in pixels. Defaults to 80.\n            in_edges (list, optional): List of incoming edges to this object. Defaults to [].\n            line_pattern (str, optional): The stroke style of the object. Defaults to \"solid\".\n            opacity (int, optional): The object's opacity, 0-100. Defaults to None.\n            out_edges (list, optional): List of outgoing edges from this object. Defaults to [].\n            parent (Object, optional): The parent object (container, etc) of this object. Defaults to None.\n            position_rel_to_parent (tuple, optional): The position of the object relative to the parent in pixels, in (X, Y).\n            rounded (int or bool, optional): Whether to round the corners of the shape. Defaults to 0.\n            shadow (bool, optional): Add a shadow to the object. Defaults to None.\n            sketch (bool, optional): Add sketch styling to the object. Defaults to None.\n            strokeColor (Union[str, StandardColor], optional): The object stroke color. Defaults to None.\n            template_object (Object, optional): Another object to copy the style_attributes from. Defaults to None.\n            text_format (TextFormat, optional): Formatting specifically around text. Defaults to TextFormat().\n            vertex (int, optional): Vertex flag for the object. Defaults to 1.\n            whiteSpace (str, optional): White space handling. Defaults to \"wrap\".\n            width (int, optional): The width of the object in pixels. Defaults to 120.\n        \"\"\"\n        super().__init__(**kwargs)\n        self._style_attributes: List[str] = [\n            \"whiteSpace\",\n            \"rounded\",\n            \"fillColor\",\n            \"strokeColor\",\n            \"glass\",\n            \"shadow\",\n            \"comic\",\n            \"sketch\",\n            \"opacity\",\n            \"dashed\",\n        ]\n\n        self.geometry: Geometry = Geometry(parent_object=self)\n\n        # Subobjecting\n        # If there is a parent passed in, disable that parents\n        # autoexpanding until position is set\n        if \"parent\" in kwargs:\n            parent: Object = kwargs.get(\"parent\")\n            old_parent_autosize: bool = parent.autosize_to_children\n            parent.autoexpand = False\n            self.parent: Optional[Object] = parent\n        else:\n            self._parent: Optional[Object] = None\n        self.children: List[Object] = kwargs.get(\"children\", [])\n        self.autosize_to_children: bool = kwargs.get(\"autosize_to_children\", False)\n        self.autocontract: bool = kwargs.get(\"autocontract\", False)\n        self.autosize_margin: int = kwargs.get(\"autosize_margin\", 20)\n\n        # Geometry\n        self.position: Optional[tuple] = position\n        # Since the position is already set to either a passed in arg or the default this will\n        # either override that default position or redundantly reset the position to the same value\n        self.position_rel_to_parent: Optional[tuple] = kwargs.get(\n            \"position_rel_to_parent\", position\n        )\n        self.width: int = kwargs.get(\"width\", 120)\n        self.height: int = kwargs.get(\"height\", 80)\n        self.vertex: int = kwargs.get(\"vertex\", 1)\n\n        # TODO enumerate to fixed\n        self.aspect = kwargs.get(\"aspect\", None)\n\n        # Style\n        self.baseStyle: Optional[str] = kwargs.get(\"baseStyle\", None)\n\n        self.rounded: Optional[bool] = kwargs.get(\"rounded\", 0)\n        self.whiteSpace: Optional[str] = kwargs.get(\"whiteSpace\", \"wrap\")\n        self.opacity: Optional[int] = kwargs.get(\"opacity\", None)\n        self.color_scheme: Optional[ColorScheme] = kwargs.get(\"color_scheme\", None)\n        self.strokeColor: Optional[Union[str, StandardColor]] = kwargs.get(\n            \"strokeColor\"\n        ) or (self.color_scheme.stroke_color if self.color_scheme else None)\n        self.fillColor: Optional[Union[str, StandardColor]] = kwargs.get(\n            \"fillColor\"\n        ) or (self.color_scheme.fill_color if self.color_scheme else None)\n        self.glass: Optional[bool] = kwargs.get(\"glass\", None)\n        self.shadow: Optional[bool] = kwargs.get(\"shadow\", None)\n        self.comic: Optional[bool] = kwargs.get(\"comic\", None)\n        self.sketch: Optional[bool] = kwargs.get(\"sketch\", None)\n        self.line_pattern: Optional[str] = kwargs.get(\"line_pattern\", \"solid\")\n\n        self.out_edges: List[Any] = kwargs.get(\"out_edges\", [])\n        self.in_edges: List[Any] = kwargs.get(\"in_edges\", [])\n\n        self.xml_class: str = \"mxCell\"\n\n        if \"template_object\" in kwargs:\n            self.template_object: Object = kwargs.get(\"template_object\")\n            self._apply_style_from_template(self.template_object)\n            self.width = self.template_object.width\n            self.height = self.template_object.height\n\n        # Content\n        self.text_format: Optional[TextFormat] = kwargs.get(\"text_format\", TextFormat())\n        if not self.text_format.fontColor and self.color_scheme:\n            self.text_format.fontColor = self.color_scheme.font_color\n        self.value: Optional[str] = value\n\n        # If a parent was passed in, reactivate the parents autoexpanding and update it\n        if \"parent\" in kwargs:\n            self.parent.autosize_to_children = old_parent_autosize\n            self.update_parent()\n\n        logger.debug(f\"\ud83d\udd32 Object created: {self.__repr__()}\")\n\n    def __repr__(self) -&gt; str:\n        \"\"\"\n        A more informative representation for debugging.\n        \"\"\"\n        parts = []\n\n        # Geometry\n        parts.append(f\"pos: {self.position}\")\n        parts.append(f\"size: ({self.width}x{self.height})\")\n\n        # Parent info\n        if getattr(self, \"parent\", None):\n            parts.append(f\"parent: {self.parent.__class__.__name__}\")\n\n        # Child count\n        if getattr(self, \"children\", None):\n            parts.append(f\"children: {len(self.children)}\")\n\n        joined = \" | \".join(parts)\n        return f\"{self.value} | {joined}\"\n\n    def __str__(self) -&gt; str:\n        return self.__repr__()\n\n    def __delete__(self) -&gt; None:\n        self.page.remove_object(self)\n\n    @classmethod\n    def create_from_template_object(\n        cls,\n        template_object: \"Object\",\n        value: Optional[str] = None,\n        position: Optional[Tuple[int, int]] = None,\n        page: Optional[Any] = None,\n    ) -&gt; \"Object\":\n        \"\"\"Object can be instantiated from another object. This will initialize the Object with the same formatting, then set a new position and value.\n\n        Args:\n            template_object (Object): Another drawpyo Object to use as a template\n            value (str, optional): The text contents of the object. Defaults to None.\n            position (tuple, optional): The position where the object should be placed. Defaults to (0, 0).\n            page (Page, optional): The Page object to place the object on. Defaults to None.\n\n        Returns:\n            Object: The newly created object\n        \"\"\"\n        new_obj: Object = cls(\n            value=value,\n            page=page,\n            width=template_object.width,\n            height=template_object.height,\n            template_object=template_object,\n        )\n        if position is not None:\n            new_obj.position = position\n        if value is not None:\n            new_obj.value = value\n        return new_obj\n\n    @classmethod\n    def create_from_style_string(cls, style_string: str) -&gt; \"Object\":\n        \"\"\"Objects can be instantiated from a style string. These strings are most easily found in the Draw.io app, by styling an object as desired then right-clicking and selecting \"Edit Style\". Copying that text into this function will generate an object styled the same.\n\n        Args:\n            style_string (str): A Draw.io generated style string.\n\n        Returns:\n            Object: An object formatted with the style string\n        \"\"\"\n        cls.apply_style_from_string(style_string)\n        return cls\n\n    @classmethod\n    def create_from_library(\n        cls, library: Union[str, Dict[str, Any]], obj_name: str\n    ) -&gt; \"Object\":\n        \"\"\"This function generates a Object from a library. The library can either be custom imported from a TOML or the name of one of the built-in Draw.io libraries.\n\n        Any keyword arguments that can be passed in to a Object creation can be passed into this function and it will format the base object. However, the styling in the library will overwrite that formatting.\n\n        Args:\n            library (str or dict): The library containing the object\n            obj_name (str): The name of the object in the library to generate\n\n        Returns:\n            Object: An object with the style from the library\n        \"\"\"\n        new_obj: Object = cls()\n        new_obj.format_as_library_object(library, obj_name)\n        return new_obj\n\n    def format_as_library_object(\n        self, library: Union[str, Dict[str, Any]], obj_name: str\n    ) -&gt; None:\n        \"\"\"This function applies the style from a library to an existing object. The library can either be custom imported from a TOML or the name of one of the built-in Draw.io libraries.\n\n        Args:\n            library (str or dict): The library containing the object\n            obj_name (str): The name of the object in the library to generate\n        \"\"\"\n        if type(library) == str:\n            if library in base_libraries:\n                library_dict: Dict[str, Any] = base_libraries[library]\n                if obj_name in library_dict:\n                    obj_dict: Dict[str, Any] = library_dict[obj_name]\n                    self.apply_attribute_dict(obj_dict)\n                else:\n                    raise ValueError(\n                        \"Object {0} not in Library {1}\".format(obj_name, library)\n                    )\n            else:\n                raise ValueError(\"Library {0} not in base_libraries\".format(library))\n        elif type(library) == dict:\n            obj_dict: Dict[str, Any] = library[obj_name]\n            self.apply_attribute_dict(obj_dict)\n        else:\n            raise ValueError(\"Unparseable libary passed in.\")\n\n    @property\n    def attributes(self) -&gt; Dict[str, Any]:\n        return {\n            \"id\": self.id,\n            \"value\": self.value,\n            \"style\": self.style,\n            \"vertex\": self.vertex,\n            \"parent\": self.xml_parent_id,\n        }\n\n    ###########################################################\n    # Style templates\n    ###########################################################\n\n    @property\n    def line_styles(self) -&gt; Dict[str, Any]:\n        return line_styles\n\n    @property\n    def container(self) -&gt; Dict[Optional[str], None]:\n        return container\n\n    ###########################################################\n    # Style properties\n    ###########################################################\n\n    @property\n    def line_pattern(self) -&gt; Optional[str]:\n        \"\"\"Two properties are enumerated together into line_pattern: dashed and dashPattern. line_pattern simplifies this with an external database that contains the dropdown options from the Draw.io app then outputs the correct combination of dashed and dashPattern.\n\n        However in some cases dashed and dashpattern need to be set individually, such as when formatting from a style string. In that case, the setters for those two attributes will disable the other.\n\n        Returns:\n            str: The line style\n        \"\"\"\n        return self._line_pattern\n\n    @line_pattern.setter\n    def line_pattern(self, value: str) -&gt; None:\n        if value in line_styles.keys():\n            self._line_pattern = value\n        else:\n            raise ValueError(\n                \"{0} is not an allowed value of line_pattern\".format(value)\n            )\n\n    @property\n    def dashed(self) -&gt; Optional[Union[bool, Any]]:\n        \"\"\"This is one of the properties that defines the line style. Along with dashPattern, it can be overriden by setting line_pattern or set directly.\n\n        Returns:\n            str: Whether the object stroke is dashed.\n        \"\"\"\n        if self._line_pattern is None:\n            return self._dashed\n        else:\n            return line_styles[self._line_pattern]\n\n    @dashed.setter\n    def dashed(self, value: bool) -&gt; None:\n        self._line_pattern = None\n        self._dashed = value\n\n    @property\n    def dashPattern(self) -&gt; Optional[Union[str, Any]]:\n        \"\"\"This is one of the properties that defines the line style. Along with dashed, it can be overriden by setting line_pattern or set directly.\n\n        Returns:\n            str: What style the object stroke is dashed with.\n        \"\"\"\n        if self._line_pattern is None:\n            return self._dashPattern\n        else:\n            return line_styles[self._line_pattern]\n\n    @dashPattern.setter\n    def dashPattern(self, value: str) -&gt; None:\n        self._line_pattern = None\n        self._dashPattern = value\n\n    ###########################################################\n    # Geometry properties\n    ###########################################################\n\n    @property\n    def width(self) -&gt; int:\n        \"\"\"This property makes geometry.width available to the owning class for ease of access.\"\"\"\n        return self.geometry.width\n\n    @width.setter\n    def width(self, value: int) -&gt; None:\n        self.geometry.width = value\n        self.update_parent()\n\n    @property\n    def height(self) -&gt; int:\n        \"\"\"This property makes geometry.height available to the owning class for ease of access.\"\"\"\n        return self.geometry.height\n\n    @height.setter\n    def height(self, value: int) -&gt; None:\n        self.geometry.height = value\n        self.update_parent()\n\n    # Position property\n    @property\n    def position(self) -&gt; Tuple[Union[int, float], Union[int, float]]:\n        \"\"\"The position of the object on the page. This is the top left corner. It's set with a tuple of ints, X and Y respectively.\n\n        (X, Y)\n\n        Returns:\n            tuple: A tuple of ints describing the top left corner position of the object\n        \"\"\"\n        if self.parent is not None:\n            return (\n                self.geometry.x + self.parent.position[0],\n                self.geometry.y + self.parent.position[1],\n            )\n        return (self.geometry.x, self.geometry.y)\n\n    @position.setter\n    def position(self, value: Tuple[Union[int, float], Union[int, float]]) -&gt; None:\n        if self.parent is not None:\n            self.geometry.x = value[0] - self.parent.position[0]\n            self.geometry.y = value[1] - self.parent.position[1]\n        else:\n            self.geometry.x = value[0]\n            self.geometry.y = value[1]\n        self.update_parent()\n\n    # Position Rel to Parent\n    @property\n    def position_rel_to_parent(self) -&gt; Tuple[Union[int, float], Union[int, float]]:\n        \"\"\"The position of the object relative to its parent (container). If there's no parent this will be relative to the page. This is the top left corner. It's set with a tuple of ints, X and Y respectively.\n\n        (X, Y)\n\n        Returns:\n            tuple: A tuple of ints describing the top left corner position of the object\n        \"\"\"\n        return (self.geometry.x, self.geometry.y)\n\n    @position_rel_to_parent.setter\n    def position_rel_to_parent(\n        self, value: Tuple[Union[int, float], Union[int, float]]\n    ) -&gt; None:\n        self.geometry.x = value[0]\n        self.geometry.y = value[1]\n        self.update_parent()\n\n    @property\n    def center_position(self) -&gt; Tuple[Union[int, float], Union[int, float]]:\n        \"\"\"The position of the object on the page. This is the center of the object. It's set with a tuple of ints, X and Y respectively.\n\n        (X, Y)\n\n        Returns:\n            tuple: A tuple of ints describing the center position of the object\n        \"\"\"\n        x: Union[int, float] = self.geometry.x + self.geometry.width / 2\n        y: Union[int, float] = self.geometry.y + self.geometry.height / 2\n        return (x, y)\n\n    @center_position.setter\n    def center_position(\n        self, position: Tuple[Union[int, float], Union[int, float]]\n    ) -&gt; None:\n        self.geometry.x = position[0] - self.geometry.width / 2\n        self.geometry.y = position[1] - self.geometry.height / 2\n\n    ###########################################################\n    # Subobjects\n    ###########################################################\n    # TODO add to documentation\n\n    @property\n    def xml_parent_id(self) -&gt; Union[int, Any]:\n        if self.parent is not None:\n            return self.parent.id\n        return 1\n\n    @property\n    def parent(self) -&gt; Optional[\"Object\"]:\n        \"\"\"The parent object that owns this object. This is usually a container of some kind but can be any other object.\n\n        Returns:\n            Object: the parent object.\n        \"\"\"\n        return self._parent\n\n    @parent.setter\n    def parent(self, value: Optional[\"Object\"]) -&gt; None:\n        if isinstance(value, Object):\n            # value.add_object(self)\n            value.children.append(self)\n            self.update_parent()\n        self._parent = value\n\n    def add_object(self, child_object: \"Object\") -&gt; None:\n        \"\"\"Adds a child object to this object, sets the child objects parent, and autoexpands this object if set to.\n\n        Args:\n            child_object (Object): object to add as a child\n        \"\"\"\n        child_object._parent = self  # Bypass the setter to prevent a loop\n        self.children.append(child_object)\n        if self.autosize_to_children:\n            self.resize_to_children()\n\n    def remove_object(self, child_object: \"Object\") -&gt; None:\n        \"\"\"Removes a child object from this object, clears the child objects parent, and autoexpands this object if set to.\n\n        Args:\n            child_object (Object): object to remove as a child\n        \"\"\"\n        child_object._parent = None  # Bypass the setter to prevent a loop\n        self.children.remove(child_object)\n        if self.autosize_to_children:\n            self.resize_to_children()\n\n    def update_parent(self) -&gt; None:\n        \"\"\"If a parent object is set and the parent is set to autoexpand, then autoexpand it.\"\"\"\n        # This function needs to be callable prior to the parent being set during init,\n        # hence the hasattr() check.\n        if (\n            hasattr(self, \"_parent\")\n            and self.parent is not None\n            and self.parent.autosize_to_children\n        ):\n            # if the parent is autoexpanding, call the autoexpand function\n            self.parent.resize_to_children()\n\n    def resize_to_children(self) -&gt; None:\n        \"\"\"If the object contains children (is a container, parent, etc) then expand the size and position to fit all of the children.\n\n        By default this function will never shrink the size of the object, only expand it. The contract input can be set for that behavior.\n\n        Args:\n            contract (bool, optional): Contract the parent object to hug the children. Defaults to False.\n        \"\"\"\n        # Get current extents\n        if len(self.children) == 0:\n            return\n        if self.autocontract:\n            topmost: Union[int, float] = 65536\n            bottommost: Union[int, float] = -65536\n            leftmost: Union[int, float] = 65536\n            rightmost: Union[int, float] = -65536\n        else:\n            topmost: Union[int, float] = self.position[1]\n            bottommost: Union[int, float] = self.position[1] + self.height\n            leftmost: Union[int, float] = self.position[0]\n            rightmost: Union[int, float] = self.position[0] + self.width\n\n        # Check all child objects for extents\n        for child_object in self.children:\n            topmost = min(topmost, child_object.position[1] - self.autosize_margin)\n            bottommost = max(\n                bottommost,\n                child_object.position[1] + child_object.height + self.autosize_margin,\n            )\n            leftmost = min(leftmost, child_object.position[0] - self.autosize_margin)\n            rightmost = max(\n                rightmost,\n                child_object.position[0] + child_object.width + self.autosize_margin,\n            )\n\n        # Set self extents to furthest positions\n        self.move_wo_children((leftmost, topmost))\n        self.width = rightmost - leftmost\n        self.height = bottommost - topmost\n\n    def move_wo_children(\n        self, position: Tuple[Union[int, float], Union[int, float]]\n    ) -&gt; None:\n        \"\"\"Move the parent object relative to the page without moving the children relative to the page.\n\n        Args:\n            position (Tuple of Ints): The target position for the parent object.\n        \"\"\"\n        # Disable autoexpand to avoid recursion from child_objects\n        # attempting to update their autoexpanding parent upon a move\n        old_autoexpand: bool = self.autosize_to_children\n        self.autosize_to_children = False\n\n        # Move children to counter upcoming parent move\n        pos_delta: List[Union[int, float]] = [\n            old_pos - new_pos for old_pos, new_pos in zip(self.position, position)\n        ]\n        for child_object in self.children:\n            child_object.position = (\n                child_object.position[0] + pos_delta[0],\n                child_object.position[1] + pos_delta[1],\n            )\n\n        # Set new position and re-enable autoexpand\n        self.position = position\n        self.autosize_to_children = old_autoexpand\n\n    ###########################################################\n    # Edge Tracking\n    ###########################################################\n\n    def add_out_edge(self, edge: Any) -&gt; None:\n        \"\"\"Add an edge out of the object. If an edge is created with this object set as the source this function will be called automatically.\n\n        Args:\n            edge (Edge): An Edge object originating at this object\n        \"\"\"\n        self.out_edges.append(edge)\n\n    def remove_out_edge(self, edge: Any) -&gt; None:\n        \"\"\"Remove an edge out of the object. If an edge linked to this object has the source changed or removed this function will be called automatically.\n\n        Args:\n            edge (Edge): An Edge object originating at this object\n        \"\"\"\n        self.out_edges.remove(edge)\n\n    def add_in_edge(self, edge: Any) -&gt; None:\n        \"\"\"Add an edge into the object. If an edge is created with this object set as the target this function will be called automatically.\n\n        Args:\n            edge (Edge): An Edge object ending at this object\n        \"\"\"\n        self.in_edges.append(edge)\n\n    def remove_in_edge(self, edge: Any) -&gt; None:\n        \"\"\"Remove an edge into the object. If an edge linked to this object has the target changed or removed this function will be called automatically.\n\n        Args:\n            edge (Edge): An Edge object ending at this object\n        \"\"\"\n        self.in_edges.remove(edge)\n\n    ###########################################################\n    # XML Generation\n    ###########################################################\n\n    @property\n    def xml(self) -&gt; str:\n        \"\"\"\n        Returns the XML object for the Object: the opening tag with the style attributes, the value, and the closing tag.\n\n        Example:\n        &lt;class_name attribute_name=attribute_value&gt;Text in object&lt;/class_name&gt;\n\n        Returns:\n            str: A single XML tag containing the object name, style attributes, and a closer.\n        \"\"\"\n        tag: str = (\n            self.xml_open_tag + \"\\n  \" + self.geometry.xml + \"\\n\" + self.xml_close_tag\n        )\n        return tag\n</code></pre>"},{"location":"api/objects/#src.drawpyo.diagram.objects.Object.center_position","title":"<code>center_position</code>  <code>property</code> <code>writable</code>","text":"<p>The position of the object on the page. This is the center of the object. It's set with a tuple of ints, X and Y respectively.</p> <p>(X, Y)</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[Union[int, float], Union[int, float]]</code> <p>A tuple of ints describing the center position of the object</p>"},{"location":"api/objects/#src.drawpyo.diagram.objects.Object.dashPattern","title":"<code>dashPattern</code>  <code>property</code> <code>writable</code>","text":"<p>This is one of the properties that defines the line style. Along with dashed, it can be overriden by setting line_pattern or set directly.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>Optional[Union[str, Any]]</code> <p>What style the object stroke is dashed with.</p>"},{"location":"api/objects/#src.drawpyo.diagram.objects.Object.dashed","title":"<code>dashed</code>  <code>property</code> <code>writable</code>","text":"<p>This is one of the properties that defines the line style. Along with dashPattern, it can be overriden by setting line_pattern or set directly.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>Optional[Union[bool, Any]]</code> <p>Whether the object stroke is dashed.</p>"},{"location":"api/objects/#src.drawpyo.diagram.objects.Object.height","title":"<code>height</code>  <code>property</code> <code>writable</code>","text":"<p>This property makes geometry.height available to the owning class for ease of access.</p>"},{"location":"api/objects/#src.drawpyo.diagram.objects.Object.line_pattern","title":"<code>line_pattern</code>  <code>property</code> <code>writable</code>","text":"<p>Two properties are enumerated together into line_pattern: dashed and dashPattern. line_pattern simplifies this with an external database that contains the dropdown options from the Draw.io app then outputs the correct combination of dashed and dashPattern.</p> <p>However in some cases dashed and dashpattern need to be set individually, such as when formatting from a style string. In that case, the setters for those two attributes will disable the other.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>Optional[str]</code> <p>The line style</p>"},{"location":"api/objects/#src.drawpyo.diagram.objects.Object.parent","title":"<code>parent</code>  <code>property</code> <code>writable</code>","text":"<p>The parent object that owns this object. This is usually a container of some kind but can be any other object.</p> <p>Returns:</p> Name Type Description <code>Object</code> <code>Optional[Object]</code> <p>the parent object.</p>"},{"location":"api/objects/#src.drawpyo.diagram.objects.Object.position","title":"<code>position</code>  <code>property</code> <code>writable</code>","text":"<p>The position of the object on the page. This is the top left corner. It's set with a tuple of ints, X and Y respectively.</p> <p>(X, Y)</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[Union[int, float], Union[int, float]]</code> <p>A tuple of ints describing the top left corner position of the object</p>"},{"location":"api/objects/#src.drawpyo.diagram.objects.Object.position_rel_to_parent","title":"<code>position_rel_to_parent</code>  <code>property</code> <code>writable</code>","text":"<p>The position of the object relative to its parent (container). If there's no parent this will be relative to the page. This is the top left corner. It's set with a tuple of ints, X and Y respectively.</p> <p>(X, Y)</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[Union[int, float], Union[int, float]]</code> <p>A tuple of ints describing the top left corner position of the object</p>"},{"location":"api/objects/#src.drawpyo.diagram.objects.Object.width","title":"<code>width</code>  <code>property</code> <code>writable</code>","text":"<p>This property makes geometry.width available to the owning class for ease of access.</p>"},{"location":"api/objects/#src.drawpyo.diagram.objects.Object.xml","title":"<code>xml</code>  <code>property</code>","text":"<p>Returns the XML object for the Object: the opening tag with the style attributes, the value, and the closing tag.</p> <p>Example: Text in object</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A single XML tag containing the object name, style attributes, and a closer.</p>"},{"location":"api/objects/#src.drawpyo.diagram.objects.Object.__init__","title":"<code>__init__(value='', position=(0, 0), **kwargs)</code>","text":"<p>A Object can be initialized with as many or as few of its styling attributes as is desired.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>The text to fill the object with. Defaults to \"\".</p> <code>''</code> <code>position</code> <code>tuple</code> <p>The position of the object in pixels, in (X, Y). Defaults to (0, 0).</p> <code>(0, 0)</code> <p>Other Parameters:</p> Name Type Description <code>aspect</code> <code>optional</code> <p>Aspect ratio handling. Defaults to None.</p> <code>autocontract</code> <code>bool</code> <p>Whether to contract to fit the child objects. Defaults to False.</p> <code>autosize_margin</code> <code>int</code> <p>What margin in pixels to leave around the child objects. Defaults to 20.</p> <code>autosize_to_children</code> <code>bool</code> <p>Whether to autoexpand when child objects are added. Defaults to False.</p> <code>baseStyle</code> <code>optional</code> <p>Base style for the object. Defaults to None.</p> <code>children</code> <code>list of Objects</code> <p>The subobjects to add to this object as a parent. Defaults to [].</p> <code>color_scheme</code> <code>ColorScheme</code> <p>Bundled set of color specifications. Defaults to None.</p> <code>comic</code> <code>bool</code> <p>Add comic styling to the object. Defaults to None.</p> <code>fillColor</code> <code>Union[str, StandardColor]</code> <p>The object fill color. Defaults to None.</p> <code>glass</code> <code>bool</code> <p>Apply glass styling to the object. Defaults to None.</p> <code>height</code> <code>int</code> <p>The height of the object in pixels. Defaults to 80.</p> <code>in_edges</code> <code>list</code> <p>List of incoming edges to this object. Defaults to [].</p> <code>line_pattern</code> <code>str</code> <p>The stroke style of the object. Defaults to \"solid\".</p> <code>opacity</code> <code>int</code> <p>The object's opacity, 0-100. Defaults to None.</p> <code>out_edges</code> <code>list</code> <p>List of outgoing edges from this object. Defaults to [].</p> <code>parent</code> <code>Object</code> <p>The parent object (container, etc) of this object. Defaults to None.</p> <code>position_rel_to_parent</code> <code>tuple</code> <p>The position of the object relative to the parent in pixels, in (X, Y).</p> <code>rounded</code> <code>int or bool</code> <p>Whether to round the corners of the shape. Defaults to 0.</p> <code>shadow</code> <code>bool</code> <p>Add a shadow to the object. Defaults to None.</p> <code>sketch</code> <code>bool</code> <p>Add sketch styling to the object. Defaults to None.</p> <code>strokeColor</code> <code>Union[str, StandardColor]</code> <p>The object stroke color. Defaults to None.</p> <code>template_object</code> <code>Object</code> <p>Another object to copy the style_attributes from. Defaults to None.</p> <code>text_format</code> <code>TextFormat</code> <p>Formatting specifically around text. Defaults to TextFormat().</p> <code>vertex</code> <code>int</code> <p>Vertex flag for the object. Defaults to 1.</p> <code>whiteSpace</code> <code>str</code> <p>White space handling. Defaults to \"wrap\".</p> <code>width</code> <code>int</code> <p>The width of the object in pixels. Defaults to 120.</p> Source code in <code>src/drawpyo/diagram/objects.py</code> <pre><code>def __init__(\n    self, value: str = \"\", position: Tuple[int, int] = (0, 0), **kwargs: Any\n) -&gt; None:\n    \"\"\"A Object can be initialized with as many or as few of its styling attributes as is desired.\n\n    Args:\n        value (str, optional): The text to fill the object with. Defaults to \"\".\n        position (tuple, optional): The position of the object in pixels, in (X, Y). Defaults to (0, 0).\n\n    Keyword Args:\n        aspect (optional): Aspect ratio handling. Defaults to None.\n        autocontract (bool, optional): Whether to contract to fit the child objects. Defaults to False.\n        autosize_margin (int, optional): What margin in pixels to leave around the child objects. Defaults to 20.\n        autosize_to_children (bool, optional): Whether to autoexpand when child objects are added. Defaults to False.\n        baseStyle (optional): Base style for the object. Defaults to None.\n        children (list of Objects, optional): The subobjects to add to this object as a parent. Defaults to [].\n        color_scheme (ColorScheme, optional): Bundled set of color specifications. Defaults to None.\n        comic (bool, optional): Add comic styling to the object. Defaults to None.\n        fillColor (Union[str, StandardColor], optional): The object fill color. Defaults to None.\n        glass (bool, optional): Apply glass styling to the object. Defaults to None.\n        height (int, optional): The height of the object in pixels. Defaults to 80.\n        in_edges (list, optional): List of incoming edges to this object. Defaults to [].\n        line_pattern (str, optional): The stroke style of the object. Defaults to \"solid\".\n        opacity (int, optional): The object's opacity, 0-100. Defaults to None.\n        out_edges (list, optional): List of outgoing edges from this object. Defaults to [].\n        parent (Object, optional): The parent object (container, etc) of this object. Defaults to None.\n        position_rel_to_parent (tuple, optional): The position of the object relative to the parent in pixels, in (X, Y).\n        rounded (int or bool, optional): Whether to round the corners of the shape. Defaults to 0.\n        shadow (bool, optional): Add a shadow to the object. Defaults to None.\n        sketch (bool, optional): Add sketch styling to the object. Defaults to None.\n        strokeColor (Union[str, StandardColor], optional): The object stroke color. Defaults to None.\n        template_object (Object, optional): Another object to copy the style_attributes from. Defaults to None.\n        text_format (TextFormat, optional): Formatting specifically around text. Defaults to TextFormat().\n        vertex (int, optional): Vertex flag for the object. Defaults to 1.\n        whiteSpace (str, optional): White space handling. Defaults to \"wrap\".\n        width (int, optional): The width of the object in pixels. Defaults to 120.\n    \"\"\"\n    super().__init__(**kwargs)\n    self._style_attributes: List[str] = [\n        \"whiteSpace\",\n        \"rounded\",\n        \"fillColor\",\n        \"strokeColor\",\n        \"glass\",\n        \"shadow\",\n        \"comic\",\n        \"sketch\",\n        \"opacity\",\n        \"dashed\",\n    ]\n\n    self.geometry: Geometry = Geometry(parent_object=self)\n\n    # Subobjecting\n    # If there is a parent passed in, disable that parents\n    # autoexpanding until position is set\n    if \"parent\" in kwargs:\n        parent: Object = kwargs.get(\"parent\")\n        old_parent_autosize: bool = parent.autosize_to_children\n        parent.autoexpand = False\n        self.parent: Optional[Object] = parent\n    else:\n        self._parent: Optional[Object] = None\n    self.children: List[Object] = kwargs.get(\"children\", [])\n    self.autosize_to_children: bool = kwargs.get(\"autosize_to_children\", False)\n    self.autocontract: bool = kwargs.get(\"autocontract\", False)\n    self.autosize_margin: int = kwargs.get(\"autosize_margin\", 20)\n\n    # Geometry\n    self.position: Optional[tuple] = position\n    # Since the position is already set to either a passed in arg or the default this will\n    # either override that default position or redundantly reset the position to the same value\n    self.position_rel_to_parent: Optional[tuple] = kwargs.get(\n        \"position_rel_to_parent\", position\n    )\n    self.width: int = kwargs.get(\"width\", 120)\n    self.height: int = kwargs.get(\"height\", 80)\n    self.vertex: int = kwargs.get(\"vertex\", 1)\n\n    # TODO enumerate to fixed\n    self.aspect = kwargs.get(\"aspect\", None)\n\n    # Style\n    self.baseStyle: Optional[str] = kwargs.get(\"baseStyle\", None)\n\n    self.rounded: Optional[bool] = kwargs.get(\"rounded\", 0)\n    self.whiteSpace: Optional[str] = kwargs.get(\"whiteSpace\", \"wrap\")\n    self.opacity: Optional[int] = kwargs.get(\"opacity\", None)\n    self.color_scheme: Optional[ColorScheme] = kwargs.get(\"color_scheme\", None)\n    self.strokeColor: Optional[Union[str, StandardColor]] = kwargs.get(\n        \"strokeColor\"\n    ) or (self.color_scheme.stroke_color if self.color_scheme else None)\n    self.fillColor: Optional[Union[str, StandardColor]] = kwargs.get(\n        \"fillColor\"\n    ) or (self.color_scheme.fill_color if self.color_scheme else None)\n    self.glass: Optional[bool] = kwargs.get(\"glass\", None)\n    self.shadow: Optional[bool] = kwargs.get(\"shadow\", None)\n    self.comic: Optional[bool] = kwargs.get(\"comic\", None)\n    self.sketch: Optional[bool] = kwargs.get(\"sketch\", None)\n    self.line_pattern: Optional[str] = kwargs.get(\"line_pattern\", \"solid\")\n\n    self.out_edges: List[Any] = kwargs.get(\"out_edges\", [])\n    self.in_edges: List[Any] = kwargs.get(\"in_edges\", [])\n\n    self.xml_class: str = \"mxCell\"\n\n    if \"template_object\" in kwargs:\n        self.template_object: Object = kwargs.get(\"template_object\")\n        self._apply_style_from_template(self.template_object)\n        self.width = self.template_object.width\n        self.height = self.template_object.height\n\n    # Content\n    self.text_format: Optional[TextFormat] = kwargs.get(\"text_format\", TextFormat())\n    if not self.text_format.fontColor and self.color_scheme:\n        self.text_format.fontColor = self.color_scheme.font_color\n    self.value: Optional[str] = value\n\n    # If a parent was passed in, reactivate the parents autoexpanding and update it\n    if \"parent\" in kwargs:\n        self.parent.autosize_to_children = old_parent_autosize\n        self.update_parent()\n\n    logger.debug(f\"\ud83d\udd32 Object created: {self.__repr__()}\")\n</code></pre>"},{"location":"api/objects/#src.drawpyo.diagram.objects.Object.__repr__","title":"<code>__repr__()</code>","text":"<p>A more informative representation for debugging.</p> Source code in <code>src/drawpyo/diagram/objects.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"\n    A more informative representation for debugging.\n    \"\"\"\n    parts = []\n\n    # Geometry\n    parts.append(f\"pos: {self.position}\")\n    parts.append(f\"size: ({self.width}x{self.height})\")\n\n    # Parent info\n    if getattr(self, \"parent\", None):\n        parts.append(f\"parent: {self.parent.__class__.__name__}\")\n\n    # Child count\n    if getattr(self, \"children\", None):\n        parts.append(f\"children: {len(self.children)}\")\n\n    joined = \" | \".join(parts)\n    return f\"{self.value} | {joined}\"\n</code></pre>"},{"location":"api/objects/#src.drawpyo.diagram.objects.Object.add_in_edge","title":"<code>add_in_edge(edge)</code>","text":"<p>Add an edge into the object. If an edge is created with this object set as the target this function will be called automatically.</p> <p>Parameters:</p> Name Type Description Default <code>edge</code> <code>Edge</code> <p>An Edge object ending at this object</p> required Source code in <code>src/drawpyo/diagram/objects.py</code> <pre><code>def add_in_edge(self, edge: Any) -&gt; None:\n    \"\"\"Add an edge into the object. If an edge is created with this object set as the target this function will be called automatically.\n\n    Args:\n        edge (Edge): An Edge object ending at this object\n    \"\"\"\n    self.in_edges.append(edge)\n</code></pre>"},{"location":"api/objects/#src.drawpyo.diagram.objects.Object.add_object","title":"<code>add_object(child_object)</code>","text":"<p>Adds a child object to this object, sets the child objects parent, and autoexpands this object if set to.</p> <p>Parameters:</p> Name Type Description Default <code>child_object</code> <code>Object</code> <p>object to add as a child</p> required Source code in <code>src/drawpyo/diagram/objects.py</code> <pre><code>def add_object(self, child_object: \"Object\") -&gt; None:\n    \"\"\"Adds a child object to this object, sets the child objects parent, and autoexpands this object if set to.\n\n    Args:\n        child_object (Object): object to add as a child\n    \"\"\"\n    child_object._parent = self  # Bypass the setter to prevent a loop\n    self.children.append(child_object)\n    if self.autosize_to_children:\n        self.resize_to_children()\n</code></pre>"},{"location":"api/objects/#src.drawpyo.diagram.objects.Object.add_out_edge","title":"<code>add_out_edge(edge)</code>","text":"<p>Add an edge out of the object. If an edge is created with this object set as the source this function will be called automatically.</p> <p>Parameters:</p> Name Type Description Default <code>edge</code> <code>Edge</code> <p>An Edge object originating at this object</p> required Source code in <code>src/drawpyo/diagram/objects.py</code> <pre><code>def add_out_edge(self, edge: Any) -&gt; None:\n    \"\"\"Add an edge out of the object. If an edge is created with this object set as the source this function will be called automatically.\n\n    Args:\n        edge (Edge): An Edge object originating at this object\n    \"\"\"\n    self.out_edges.append(edge)\n</code></pre>"},{"location":"api/objects/#src.drawpyo.diagram.objects.Object.create_from_library","title":"<code>create_from_library(library, obj_name)</code>  <code>classmethod</code>","text":"<p>This function generates a Object from a library. The library can either be custom imported from a TOML or the name of one of the built-in Draw.io libraries.</p> <p>Any keyword arguments that can be passed in to a Object creation can be passed into this function and it will format the base object. However, the styling in the library will overwrite that formatting.</p> <p>Parameters:</p> Name Type Description Default <code>library</code> <code>str or dict</code> <p>The library containing the object</p> required <code>obj_name</code> <code>str</code> <p>The name of the object in the library to generate</p> required <p>Returns:</p> Name Type Description <code>Object</code> <code>Object</code> <p>An object with the style from the library</p> Source code in <code>src/drawpyo/diagram/objects.py</code> <pre><code>@classmethod\ndef create_from_library(\n    cls, library: Union[str, Dict[str, Any]], obj_name: str\n) -&gt; \"Object\":\n    \"\"\"This function generates a Object from a library. The library can either be custom imported from a TOML or the name of one of the built-in Draw.io libraries.\n\n    Any keyword arguments that can be passed in to a Object creation can be passed into this function and it will format the base object. However, the styling in the library will overwrite that formatting.\n\n    Args:\n        library (str or dict): The library containing the object\n        obj_name (str): The name of the object in the library to generate\n\n    Returns:\n        Object: An object with the style from the library\n    \"\"\"\n    new_obj: Object = cls()\n    new_obj.format_as_library_object(library, obj_name)\n    return new_obj\n</code></pre>"},{"location":"api/objects/#src.drawpyo.diagram.objects.Object.create_from_style_string","title":"<code>create_from_style_string(style_string)</code>  <code>classmethod</code>","text":"<p>Objects can be instantiated from a style string. These strings are most easily found in the Draw.io app, by styling an object as desired then right-clicking and selecting \"Edit Style\". Copying that text into this function will generate an object styled the same.</p> <p>Parameters:</p> Name Type Description Default <code>style_string</code> <code>str</code> <p>A Draw.io generated style string.</p> required <p>Returns:</p> Name Type Description <code>Object</code> <code>Object</code> <p>An object formatted with the style string</p> Source code in <code>src/drawpyo/diagram/objects.py</code> <pre><code>@classmethod\ndef create_from_style_string(cls, style_string: str) -&gt; \"Object\":\n    \"\"\"Objects can be instantiated from a style string. These strings are most easily found in the Draw.io app, by styling an object as desired then right-clicking and selecting \"Edit Style\". Copying that text into this function will generate an object styled the same.\n\n    Args:\n        style_string (str): A Draw.io generated style string.\n\n    Returns:\n        Object: An object formatted with the style string\n    \"\"\"\n    cls.apply_style_from_string(style_string)\n    return cls\n</code></pre>"},{"location":"api/objects/#src.drawpyo.diagram.objects.Object.create_from_template_object","title":"<code>create_from_template_object(template_object, value=None, position=None, page=None)</code>  <code>classmethod</code>","text":"<p>Object can be instantiated from another object. This will initialize the Object with the same formatting, then set a new position and value.</p> <p>Parameters:</p> Name Type Description Default <code>template_object</code> <code>Object</code> <p>Another drawpyo Object to use as a template</p> required <code>value</code> <code>str</code> <p>The text contents of the object. Defaults to None.</p> <code>None</code> <code>position</code> <code>tuple</code> <p>The position where the object should be placed. Defaults to (0, 0).</p> <code>None</code> <code>page</code> <code>Page</code> <p>The Page object to place the object on. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Object</code> <code>Object</code> <p>The newly created object</p> Source code in <code>src/drawpyo/diagram/objects.py</code> <pre><code>@classmethod\ndef create_from_template_object(\n    cls,\n    template_object: \"Object\",\n    value: Optional[str] = None,\n    position: Optional[Tuple[int, int]] = None,\n    page: Optional[Any] = None,\n) -&gt; \"Object\":\n    \"\"\"Object can be instantiated from another object. This will initialize the Object with the same formatting, then set a new position and value.\n\n    Args:\n        template_object (Object): Another drawpyo Object to use as a template\n        value (str, optional): The text contents of the object. Defaults to None.\n        position (tuple, optional): The position where the object should be placed. Defaults to (0, 0).\n        page (Page, optional): The Page object to place the object on. Defaults to None.\n\n    Returns:\n        Object: The newly created object\n    \"\"\"\n    new_obj: Object = cls(\n        value=value,\n        page=page,\n        width=template_object.width,\n        height=template_object.height,\n        template_object=template_object,\n    )\n    if position is not None:\n        new_obj.position = position\n    if value is not None:\n        new_obj.value = value\n    return new_obj\n</code></pre>"},{"location":"api/objects/#src.drawpyo.diagram.objects.Object.format_as_library_object","title":"<code>format_as_library_object(library, obj_name)</code>","text":"<p>This function applies the style from a library to an existing object. The library can either be custom imported from a TOML or the name of one of the built-in Draw.io libraries.</p> <p>Parameters:</p> Name Type Description Default <code>library</code> <code>str or dict</code> <p>The library containing the object</p> required <code>obj_name</code> <code>str</code> <p>The name of the object in the library to generate</p> required Source code in <code>src/drawpyo/diagram/objects.py</code> <pre><code>def format_as_library_object(\n    self, library: Union[str, Dict[str, Any]], obj_name: str\n) -&gt; None:\n    \"\"\"This function applies the style from a library to an existing object. The library can either be custom imported from a TOML or the name of one of the built-in Draw.io libraries.\n\n    Args:\n        library (str or dict): The library containing the object\n        obj_name (str): The name of the object in the library to generate\n    \"\"\"\n    if type(library) == str:\n        if library in base_libraries:\n            library_dict: Dict[str, Any] = base_libraries[library]\n            if obj_name in library_dict:\n                obj_dict: Dict[str, Any] = library_dict[obj_name]\n                self.apply_attribute_dict(obj_dict)\n            else:\n                raise ValueError(\n                    \"Object {0} not in Library {1}\".format(obj_name, library)\n                )\n        else:\n            raise ValueError(\"Library {0} not in base_libraries\".format(library))\n    elif type(library) == dict:\n        obj_dict: Dict[str, Any] = library[obj_name]\n        self.apply_attribute_dict(obj_dict)\n    else:\n        raise ValueError(\"Unparseable libary passed in.\")\n</code></pre>"},{"location":"api/objects/#src.drawpyo.diagram.objects.Object.move_wo_children","title":"<code>move_wo_children(position)</code>","text":"<p>Move the parent object relative to the page without moving the children relative to the page.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>Tuple of Ints</code> <p>The target position for the parent object.</p> required Source code in <code>src/drawpyo/diagram/objects.py</code> <pre><code>def move_wo_children(\n    self, position: Tuple[Union[int, float], Union[int, float]]\n) -&gt; None:\n    \"\"\"Move the parent object relative to the page without moving the children relative to the page.\n\n    Args:\n        position (Tuple of Ints): The target position for the parent object.\n    \"\"\"\n    # Disable autoexpand to avoid recursion from child_objects\n    # attempting to update their autoexpanding parent upon a move\n    old_autoexpand: bool = self.autosize_to_children\n    self.autosize_to_children = False\n\n    # Move children to counter upcoming parent move\n    pos_delta: List[Union[int, float]] = [\n        old_pos - new_pos for old_pos, new_pos in zip(self.position, position)\n    ]\n    for child_object in self.children:\n        child_object.position = (\n            child_object.position[0] + pos_delta[0],\n            child_object.position[1] + pos_delta[1],\n        )\n\n    # Set new position and re-enable autoexpand\n    self.position = position\n    self.autosize_to_children = old_autoexpand\n</code></pre>"},{"location":"api/objects/#src.drawpyo.diagram.objects.Object.remove_in_edge","title":"<code>remove_in_edge(edge)</code>","text":"<p>Remove an edge into the object. If an edge linked to this object has the target changed or removed this function will be called automatically.</p> <p>Parameters:</p> Name Type Description Default <code>edge</code> <code>Edge</code> <p>An Edge object ending at this object</p> required Source code in <code>src/drawpyo/diagram/objects.py</code> <pre><code>def remove_in_edge(self, edge: Any) -&gt; None:\n    \"\"\"Remove an edge into the object. If an edge linked to this object has the target changed or removed this function will be called automatically.\n\n    Args:\n        edge (Edge): An Edge object ending at this object\n    \"\"\"\n    self.in_edges.remove(edge)\n</code></pre>"},{"location":"api/objects/#src.drawpyo.diagram.objects.Object.remove_object","title":"<code>remove_object(child_object)</code>","text":"<p>Removes a child object from this object, clears the child objects parent, and autoexpands this object if set to.</p> <p>Parameters:</p> Name Type Description Default <code>child_object</code> <code>Object</code> <p>object to remove as a child</p> required Source code in <code>src/drawpyo/diagram/objects.py</code> <pre><code>def remove_object(self, child_object: \"Object\") -&gt; None:\n    \"\"\"Removes a child object from this object, clears the child objects parent, and autoexpands this object if set to.\n\n    Args:\n        child_object (Object): object to remove as a child\n    \"\"\"\n    child_object._parent = None  # Bypass the setter to prevent a loop\n    self.children.remove(child_object)\n    if self.autosize_to_children:\n        self.resize_to_children()\n</code></pre>"},{"location":"api/objects/#src.drawpyo.diagram.objects.Object.remove_out_edge","title":"<code>remove_out_edge(edge)</code>","text":"<p>Remove an edge out of the object. If an edge linked to this object has the source changed or removed this function will be called automatically.</p> <p>Parameters:</p> Name Type Description Default <code>edge</code> <code>Edge</code> <p>An Edge object originating at this object</p> required Source code in <code>src/drawpyo/diagram/objects.py</code> <pre><code>def remove_out_edge(self, edge: Any) -&gt; None:\n    \"\"\"Remove an edge out of the object. If an edge linked to this object has the source changed or removed this function will be called automatically.\n\n    Args:\n        edge (Edge): An Edge object originating at this object\n    \"\"\"\n    self.out_edges.remove(edge)\n</code></pre>"},{"location":"api/objects/#src.drawpyo.diagram.objects.Object.resize_to_children","title":"<code>resize_to_children()</code>","text":"<p>If the object contains children (is a container, parent, etc) then expand the size and position to fit all of the children.</p> <p>By default this function will never shrink the size of the object, only expand it. The contract input can be set for that behavior.</p> <p>Parameters:</p> Name Type Description Default <code>contract</code> <code>bool</code> <p>Contract the parent object to hug the children. Defaults to False.</p> required Source code in <code>src/drawpyo/diagram/objects.py</code> <pre><code>def resize_to_children(self) -&gt; None:\n    \"\"\"If the object contains children (is a container, parent, etc) then expand the size and position to fit all of the children.\n\n    By default this function will never shrink the size of the object, only expand it. The contract input can be set for that behavior.\n\n    Args:\n        contract (bool, optional): Contract the parent object to hug the children. Defaults to False.\n    \"\"\"\n    # Get current extents\n    if len(self.children) == 0:\n        return\n    if self.autocontract:\n        topmost: Union[int, float] = 65536\n        bottommost: Union[int, float] = -65536\n        leftmost: Union[int, float] = 65536\n        rightmost: Union[int, float] = -65536\n    else:\n        topmost: Union[int, float] = self.position[1]\n        bottommost: Union[int, float] = self.position[1] + self.height\n        leftmost: Union[int, float] = self.position[0]\n        rightmost: Union[int, float] = self.position[0] + self.width\n\n    # Check all child objects for extents\n    for child_object in self.children:\n        topmost = min(topmost, child_object.position[1] - self.autosize_margin)\n        bottommost = max(\n            bottommost,\n            child_object.position[1] + child_object.height + self.autosize_margin,\n        )\n        leftmost = min(leftmost, child_object.position[0] - self.autosize_margin)\n        rightmost = max(\n            rightmost,\n            child_object.position[0] + child_object.width + self.autosize_margin,\n        )\n\n    # Set self extents to furthest positions\n    self.move_wo_children((leftmost, topmost))\n    self.width = rightmost - leftmost\n    self.height = bottommost - topmost\n</code></pre>"},{"location":"api/objects/#src.drawpyo.diagram.objects.Object.update_parent","title":"<code>update_parent()</code>","text":"<p>If a parent object is set and the parent is set to autoexpand, then autoexpand it.</p> Source code in <code>src/drawpyo/diagram/objects.py</code> <pre><code>def update_parent(self) -&gt; None:\n    \"\"\"If a parent object is set and the parent is set to autoexpand, then autoexpand it.\"\"\"\n    # This function needs to be callable prior to the parent being set during init,\n    # hence the hasattr() check.\n    if (\n        hasattr(self, \"_parent\")\n        and self.parent is not None\n        and self.parent.autosize_to_children\n    ):\n        # if the parent is autoexpanding, call the autoexpand function\n        self.parent.resize_to_children()\n</code></pre>"},{"location":"api/objects/#group","title":"Group","text":""},{"location":"api/objects/#src.drawpyo.diagram.objects.Group","title":"<code>src.drawpyo.diagram.objects.Group</code>","text":"<p>This class allows objects to be grouped together. It then provides a number of geometry functions and properties to move the entire group around.</p> <p>Currently this object doesn't replicate any of the functionality of groups in the Draw.io app but it may be extended to have that capability in the future.</p> Source code in <code>src/drawpyo/diagram/objects.py</code> <pre><code>class Group:\n    \"\"\"This class allows objects to be grouped together. It then provides a number of geometry functions and properties to move the entire group around.\n\n    Currently this object doesn't replicate any of the functionality of groups in the Draw.io app but it may be extended to have that capability in the future.\n    \"\"\"\n\n    def __init__(self, **kwargs: Any) -&gt; None:\n        self.objects: List[Object] = kwargs.get(\"objects\", [])\n        self.geometry: Geometry = Geometry()\n\n    def add_object(self, object: Union[Object, List[Object]]) -&gt; None:\n        \"\"\"Adds one or more objects to the group and updates the geometry of the group.\n\n        Args:\n            object (Object or list): Object or list of objects to be added to the group\n        \"\"\"\n        if not isinstance(object, list):\n            object = [object]\n        for o in object:\n            if o not in self.objects:\n                self.objects.append(o)\n        self.update_geometry()\n\n    def update_geometry(self) -&gt; None:\n        \"\"\"Update the geometry of the group. This includes the left and top coordinates and the width and height of the entire group.\"\"\"\n        self.geometry.x = self.left\n        self.geometry.y = self.top\n        self.geometry.width = self.width\n        self.geometry.height = self.height\n\n    ###########################################################\n    # Passive properties\n    ###########################################################\n\n    @property\n    def left(self) -&gt; Union[int, float]:\n        \"\"\"The leftmost X-coordinate of the objects in the group\n\n        Returns:\n            int: Left edge of the group\n        \"\"\"\n        return min([obj.geometry.x for obj in self.objects])\n\n    @property\n    def right(self) -&gt; Union[int, float]:\n        \"\"\"The rightmost X-coordinate of the objects in the group\n\n        Returns:\n            int: Right edge of the group\n        \"\"\"\n        return max([obj.geometry.x + obj.geometry.width for obj in self.objects])\n\n    @property\n    def top(self) -&gt; Union[int, float]:\n        \"\"\"The topmost Y-coordinate of the objects in the group\n\n        Returns:\n            int: Top edge of the group\n        \"\"\"\n        return min([obj.geometry.y for obj in self.objects])\n\n    @property\n    def bottom(self) -&gt; Union[int, float]:\n        \"\"\"The bottommost Y-coordinate of the objects in the group\n\n        Returns:\n            int: The bottom edge of the group\n        \"\"\"\n        return max([obj.geometry.y + obj.geometry.height for obj in self.objects])\n\n    @property\n    def width(self) -&gt; Union[int, float]:\n        \"\"\"The width of all the objects in the group\n\n        Returns:\n            int: Width of the group\n        \"\"\"\n        return self.right - self.left\n\n    @property\n    def height(self) -&gt; Union[int, float]:\n        \"\"\"The height of all the objects in the group\n\n        Returns:\n            int: Height of the group\n        \"\"\"\n        return self.bottom - self.top\n\n    @property\n    def size(self) -&gt; Tuple[Union[int, float], Union[int, float]]:\n        \"\"\"The size of the group. Returns a tuple of ints, with the width and height.\n\n        Returns:\n            tuple: A tuple of ints (width, height)\n        \"\"\"\n        return (self.width, self.height)\n\n    ###########################################################\n    # Position properties\n    ###########################################################\n\n    def _move_by_delta(\n        self, delta_x: Union[int, float], delta_y: Union[int, float]\n    ) -&gt; None:\n        \"\"\"Apply position delta to all objects in the group.\n\n        Args:\n            delta_x: Horizontal offset to apply\n            delta_y: Vertical offset to apply\n        \"\"\"\n        for obj in self.objects:\n            obj.position = (obj.geometry.x + delta_x, obj.geometry.y + delta_y)\n        self.update_geometry()\n\n    @property\n    def center_position(self) -&gt; Tuple[Union[int, float], Union[int, float]]:\n        \"\"\"The center position of the group. Returns a tuple of ints, with the X and Y coordinate. When this property is set, the coordinates of every object in the group are updated.\n\n        Returns:\n            tuple: A tuple of ints (X, Y)\n        \"\"\"\n        return (self.left + self.width / 2, self.top + self.height / 2)\n\n    @center_position.setter\n    def center_position(\n        self, new_center: Tuple[Union[int, float], Union[int, float]]\n    ) -&gt; None:\n        delta_x = new_center[0] - self.center_position[0]\n        delta_y = new_center[1] - self.center_position[1]\n        self._move_by_delta(delta_x, delta_y)\n\n    @property\n    def position(self) -&gt; Tuple[Union[int, float], Union[int, float]]:\n        \"\"\"The top left position of the group. Returns a tuple of ints, with the X and Y coordinate. When this property is set, the coordinates of every object in the group are updated.\n\n        Returns:\n            tuple: A tuple of ints (X, Y)\n        \"\"\"\n        return (self.left, self.top)\n\n    @position.setter\n    def position(\n        self, new_position: Tuple[Union[int, float], Union[int, float]]\n    ) -&gt; None:\n        delta_x = new_position[0] - self.position[0]\n        delta_y = new_position[1] - self.position[1]\n        self._move_by_delta(delta_x, delta_y)\n</code></pre>"},{"location":"api/objects/#src.drawpyo.diagram.objects.Group.bottom","title":"<code>bottom</code>  <code>property</code>","text":"<p>The bottommost Y-coordinate of the objects in the group</p> <p>Returns:</p> Name Type Description <code>int</code> <code>Union[int, float]</code> <p>The bottom edge of the group</p>"},{"location":"api/objects/#src.drawpyo.diagram.objects.Group.center_position","title":"<code>center_position</code>  <code>property</code> <code>writable</code>","text":"<p>The center position of the group. Returns a tuple of ints, with the X and Y coordinate. When this property is set, the coordinates of every object in the group are updated.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[Union[int, float], Union[int, float]]</code> <p>A tuple of ints (X, Y)</p>"},{"location":"api/objects/#src.drawpyo.diagram.objects.Group.height","title":"<code>height</code>  <code>property</code>","text":"<p>The height of all the objects in the group</p> <p>Returns:</p> Name Type Description <code>int</code> <code>Union[int, float]</code> <p>Height of the group</p>"},{"location":"api/objects/#src.drawpyo.diagram.objects.Group.left","title":"<code>left</code>  <code>property</code>","text":"<p>The leftmost X-coordinate of the objects in the group</p> <p>Returns:</p> Name Type Description <code>int</code> <code>Union[int, float]</code> <p>Left edge of the group</p>"},{"location":"api/objects/#src.drawpyo.diagram.objects.Group.position","title":"<code>position</code>  <code>property</code> <code>writable</code>","text":"<p>The top left position of the group. Returns a tuple of ints, with the X and Y coordinate. When this property is set, the coordinates of every object in the group are updated.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[Union[int, float], Union[int, float]]</code> <p>A tuple of ints (X, Y)</p>"},{"location":"api/objects/#src.drawpyo.diagram.objects.Group.right","title":"<code>right</code>  <code>property</code>","text":"<p>The rightmost X-coordinate of the objects in the group</p> <p>Returns:</p> Name Type Description <code>int</code> <code>Union[int, float]</code> <p>Right edge of the group</p>"},{"location":"api/objects/#src.drawpyo.diagram.objects.Group.size","title":"<code>size</code>  <code>property</code>","text":"<p>The size of the group. Returns a tuple of ints, with the width and height.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[Union[int, float], Union[int, float]]</code> <p>A tuple of ints (width, height)</p>"},{"location":"api/objects/#src.drawpyo.diagram.objects.Group.top","title":"<code>top</code>  <code>property</code>","text":"<p>The topmost Y-coordinate of the objects in the group</p> <p>Returns:</p> Name Type Description <code>int</code> <code>Union[int, float]</code> <p>Top edge of the group</p>"},{"location":"api/objects/#src.drawpyo.diagram.objects.Group.width","title":"<code>width</code>  <code>property</code>","text":"<p>The width of all the objects in the group</p> <p>Returns:</p> Name Type Description <code>int</code> <code>Union[int, float]</code> <p>Width of the group</p>"},{"location":"api/objects/#src.drawpyo.diagram.objects.Group.add_object","title":"<code>add_object(object)</code>","text":"<p>Adds one or more objects to the group and updates the geometry of the group.</p> <p>Parameters:</p> Name Type Description Default <code>object</code> <code>Object or list</code> <p>Object or list of objects to be added to the group</p> required Source code in <code>src/drawpyo/diagram/objects.py</code> <pre><code>def add_object(self, object: Union[Object, List[Object]]) -&gt; None:\n    \"\"\"Adds one or more objects to the group and updates the geometry of the group.\n\n    Args:\n        object (Object or list): Object or list of objects to be added to the group\n    \"\"\"\n    if not isinstance(object, list):\n        object = [object]\n    for o in object:\n        if o not in self.objects:\n            self.objects.append(o)\n    self.update_geometry()\n</code></pre>"},{"location":"api/objects/#src.drawpyo.diagram.objects.Group.update_geometry","title":"<code>update_geometry()</code>","text":"<p>Update the geometry of the group. This includes the left and top coordinates and the width and height of the entire group.</p> Source code in <code>src/drawpyo/diagram/objects.py</code> <pre><code>def update_geometry(self) -&gt; None:\n    \"\"\"Update the geometry of the group. This includes the left and top coordinates and the width and height of the entire group.\"\"\"\n    self.geometry.x = self.left\n    self.geometry.y = self.top\n    self.geometry.width = self.width\n    self.geometry.height = self.height\n</code></pre>"},{"location":"api/page/","title":"Page","text":""},{"location":"api/page/#src.drawpyo.page.Page","title":"<code>src.drawpyo.page.Page</code>","text":"<p>This class defines a page in a Draw.io document. It contains a list of objects and a reference to the File it's in as well as formatting attributes.</p> Source code in <code>src/drawpyo/page.py</code> <pre><code>class Page:\n    \"\"\"\n    This class defines a page in a Draw.io document. It contains a list of objects and a reference to the File it's in as well as formatting attributes.\n    \"\"\"\n\n    def __init__(self, file: Optional[Any] = None, **kwargs: Any) -&gt; None:\n        super().__init__()\n        self.id: int = id(self)\n\n        self.file: Optional[Any] = file\n        self.objects: List[Any] = kwargs.get(\"objects\", [])\n\n        # There are two empty top level objects in every Draw.io diagram\n        self.objects.append(XMLBase(id=0, xml_class=\"mxCell\"))\n        self.objects.append(XMLBase(id=1, xml_class=\"mxCell\", xml_parent=0))\n\n        # Properties\n\n        if self.file is not None:\n            page_num = len(self.file.pages)\n        else:\n            page_num = 1\n        self.name: str = kwargs.get(\"name\", f\"Page-{page_num}\")\n        self.page_num: int = kwargs.get(\"page_num\", page_num)\n\n        self.dx: Union[int, float] = kwargs.get(\"dx\", 2037)\n        self.dy: Union[int, float] = kwargs.get(\"dy\", 830)\n        self.grid: int = kwargs.get(\"grid\", 1)\n        self.grid_size: int = kwargs.get(\"grid_size\", 10)\n        self.guides: int = kwargs.get(\"guides\", 1)\n        self.tooltips: int = kwargs.get(\"tooltips\", 1)\n        self.connect: int = kwargs.get(\"connect\", 1)\n        self.arrows: int = kwargs.get(\"arrows\", 1)\n        self.fold: int = kwargs.get(\"fold\", 1)\n        self.scale: Union[int, float] = kwargs.get(\"scale\", 1)\n        self.width: Union[int, float] = kwargs.get(\"width\", 850)\n        self.height: Union[int, float] = kwargs.get(\"height\", 1100)\n        self.math: int = kwargs.get(\"math\", 0)\n        self.shadow: int = kwargs.get(\"shadow\", 0)\n\n        # In the Draw.io file format, each page is actually three nested XML\n        # tags. These are defined as XMLBase subclasses below\n        self.diagram: Diagram = Diagram(name=self.name)\n        self.mxGraph: mxGraph = mxGraph(page=self)\n        self.root: Root = Root()\n\n        logger.info(f\"\ud83d\udcc4 Page created: '{self.__repr__()}'\")\n\n    def __repr__(self) -&gt; str:\n        return f\"drawpyo Page - {self.name}\"\n\n    def remove(self) -&gt; None:\n        \"\"\"This function removes the Page from its linked File object then deletes itself.\"\"\"\n        if self.file is not None:\n            self.file.remove_page(self)\n        del self\n\n    def add_object(self, obj: Any) -&gt; None:\n        if obj not in self.objects:\n            self.objects.append(obj)\n\n    def remove_object(self, obj: Any) -&gt; None:\n        self.objects.remove(obj)\n\n    @property\n    def file(self) -&gt; Optional[Any]:\n        return self._file\n\n    @file.setter\n    def file(self, f: Optional[Any]) -&gt; None:\n        if f is not None:\n            f.add_page(self)\n        self._file = f\n\n    @file.deleter\n    def file(self) -&gt; None:\n        self._file.remove_page(self)\n        self._file = None\n\n    ###########################################################\n    # XML Generation\n    ###########################################################\n    @property\n    def xml(self) -&gt; str:\n        xml_string = self.xml_open_tag\n        for obj in self.objects:\n            xml_string = xml_string + \"\\n        \" + obj.xml\n        xml_string = xml_string + \"\\n\" + self.xml_close_tag\n        return xml_string\n\n    @property\n    def xml_open_tag(self) -&gt; str:\n        tag = (\n            self.diagram.xml_open_tag\n            + \"\\n    \"\n            + self.mxGraph.xml_open_tag\n            + \"\\n      \"\n            + self.root.xml_open_tag\n        )\n        return tag\n\n    @property\n    def xml_close_tag(self) -&gt; str:\n        tag = (\n            \"      \"\n            + self.root.xml_close_tag\n            + \"\\n    \"\n            + self.mxGraph.xml_close_tag\n            + \"\\n  \"\n            + self.diagram.xml_close_tag\n        )\n        return tag\n</code></pre>"},{"location":"api/page/#src.drawpyo.page.Page.remove","title":"<code>remove()</code>","text":"<p>This function removes the Page from its linked File object then deletes itself.</p> Source code in <code>src/drawpyo/page.py</code> <pre><code>def remove(self) -&gt; None:\n    \"\"\"This function removes the Page from its linked File object then deletes itself.\"\"\"\n    if self.file is not None:\n        self.file.remove_page(self)\n    del self\n</code></pre>"},{"location":"api/standard_colors/","title":"Standard Colors","text":""},{"location":"api/standard_colors/#src.drawpyo.utils.standard_colors.StandardColor","title":"<code>src.drawpyo.utils.standard_colors.StandardColor</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> Source code in <code>src/drawpyo/utils/standard_colors.py</code> <pre><code>class StandardColor(str, Enum):\n    NONE = \"none\"\n    BLACK = \"#000000\"\n    WHITE = \"#FFFFFF\"\n    GRAY1 = \"#E6E6E6\"\n    GRAY2 = \"#CCCCCC\"\n    GRAY3 = \"#B3B3B3\"\n    GRAY4 = \"#999999\"\n    GRAY5 = \"#808080\"\n    GRAY6 = \"#666666\"\n    GRAY7 = \"#4D4D4D\"\n    GRAY8 = \"#333333\"\n    GRAY9 = \"#1A1A1A\"\n    RED1 = \"#FFCCCC\"\n    RED2 = \"#FF9999\"\n    RED3 = \"#FF6666\"\n    RED4 = \"#FF3333\"\n    RED5 = \"#FF0000\"\n    RED6 = \"#CC0000\"\n    RED7 = \"#990000\"\n    RED8 = \"#660000\"\n    RED9 = \"#330000\"\n    ORANGE1 = \"#FFE6CC\"\n    ORANGE2 = \"#FFCC99\"\n    ORANGE3 = \"#FFB366\"\n    ORANGE4 = \"#FF9933\"\n    ORANGE5 = \"#FF8000\"\n    ORANGE6 = \"#CC6600\"\n    ORANGE7 = \"#994C00\"\n    ORANGE8 = \"#663300\"\n    ORANGE9 = \"#331A00\"\n    YELLOW1 = \"#FFFFCC\"\n    YELLOW2 = \"#FFFF99\"\n    YELLOW3 = \"#FFFF66\"\n    YELLOW4 = \"#FFFF33\"\n    YELLOW5 = \"#FFFF00\"\n    YELLOW6 = \"#CCCC00\"\n    YELLOW7 = \"#999900\"\n    YELLOW8 = \"#666600\"\n    YELLOW9 = \"#333300\"\n    LIME1 = \"#E6FFCC\"\n    LIME2 = \"#CCFF99\"\n    LIME3 = \"#B3FF66\"\n    LIME4 = \"#99FF33\"\n    LIME5 = \"#80FF00\"\n    LIME6 = \"#66CC00\"\n    LIME7 = \"#4D9900\"\n    LIME8 = \"#336600\"\n    LIME9 = \"#1A3300\"\n    GREEN1 = \"#CCFFCC\"\n    GREEN2 = \"#99FF99\"\n    GREEN3 = \"#66FF66\"\n    GREEN4 = \"#33FF33\"\n    GREEN5 = \"#00FF00\"\n    GREEN6 = \"#00CC00\"\n    GREEN7 = \"#009900\"\n    GREEN8 = \"#006600\"\n    GREEN9 = \"#003300\"\n    EMERALD1 = \"#CCFFE6\"\n    EMERALD2 = \"#99FFCC\"\n    EMERALD3 = \"#66FFB3\"\n    EMERALD4 = \"#33FF99\"\n    EMERALD5 = \"#00FF80\"\n    EMERALD6 = \"#00CC66\"\n    EMERALD7 = \"#00994D\"\n    EMERALD8 = \"#006633\"\n    EMERALD9 = \"#00331A\"\n    CYAN1 = \"#CCFFFF\"\n    CYAN2 = \"#99FFFF\"\n    CYAN3 = \"#66FFFF\"\n    CYAN4 = \"#33FFFF\"\n    CYAN5 = \"#00FFFF\"\n    CYAN6 = \"#00CCCC\"\n    CYAN7 = \"#009999\"\n    CYAN8 = \"#006666\"\n    CYAN9 = \"#003333\"\n    BLUE1 = \"#CCE5FF\"\n    BLUE2 = \"#99CCFF\"\n    BLUE3 = \"#66B2FF\"\n    BLUE4 = \"#3399FF\"\n    BLUE5 = \"#007FFF\"\n    BLUE6 = \"#0066CC\"\n    BLUE7 = \"#004C99\"\n    BLUE8 = \"#003366\"\n    BLUE9 = \"#001933\"\n    INDIGO1 = \"#CCCCFF\"\n    INDIGO2 = \"#9999FF\"\n    INDIGO3 = \"#6666FF\"\n    INDIGO4 = \"#3333FF\"\n    INDIGO5 = \"#0000FF\"\n    INDIGO6 = \"#0000CC\"\n    INDIGO7 = \"#000099\"\n    INDIGO8 = \"#000066\"\n    INDIGO9 = \"#000033\"\n    PURPLE1 = \"#E5CCFF\"\n    PURPLE2 = \"#CC99FF\"\n    PURPLE3 = \"#B266FF\"\n    PURPLE4 = \"#9933FF\"\n    PURPLE5 = \"#7F00FF\"\n    PURPLE6 = \"#6600CC\"\n    PURPLE7 = \"#6600CC\"\n    PURPLE8 = \"#330066\"\n    PURPLE9 = \"#190033\"\n    MAGENTA1 = \"#FFCCFF\"\n    MAGENTA2 = \"#FF99CC\"\n    MAGENTA3 = \"#FF66CC\"\n    MAGENTA4 = \"#FF33FF\"\n    MAGENTA5 = \"#FF00FF\"\n    MAGENTA6 = \"#CC00CC\"\n    MAGENTA7 = \"#990099\"\n    MAGENTA8 = \"#660066\"\n    MAGENTA9 = \"#330033\"\n    CRIMSON1 = \"#FFCCE6\"\n    CRIMSON2 = \"#FF99CC\"\n    CRIMSON3 = \"#FF66B3\"\n    CRIMSON4 = \"#FF3399\"\n    CRIMSON5 = \"#FF0080\"\n    CRIMSON6 = \"#CC0066\"\n    CRIMSON7 = \"#99004D\"\n    CRIMSON8 = \"#660033\"\n    CRIMSON9 = \"#33001A\"\n</code></pre>"},{"location":"api/text_format/","title":"Text Format","text":""},{"location":"api/text_format/#textformat","title":"TextFormat","text":""},{"location":"api/text_format/#src.drawpyo.diagram.text_format.TextFormat","title":"<code>src.drawpyo.diagram.text_format.TextFormat</code>","text":"<p>               Bases: <code>DiagramBase</code></p> <p>The TextFormat class handles all of the formatting specifically around a text box or label.</p> Source code in <code>src/drawpyo/diagram/text_format.py</code> <pre><code>class TextFormat(DiagramBase):\n    \"\"\"The TextFormat class handles all of the formatting specifically around a text box or label.\"\"\"\n\n    def __init__(self, **kwargs: Any) -&gt; None:\n        \"\"\"TextFormat objects can be initialized with no properties or any of what's listed below:\n\n        Keyword Args:\n            fontColor (int, optional): The color of the text in the object (#ffffff)\n            fontFamily (str, optional): The typeface of the text in the object (see Draw.io for available fonts)\n            fontSize (int, optional): The size of the text in the object in points\n            align (str, optional): The horizontal alignment of the text in the object ('left', 'center', or 'right')\n            verticalAlign (str, optional): The vertical alignment of the text in the object ('top', 'middle', 'bottom')\n            textOpacity (int, optional): The opacity of the text in the object\n            direction (str, optional): The direction to print the text ('vertical', 'horizontal')\n            bold (bool, optional): Whether the text in the object should be bold\n            italic (bool, optional): Whether the text in the object should be italic\n            underline (bool, optional): Whether the text in the object should be underlined\n            labelPosition (str, optional): The position of the object label ('left', 'center', or 'right')\n            labelBackgroundColor (str, optional): The background color of the object label (#ffffff)\n            labelBorderColor (str, optional): The border color of the object label (#ffffff)\n            formattedText (bool, optional): Whether to render the text as HTML formatted or not\n\n        \"\"\"\n        super().__init__(**kwargs)\n        self.fontFamily: Optional[str] = kwargs.get(\"fontFamily\", None)\n        self.fontSize: Optional[int] = kwargs.get(\"fontSize\", None)\n        self.fontColor: Optional[str] = kwargs.get(\"fontColor\", None)\n        self.labelBorderColor: Optional[str] = kwargs.get(\"labelBorderColor\", None)\n        self.labelBackgroundColor: Optional[str] = kwargs.get(\n            \"labelBackgroundColor\", None\n        )\n        self.labelPosition: Optional[str] = kwargs.get(\"labelPosition\", None)\n        self.textShadow: Optional[Union[int, str]] = kwargs.get(\"textShadow\", None)\n        self.textOpacity: Optional[int] = kwargs.get(\"textOpacity\", None)\n        self.spacingTop: Optional[int] = kwargs.get(\"spacingTop\", None)\n        self.spacingLeft: Optional[int] = kwargs.get(\"spacingLeft\", None)\n        self.spacingBottom: Optional[int] = kwargs.get(\"spacingBottom\", None)\n        self.spacingRight: Optional[int] = kwargs.get(\"spacingRight\", None)\n        self.spacing: Optional[int] = kwargs.get(\"spacing\", None)\n        self.align: Optional[str] = kwargs.get(\"align\", None)\n        self.verticalAlign: Optional[str] = kwargs.get(\"verticalAlign\", None)\n        # These need to be enumerated\n        self._direction: Optional[str] = kwargs.get(\"direction\", None)\n        # This is actually horizontal. 0 means vertical text, 1 or not present\n        # means horizontal\n        self.html: Optional[bool] = kwargs.get(\n            \"formattedText\", None\n        )  # prints in the style string as html\n        self.bold: bool = kwargs.get(\"bold\", False)\n        self.italic: bool = kwargs.get(\"italic\", False)\n        self.underline: bool = kwargs.get(\"underline\", False)\n\n        self._style_attributes: list[str] = [\n            \"html\",\n            \"fontFamily\",\n            \"fontStyle\",\n            \"fontSize\",\n            \"fontColor\",\n            \"labelBorderColor\",\n            \"labelBackgroundColor\",\n            \"labelPosition\",\n            \"textShadow\",\n            \"textOpacity\",\n            \"spacingTop\",\n            \"spacingLeft\",\n            \"spacingBottom\",\n            \"spacingRight\",\n            \"spacing\",\n            \"align\",\n            \"verticalAlign\",\n            \"horizontal\",\n        ]\n\n    def __repr__(self) -&gt; str:\n        \"\"\"\n        A concise, informative representation for TextFormat.\n        \"\"\"\n        cls = self.__class__.__name__\n        parts = []\n\n        # Font properties\n        if self.fontFamily:\n            parts.append(f\"fontFamily={self.fontFamily!r}\")\n        if self.fontSize:\n            parts.append(f\"fontSize={self.fontSize}\")\n        if self.fontColor:\n            parts.append(f\"fontColor={self.fontColor!r}\")\n\n        # Style flags\n        flags = []\n        if self.bold:\n            flags.append(\"bold\")\n        if self.italic:\n            flags.append(\"italic\")\n        if self.underline:\n            flags.append(\"underline\")\n        if flags:\n            parts.append(\"fontStyle=\" + \"|\".join(flags))\n\n        # Alignment\n        if self.align:\n            parts.append(f\"align={self.align!r}\")\n        if self.verticalAlign:\n            parts.append(f\"verticalAlign={self.verticalAlign!r}\")\n        if self._direction:\n            parts.append(f\"direction={self._direction!r}\")\n        if self.html:\n            parts.append(\"formattedText=True\")\n\n        # Label styling\n        if self.labelPosition:\n            parts.append(f\"labelPosition={self.labelPosition!r}\")\n\n        return f\"{cls}(\" + \", \".join(parts) + \")\"\n\n    @property\n    def formattedText(self) -&gt; Optional[bool]:\n        \"\"\"formattedText wraps the Draw.io style attribute 'html'. This controls whether the text is rendered with HTML attributes or as plain text.\"\"\"\n        return self.html\n\n    @formattedText.setter\n    def formattedText(self, value: Optional[bool]) -&gt; None:\n        self.html = value\n\n    @formattedText.deleter\n    def formattedText(self) -&gt; None:\n        self.html = None\n\n    # The direction of the text is encoded as 'horizontal' in Draw.io. This is\n    # unintuitive so I provided a direction alternate syntax.\n    @property\n    def horizontal(self) -&gt; Optional[int]:\n        return directions[self._direction]\n\n    @horizontal.setter\n    def horizontal(self, value: Optional[int]) -&gt; None:\n        if value in directions_inv.keys():\n            self._direction = directions_inv[value]\n        else:\n            raise ValueError(\"{0} is not an allowed value of horizontal\".format(value))\n\n    @property\n    def directions(self) -&gt; Dict[Optional[str], Optional[int]]:\n        \"\"\"The direction controls the direction of the text and can be either horizontal or vertical.\"\"\"\n        return directions\n\n    @property\n    def direction(self) -&gt; Optional[str]:\n        return self._direction\n\n    @direction.setter\n    def direction(self, value: Optional[str]) -&gt; None:\n        if value in directions.keys():\n            self._direction = value\n        else:\n            raise ValueError(\"{0} is not an allowed value of direction\".format(value))\n\n    @property\n    def font_style(self) -&gt; int:\n        \"\"\"The font_style is a numeric format that corresponds to a combination of three other attributes: bold, italic, and underline. Any combination of them can be true.\"\"\"\n        bld = self.bold\n        ita = self.italic\n        unl = self.underline\n\n        # 0 = normal\n        # 1 = bold\n        # 2 = italic\n        # 3 = bold and italic\n        # 4 = underline\n        # 5 = bold and underlined\n        # 6 = italic and underlined\n        # 7 = bold, italic, and underlined\n\n        if not bld and not ita and not unl:\n            return 0\n        elif bld and not ita and not unl:\n            return 1\n        elif not bld and ita and not unl:\n            return 2\n        elif bld and ita and not unl:\n            return 3\n        elif not bld and not ita and unl:\n            return 4\n        elif bld and not ita and unl:\n            return 5\n        elif not bld and ita and unl:\n            return 6\n        elif bld and ita and unl:\n            return 7\n        return 0  # fallback (shouldn't be reached)\n\n    @property\n    def fontStyle(self) -&gt; Optional[int]:\n        if self.font_style != 0:\n            return self.font_style\n        return None\n</code></pre>"},{"location":"api/text_format/#src.drawpyo.diagram.text_format.TextFormat.directions","title":"<code>directions</code>  <code>property</code>","text":"<p>The direction controls the direction of the text and can be either horizontal or vertical.</p>"},{"location":"api/text_format/#src.drawpyo.diagram.text_format.TextFormat.font_style","title":"<code>font_style</code>  <code>property</code>","text":"<p>The font_style is a numeric format that corresponds to a combination of three other attributes: bold, italic, and underline. Any combination of them can be true.</p>"},{"location":"api/text_format/#src.drawpyo.diagram.text_format.TextFormat.formattedText","title":"<code>formattedText</code>  <code>deletable</code> <code>property</code> <code>writable</code>","text":"<p>formattedText wraps the Draw.io style attribute 'html'. This controls whether the text is rendered with HTML attributes or as plain text.</p>"},{"location":"api/text_format/#src.drawpyo.diagram.text_format.TextFormat.__init__","title":"<code>__init__(**kwargs)</code>","text":"<p>TextFormat objects can be initialized with no properties or any of what's listed below:</p> <p>Other Parameters:</p> Name Type Description <code>fontColor</code> <code>int</code> <p>The color of the text in the object (#ffffff)</p> <code>fontFamily</code> <code>str</code> <p>The typeface of the text in the object (see Draw.io for available fonts)</p> <code>fontSize</code> <code>int</code> <p>The size of the text in the object in points</p> <code>align</code> <code>str</code> <p>The horizontal alignment of the text in the object ('left', 'center', or 'right')</p> <code>verticalAlign</code> <code>str</code> <p>The vertical alignment of the text in the object ('top', 'middle', 'bottom')</p> <code>textOpacity</code> <code>int</code> <p>The opacity of the text in the object</p> <code>direction</code> <code>str</code> <p>The direction to print the text ('vertical', 'horizontal')</p> <code>bold</code> <code>bool</code> <p>Whether the text in the object should be bold</p> <code>italic</code> <code>bool</code> <p>Whether the text in the object should be italic</p> <code>underline</code> <code>bool</code> <p>Whether the text in the object should be underlined</p> <code>labelPosition</code> <code>str</code> <p>The position of the object label ('left', 'center', or 'right')</p> <code>labelBackgroundColor</code> <code>str</code> <p>The background color of the object label (#ffffff)</p> <code>labelBorderColor</code> <code>str</code> <p>The border color of the object label (#ffffff)</p> <code>formattedText</code> <code>bool</code> <p>Whether to render the text as HTML formatted or not</p> Source code in <code>src/drawpyo/diagram/text_format.py</code> <pre><code>def __init__(self, **kwargs: Any) -&gt; None:\n    \"\"\"TextFormat objects can be initialized with no properties or any of what's listed below:\n\n    Keyword Args:\n        fontColor (int, optional): The color of the text in the object (#ffffff)\n        fontFamily (str, optional): The typeface of the text in the object (see Draw.io for available fonts)\n        fontSize (int, optional): The size of the text in the object in points\n        align (str, optional): The horizontal alignment of the text in the object ('left', 'center', or 'right')\n        verticalAlign (str, optional): The vertical alignment of the text in the object ('top', 'middle', 'bottom')\n        textOpacity (int, optional): The opacity of the text in the object\n        direction (str, optional): The direction to print the text ('vertical', 'horizontal')\n        bold (bool, optional): Whether the text in the object should be bold\n        italic (bool, optional): Whether the text in the object should be italic\n        underline (bool, optional): Whether the text in the object should be underlined\n        labelPosition (str, optional): The position of the object label ('left', 'center', or 'right')\n        labelBackgroundColor (str, optional): The background color of the object label (#ffffff)\n        labelBorderColor (str, optional): The border color of the object label (#ffffff)\n        formattedText (bool, optional): Whether to render the text as HTML formatted or not\n\n    \"\"\"\n    super().__init__(**kwargs)\n    self.fontFamily: Optional[str] = kwargs.get(\"fontFamily\", None)\n    self.fontSize: Optional[int] = kwargs.get(\"fontSize\", None)\n    self.fontColor: Optional[str] = kwargs.get(\"fontColor\", None)\n    self.labelBorderColor: Optional[str] = kwargs.get(\"labelBorderColor\", None)\n    self.labelBackgroundColor: Optional[str] = kwargs.get(\n        \"labelBackgroundColor\", None\n    )\n    self.labelPosition: Optional[str] = kwargs.get(\"labelPosition\", None)\n    self.textShadow: Optional[Union[int, str]] = kwargs.get(\"textShadow\", None)\n    self.textOpacity: Optional[int] = kwargs.get(\"textOpacity\", None)\n    self.spacingTop: Optional[int] = kwargs.get(\"spacingTop\", None)\n    self.spacingLeft: Optional[int] = kwargs.get(\"spacingLeft\", None)\n    self.spacingBottom: Optional[int] = kwargs.get(\"spacingBottom\", None)\n    self.spacingRight: Optional[int] = kwargs.get(\"spacingRight\", None)\n    self.spacing: Optional[int] = kwargs.get(\"spacing\", None)\n    self.align: Optional[str] = kwargs.get(\"align\", None)\n    self.verticalAlign: Optional[str] = kwargs.get(\"verticalAlign\", None)\n    # These need to be enumerated\n    self._direction: Optional[str] = kwargs.get(\"direction\", None)\n    # This is actually horizontal. 0 means vertical text, 1 or not present\n    # means horizontal\n    self.html: Optional[bool] = kwargs.get(\n        \"formattedText\", None\n    )  # prints in the style string as html\n    self.bold: bool = kwargs.get(\"bold\", False)\n    self.italic: bool = kwargs.get(\"italic\", False)\n    self.underline: bool = kwargs.get(\"underline\", False)\n\n    self._style_attributes: list[str] = [\n        \"html\",\n        \"fontFamily\",\n        \"fontStyle\",\n        \"fontSize\",\n        \"fontColor\",\n        \"labelBorderColor\",\n        \"labelBackgroundColor\",\n        \"labelPosition\",\n        \"textShadow\",\n        \"textOpacity\",\n        \"spacingTop\",\n        \"spacingLeft\",\n        \"spacingBottom\",\n        \"spacingRight\",\n        \"spacing\",\n        \"align\",\n        \"verticalAlign\",\n        \"horizontal\",\n    ]\n</code></pre>"},{"location":"api/text_format/#src.drawpyo.diagram.text_format.TextFormat.__repr__","title":"<code>__repr__()</code>","text":"<p>A concise, informative representation for TextFormat.</p> Source code in <code>src/drawpyo/diagram/text_format.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"\n    A concise, informative representation for TextFormat.\n    \"\"\"\n    cls = self.__class__.__name__\n    parts = []\n\n    # Font properties\n    if self.fontFamily:\n        parts.append(f\"fontFamily={self.fontFamily!r}\")\n    if self.fontSize:\n        parts.append(f\"fontSize={self.fontSize}\")\n    if self.fontColor:\n        parts.append(f\"fontColor={self.fontColor!r}\")\n\n    # Style flags\n    flags = []\n    if self.bold:\n        flags.append(\"bold\")\n    if self.italic:\n        flags.append(\"italic\")\n    if self.underline:\n        flags.append(\"underline\")\n    if flags:\n        parts.append(\"fontStyle=\" + \"|\".join(flags))\n\n    # Alignment\n    if self.align:\n        parts.append(f\"align={self.align!r}\")\n    if self.verticalAlign:\n        parts.append(f\"verticalAlign={self.verticalAlign!r}\")\n    if self._direction:\n        parts.append(f\"direction={self._direction!r}\")\n    if self.html:\n        parts.append(\"formattedText=True\")\n\n    # Label styling\n    if self.labelPosition:\n        parts.append(f\"labelPosition={self.labelPosition!r}\")\n\n    return f\"{cls}(\" + \", \".join(parts) + \")\"\n</code></pre>"},{"location":"api/bar_chart/barchart/","title":"Bar Chart","text":""},{"location":"api/bar_chart/barchart/#src.drawpyo.diagram_types.bar_chart.BarChart","title":"<code>src.drawpyo.diagram_types.bar_chart.BarChart</code>","text":"<p>A configurable bar chart built entirely from Object and Group.</p> <p>This chart is mutable - you can update data, styling, and position after creation.</p> Source code in <code>src/drawpyo/diagram_types/bar_chart.py</code> <pre><code>class BarChart:\n    \"\"\"A configurable bar chart built entirely from Object and Group.\n\n    This chart is mutable - you can update data, styling, and position after creation.\n    \"\"\"\n\n    # Layout constants\n    DEFAULT_BAR_WIDTH = 40\n    DEFAULT_BAR_SPACING = 20\n    DEFAULT_MAX_BAR_HEIGHT = 200\n\n    # Spacing constants\n    TITLE_BOTTOM_MARGIN = 10\n    LABEL_TOP_MARGIN = 5\n    BACKGROUND_PADDING = 20\n\n    # Axis constants\n    AXIS_OFFSET = 10\n    TICK_COUNT = 5\n    TICK_LENGTH = 4\n    TICK_LABEL_MARGIN = 4\n    TICK_COLOR = \"#000000\"\n\n    def __init__(self, data: dict[str, float], **kwargs):\n        \"\"\"\n        Args:\n            data (dict[str, float]): Mapping of labels to numeric values.\n\n        Keyword Args:\n            position (tuple[int, int]): Chart top-left position. Default: (0, 0)\n            bar_width (int): Width of each bar. Default: 40\n            bar_spacing (int): Space between bars. Default: 20\n            max_bar_height (int): Height of the largest bar. Default: 200\n            bar_colors (list[Union[str, StandardColor, ColorScheme]]): List of colors. Default: [\"#66ccff\"]\n            base_label_formatter (Callable[[str, float], str]): Custom label formatter for base (below) labels. Default: lambda l,v: l\n            inside_label_formatter (Callable[[str, float], str]): Custom label formatter for inside-bar labels. Default: lambda l,v: str(v)\n            title (str): Optional chart title. Default: None\n            title_text_format (TextFormat): TextFormat for the title. Default: TextFormat()\n            base_text_format (TextFormat): TextFormat for base labels. Default: TextFormat()\n            inside_text_format (TextFormat): TextFormat for inside labels. Default: TextFormat()\n            background_color (str | StandardColor): Optional chart background fill. Default: None\n            show_axis (bool): Whether to show the axis and ticks. Default: False\n            axis_tick_count (int): Number of tick intervals on the axis. Default: 5\n            axis_text_format (TextFormat): TextFormat for axis tick labels. Default: TextFormat()\n            glass (bool): Whether bars have a glass effect. Default: False\n            rounded (bool): Whether bars have rounded corners. Default: False\n        \"\"\"\n        # Validate data\n        if not isinstance(data, dict):\n            raise TypeError(\"Data must be a dict.\")\n        if not data:\n            raise ValueError(\"Data cannot be empty.\")\n\n        invalid_keys = [key for key in data if not isinstance(key, str)]\n        if invalid_keys:\n            raise TypeError(f\"All keys must be strings. Invalid: {invalid_keys}\")\n\n        invalid_values = [\n            key for key, value in data.items() if not isinstance(value, (int, float))\n        ]\n        if invalid_values:\n            raise TypeError(f\"Values must be numeric. Invalid: {invalid_values}\")\n\n        self._data: dict[str, Union[int, float]] = data.copy()\n\n        # Position and dimensions\n        self._position: Optional[tuple[int, int]] = kwargs.get(\"position\", (0, 0))\n        self._bar_width: Optional[int] = kwargs.get(\"bar_width\", self.DEFAULT_BAR_WIDTH)\n        self._bar_spacing: Optional[int] = kwargs.get(\n            \"bar_spacing\", self.DEFAULT_BAR_SPACING\n        )\n        self._max_bar_height: Optional[int] = kwargs.get(\n            \"max_bar_height\", self.DEFAULT_MAX_BAR_HEIGHT\n        )\n\n        # Text formats\n        self._title_text_format: Optional[TextFormat] = deepcopy(\n            kwargs.get(\"title_text_format\", TextFormat())\n        )\n        self._base_text_format: Optional[TextFormat] = deepcopy(\n            kwargs.get(\"base_text_format\", TextFormat())\n        )\n        self._inside_text_format: Optional[TextFormat] = deepcopy(\n            kwargs.get(\"inside_text_format\", TextFormat())\n        )\n        self._axis_text_format: Optional[TextFormat] = deepcopy(\n            kwargs.get(\"axis_text_format\", TextFormat())\n        )\n\n        # Label formatters\n        self._base_label_formatter: Optional[Callable[[str, float], str]] = kwargs.get(\n            \"base_label_formatter\", lambda label, value: label\n        )\n        self._inside_label_formatter: Optional[Callable[[str, float], str]] = (\n            kwargs.get(\"inside_label_formatter\", lambda label, value: str(value))\n        )\n\n        # Title\n        self._title: Optional[str] = kwargs.get(\"title\")\n\n        # Background color\n        self._background_color: Optional[Union[str, StandardColor]] = kwargs.get(\n            \"background_color\"\n        )\n\n        # Axis settings\n        self._show_axis: Optional[bool] = kwargs.get(\"show_axis\", False)\n        self._axis_tick_count: Optional[int] = kwargs.get(\n            \"axis_tick_count\", self.TICK_COUNT\n        )\n\n        # Bar appearance\n        bar_colors: Optional[list[Union[str, StandardColor, ColorScheme]]] = kwargs.get(\n            \"bar_colors\", [\"#66ccff\"]\n        )\n        self._bar_colors: list[Union[str, StandardColor, ColorScheme]] = (\n            self._normalize_colors(bar_colors, len(data))\n        )\n        self._original_bar_colors: Optional[\n            list[Union[str, StandardColor, ColorScheme]]\n        ] = bar_colors\n        self._glass: Optional[bool] = kwargs.get(\"glass\", False)\n        self._rounded: Optional[bool] = kwargs.get(\"rounded\", False)\n\n        # Build the chart\n        self._group: Group = Group()\n        self._build_chart()\n\n    # ------------------------------------------------------------------\n    # Properties\n    # ------------------------------------------------------------------\n\n    @property\n    def data(self) -&gt; dict[str, float]:\n        return self._data.copy()\n\n    @property\n    def position(self) -&gt; tuple[int, int]:\n        return self._position\n\n    @property\n    def group(self) -&gt; Group:\n        return self._group\n\n    # ------------------------------------------------------------------\n    # Public methods\n    # ------------------------------------------------------------------\n\n    def update_data(self, data: dict[str, Union[float, int]]) -&gt; None:\n        # Validate data\n        if not isinstance(data, dict):\n            raise TypeError(\"Data must be a dict.\")\n        if not data:\n            raise ValueError(\"Data cannot be empty.\")\n\n        invalid_keys = [key for key in data if not isinstance(key, str)]\n        if invalid_keys:\n            raise TypeError(f\"All keys must be strings. Invalid: {invalid_keys}\")\n\n        invalid_values = [\n            key for key, value in data.items() if not isinstance(value, (int, float))\n        ]\n        if invalid_values:\n            raise TypeError(f\"Values must be numeric. Invalid: {invalid_values}\")\n\n        self._data = data.copy()\n        self._bar_colors = self._normalize_colors(self._original_bar_colors, len(data))\n        self._rebuild()\n\n    def update_colors(\n        self, bar_colors: list[Union[str, StandardColor, ColorScheme]]\n    ) -&gt; None:\n        self._original_bar_colors = bar_colors\n        self._bar_colors = self._normalize_colors(bar_colors, len(self._data))\n        self._rebuild()\n\n    def move(self, new_position: tuple[int, int]) -&gt; None:\n        if not isinstance(new_position, (tuple, list)) or len(new_position) != 2:\n            raise ValueError(\"new_position must be a tuple of (x, y)\")\n\n        dx = new_position[0] - self._position[0]\n        dy = new_position[1] - self._position[1]\n\n        for obj in self._group.objects:\n            old_x, old_y = obj.position\n            obj.position = (old_x + dx, old_y + dy)\n\n        self._position = new_position\n        self._group.update_geometry()\n\n    def add_to_page(self, page: Page) -&gt; None:\n        for obj in self._group.objects:\n            page.add_object(obj)\n\n    # ------------------------------------------------------------------\n    # Private methods\n    # ------------------------------------------------------------------\n\n    def _normalize_colors(\n        self,\n        colors: list[Union[str, StandardColor, ColorScheme]],\n        count: int,\n    ) -&gt; list[Union[str, StandardColor, ColorScheme]]:\n        if not colors:\n            return [\"#66ccff\"] * count\n\n        # Cycle through the list until we have the right amount of colors\n        result = []\n        for i in range(count):\n            result.append(colors[i % len(colors)])\n        return result\n\n    def _calculate_scale(self) -&gt; float:\n        values = list(self._data.values())\n        max_value = max(values)\n        min_value = min(values)\n\n        if min_value &lt; 0:\n            raise ValueError(\"Negative values are not currently supported\")\n        if max_value == 0:\n            return 1\n        return self._max_bar_height / max_value\n\n    def _calculate_chart_dimensions(self) -&gt; tuple[int, int]:\n        num_bars = len(self._data)\n        width = num_bars * self._bar_width + (num_bars - 1) * self._bar_spacing\n        height = self._max_bar_height\n\n        # add space for base labels\n        height += (self._base_text_format.fontSize or 12) + self.LABEL_TOP_MARGIN\n\n        # add space for title\n        if self._title:\n            height += (\n                self._title_text_format.fontSize or 16\n            ) + self.TITLE_BOTTOM_MARGIN\n\n        return width, height\n\n    def _rebuild(self) -&gt; None:\n        self._group.objects.clear()\n        self._build_chart()\n\n    def _build_chart(self) -&gt; None:\n        x, y = self._position\n        scale = self._calculate_scale()\n\n        content_y = y\n        if self._title:\n            content_y += (\n                self._title_text_format.fontSize or 16\n            ) + self.TITLE_BOTTOM_MARGIN\n\n        if self._background_color:\n            self._add_background()\n        if self._title:\n            self._add_title()\n\n        # Add ticks and axis if enabled\n        if self._show_axis:\n            self._add_axis_and_ticks(content_y, scale)\n\n        for i, (key, value) in enumerate(self._data.items()):\n            self._add_bar_and_label(i, key, value, content_y, scale)\n\n        self._group.update_geometry()\n\n    def _add_background(self) -&gt; None:\n        width, height = self._calculate_chart_dimensions()\n        x, y = self._position\n\n        bg = Object(\n            value=\"\",\n            position=(x - self.BACKGROUND_PADDING, y - self.BACKGROUND_PADDING),\n            width=width + 2 * self.BACKGROUND_PADDING,\n            height=height + 2 * self.BACKGROUND_PADDING,\n            fillColor=self._background_color,\n            strokeColor=None,\n        )\n        self._group.add_object(bg)\n\n    def _add_title(self) -&gt; None:\n        x, y = self._position\n        chart_width, _ = self._calculate_chart_dimensions()\n\n        title_obj = Object(\n            value=self._title,\n            position=(x, y),\n            width=chart_width,\n            height=(self._title_text_format.fontSize or 16) + 4,\n            fillColor=\"none\",\n            strokeColor=\"none\",\n        )\n        title_obj.text_format = deepcopy(self._title_text_format)\n        title_obj.text_format.align = title_obj.text_format.align or \"center\"\n        title_obj.text_format.verticalAlign = (\n            title_obj.text_format.verticalAlign or \"top\"\n        )\n        self._group.add_object(title_obj)\n\n    # Draw axis and tick marks\n    def _add_axis_and_ticks(self, content_y: int, scale: float) -&gt; None:\n        x, _ = self._position\n\n        axis_x = x - self._bar_spacing\n        axis_y_top = content_y\n        axis_y_bottom = content_y + self._max_bar_height\n\n        axis_line = Object(\n            value=\"\",\n            position=(axis_x, axis_y_top),\n            width=1,\n            height=self._max_bar_height,\n            fillColor=None,\n            strokeColor=self.TICK_COLOR,\n        )\n        self._group.add_object(axis_line)\n\n        self._add_ticks(axis_x, content_y, scale)\n\n    def _add_ticks(self, axis_x: int, content_y: int, scale: float) -&gt; None:\n        if self._axis_tick_count &lt; 1:\n            return\n\n        max_value = max(self._data.values())\n        font_size = self._axis_text_format.fontSize or 12\n\n        for i in range(self._axis_tick_count + 1):\n            t = i / self._axis_tick_count\n\n            tick_value = max_value * (1 - t)\n            tick_y = content_y + (self._max_bar_height * t)\n\n            tick = Object(\n                value=\"\",\n                position=(axis_x - self.TICK_LENGTH, tick_y),\n                width=self.TICK_LENGTH,\n                height=1,\n                fillColor=None,\n                strokeColor=self.TICK_COLOR,\n            )\n            self._group.add_object(tick)\n\n            label_obj = Object(\n                value=str(round(tick_value, 2)),\n                position=(\n                    axis_x - self.TICK_LENGTH - self.TICK_LABEL_MARGIN - 40,\n                    tick_y - font_size / 2,\n                ),\n                width=40,\n                height=font_size + 4,\n                fillColor=\"none\",\n                strokeColor=\"none\",\n            )\n            label_obj.text_format = deepcopy(self._axis_text_format)\n            label_obj.text_format.align = \"right\"\n            self._group.add_object(label_obj)\n\n    def _add_bar_and_label(\n        self, index: int, key: str, value: float, content_y: int, scale: float\n    ) -&gt; None:\n        x, _ = self._position\n        bar_height = value * scale\n        if isinstance(self._bar_colors[index], ColorScheme):\n            color_scheme = self._bar_colors[index]\n        elif isinstance(self._bar_colors[index], (StandardColor, str)):\n            fill_color = self._bar_colors[index]\n\n        # Calculate geometry\n        bar_x = x + index * (self._bar_width + self._bar_spacing)\n        bar_y = content_y + (self._max_bar_height - bar_height)\n        bar_width = self._bar_width\n\n        # Resolve color\n        color_value = self._bar_colors[index]\n        color_scheme = color_value if isinstance(color_value, ColorScheme) else None\n        fill_color = None if color_scheme else color_value\n\n        # INSIDE LABEL\n        inside_label = self._inside_label_formatter(key, value)\n        inside_text_format = deepcopy(self._inside_text_format)\n        inside_text_format.align = inside_text_format.align or \"center\"\n        inside_text_format.verticalAlign = inside_text_format.verticalAlign or \"middle\"\n\n        bar = Object(\n            value=inside_label,\n            position=(bar_x, bar_y),\n            width=bar_width,\n            height=bar_height,\n            color_scheme=color_scheme,\n            fillColor=fill_color,\n            rounded=self._rounded,\n            glass=self._glass,\n            text_format=inside_text_format,\n        )\n\n        self._group.add_object(bar)\n\n        # BASE LABEL\n        base_label = self._base_label_formatter(key, value)\n        base_obj = Object(\n            value=base_label,\n            position=(bar_x, content_y + self._max_bar_height + self.LABEL_TOP_MARGIN),\n            width=bar_width,\n            height=(self._base_text_format.fontSize or 12) + 10,\n            fillColor=\"none\",\n            strokeColor=\"none\",\n        )\n        base_obj.text_format = deepcopy(self._base_text_format)\n        base_obj.text_format.align = base_obj.text_format.align or \"center\"\n        self._group.add_object(base_obj)\n\n    def __repr__(self) -&gt; str:\n        return f\"BarChart(bars={len(self._data)}, position={self._position})\"\n\n    def __len__(self) -&gt; int:\n        return len(self._data)\n</code></pre>"},{"location":"api/bar_chart/barchart/#src.drawpyo.diagram_types.bar_chart.BarChart.__init__","title":"<code>__init__(data, **kwargs)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, float]</code> <p>Mapping of labels to numeric values.</p> required <p>Other Parameters:</p> Name Type Description <code>position</code> <code>tuple[int, int]</code> <p>Chart top-left position. Default: (0, 0)</p> <code>bar_width</code> <code>int</code> <p>Width of each bar. Default: 40</p> <code>bar_spacing</code> <code>int</code> <p>Space between bars. Default: 20</p> <code>max_bar_height</code> <code>int</code> <p>Height of the largest bar. Default: 200</p> <code>bar_colors</code> <code>list[Union[str, StandardColor, ColorScheme]]</code> <p>List of colors. Default: [\"#66ccff\"]</p> <code>base_label_formatter</code> <code>Callable[[str, float], str]</code> <p>Custom label formatter for base (below) labels. Default: lambda l,v: l</p> <code>inside_label_formatter</code> <code>Callable[[str, float], str]</code> <p>Custom label formatter for inside-bar labels. Default: lambda l,v: str(v)</p> <code>title</code> <code>str</code> <p>Optional chart title. Default: None</p> <code>title_text_format</code> <code>TextFormat</code> <p>TextFormat for the title. Default: TextFormat()</p> <code>base_text_format</code> <code>TextFormat</code> <p>TextFormat for base labels. Default: TextFormat()</p> <code>inside_text_format</code> <code>TextFormat</code> <p>TextFormat for inside labels. Default: TextFormat()</p> <code>background_color</code> <code>str | StandardColor</code> <p>Optional chart background fill. Default: None</p> <code>show_axis</code> <code>bool</code> <p>Whether to show the axis and ticks. Default: False</p> <code>axis_tick_count</code> <code>int</code> <p>Number of tick intervals on the axis. Default: 5</p> <code>axis_text_format</code> <code>TextFormat</code> <p>TextFormat for axis tick labels. Default: TextFormat()</p> <code>glass</code> <code>bool</code> <p>Whether bars have a glass effect. Default: False</p> <code>rounded</code> <code>bool</code> <p>Whether bars have rounded corners. Default: False</p> Source code in <code>src/drawpyo/diagram_types/bar_chart.py</code> <pre><code>def __init__(self, data: dict[str, float], **kwargs):\n    \"\"\"\n    Args:\n        data (dict[str, float]): Mapping of labels to numeric values.\n\n    Keyword Args:\n        position (tuple[int, int]): Chart top-left position. Default: (0, 0)\n        bar_width (int): Width of each bar. Default: 40\n        bar_spacing (int): Space between bars. Default: 20\n        max_bar_height (int): Height of the largest bar. Default: 200\n        bar_colors (list[Union[str, StandardColor, ColorScheme]]): List of colors. Default: [\"#66ccff\"]\n        base_label_formatter (Callable[[str, float], str]): Custom label formatter for base (below) labels. Default: lambda l,v: l\n        inside_label_formatter (Callable[[str, float], str]): Custom label formatter for inside-bar labels. Default: lambda l,v: str(v)\n        title (str): Optional chart title. Default: None\n        title_text_format (TextFormat): TextFormat for the title. Default: TextFormat()\n        base_text_format (TextFormat): TextFormat for base labels. Default: TextFormat()\n        inside_text_format (TextFormat): TextFormat for inside labels. Default: TextFormat()\n        background_color (str | StandardColor): Optional chart background fill. Default: None\n        show_axis (bool): Whether to show the axis and ticks. Default: False\n        axis_tick_count (int): Number of tick intervals on the axis. Default: 5\n        axis_text_format (TextFormat): TextFormat for axis tick labels. Default: TextFormat()\n        glass (bool): Whether bars have a glass effect. Default: False\n        rounded (bool): Whether bars have rounded corners. Default: False\n    \"\"\"\n    # Validate data\n    if not isinstance(data, dict):\n        raise TypeError(\"Data must be a dict.\")\n    if not data:\n        raise ValueError(\"Data cannot be empty.\")\n\n    invalid_keys = [key for key in data if not isinstance(key, str)]\n    if invalid_keys:\n        raise TypeError(f\"All keys must be strings. Invalid: {invalid_keys}\")\n\n    invalid_values = [\n        key for key, value in data.items() if not isinstance(value, (int, float))\n    ]\n    if invalid_values:\n        raise TypeError(f\"Values must be numeric. Invalid: {invalid_values}\")\n\n    self._data: dict[str, Union[int, float]] = data.copy()\n\n    # Position and dimensions\n    self._position: Optional[tuple[int, int]] = kwargs.get(\"position\", (0, 0))\n    self._bar_width: Optional[int] = kwargs.get(\"bar_width\", self.DEFAULT_BAR_WIDTH)\n    self._bar_spacing: Optional[int] = kwargs.get(\n        \"bar_spacing\", self.DEFAULT_BAR_SPACING\n    )\n    self._max_bar_height: Optional[int] = kwargs.get(\n        \"max_bar_height\", self.DEFAULT_MAX_BAR_HEIGHT\n    )\n\n    # Text formats\n    self._title_text_format: Optional[TextFormat] = deepcopy(\n        kwargs.get(\"title_text_format\", TextFormat())\n    )\n    self._base_text_format: Optional[TextFormat] = deepcopy(\n        kwargs.get(\"base_text_format\", TextFormat())\n    )\n    self._inside_text_format: Optional[TextFormat] = deepcopy(\n        kwargs.get(\"inside_text_format\", TextFormat())\n    )\n    self._axis_text_format: Optional[TextFormat] = deepcopy(\n        kwargs.get(\"axis_text_format\", TextFormat())\n    )\n\n    # Label formatters\n    self._base_label_formatter: Optional[Callable[[str, float], str]] = kwargs.get(\n        \"base_label_formatter\", lambda label, value: label\n    )\n    self._inside_label_formatter: Optional[Callable[[str, float], str]] = (\n        kwargs.get(\"inside_label_formatter\", lambda label, value: str(value))\n    )\n\n    # Title\n    self._title: Optional[str] = kwargs.get(\"title\")\n\n    # Background color\n    self._background_color: Optional[Union[str, StandardColor]] = kwargs.get(\n        \"background_color\"\n    )\n\n    # Axis settings\n    self._show_axis: Optional[bool] = kwargs.get(\"show_axis\", False)\n    self._axis_tick_count: Optional[int] = kwargs.get(\n        \"axis_tick_count\", self.TICK_COUNT\n    )\n\n    # Bar appearance\n    bar_colors: Optional[list[Union[str, StandardColor, ColorScheme]]] = kwargs.get(\n        \"bar_colors\", [\"#66ccff\"]\n    )\n    self._bar_colors: list[Union[str, StandardColor, ColorScheme]] = (\n        self._normalize_colors(bar_colors, len(data))\n    )\n    self._original_bar_colors: Optional[\n        list[Union[str, StandardColor, ColorScheme]]\n    ] = bar_colors\n    self._glass: Optional[bool] = kwargs.get(\"glass\", False)\n    self._rounded: Optional[bool] = kwargs.get(\"rounded\", False)\n\n    # Build the chart\n    self._group: Group = Group()\n    self._build_chart()\n</code></pre>"},{"location":"api/binary_tree_diagram/binarynodeobject/","title":"BinaryNodeObject","text":""},{"location":"api/binary_tree_diagram/binarynodeobject/#src.drawpyo.diagram_types.binary_tree.BinaryNodeObject","title":"<code>src.drawpyo.diagram_types.binary_tree.BinaryNodeObject</code>","text":"<p>               Bases: <code>NodeObject</code></p> <p>NodeObject variant for binary trees exposing <code>left</code> and <code>right</code> properties and enforcing at most two children.</p> Source code in <code>src/drawpyo/diagram_types/binary_tree.py</code> <pre><code>class BinaryNodeObject(NodeObject):\n    \"\"\"\n    NodeObject variant for binary trees exposing `left` and `right` properties\n    and enforcing at most two children.\n    \"\"\"\n\n    def __init__(self, tree=None, **kwargs) -&gt; None:\n        \"\"\"\n        Initialize a binary node with exactly 2 child slots [left, right].\n\n        If `tree_children` is provided, it is normalized to two elements.\n        \"\"\"\n        children: List[Optional[BinaryNodeObject]] = kwargs.get(\"tree_children\", [])\n\n        # Normalize provided list to exactly 2 elements\n        if len(children) == 0:\n            normalized = [None, None]\n        elif len(children) == 1:\n            normalized = [children[0], None]\n        elif len(children) == 2:\n            normalized = children[:]\n        else:\n            raise ValueError(\"BinaryNodeObject cannot have more than two children\")\n\n        kwargs[\"tree_children\"] = normalized\n        super().__init__(tree=tree, **kwargs)\n\n    # ---------------------------------------------------------\n    # Private methods\n    # ---------------------------------------------------------\n\n    def _ensure_two_slots(self) -&gt; None:\n        \"\"\"Ensure tree_children always has exactly 2 slots.\"\"\"\n        if len(self.tree_children) &lt; 2:\n            missing = 2 - len(self.tree_children)\n            self.tree_children.extend([None] * missing)\n        elif len(self.tree_children) &gt; 2:\n            self.tree_children[:] = self.tree_children[:2]\n\n    def _detach_from_old_parent(self, node: NodeObject) -&gt; None:\n        \"\"\"Remove `node` from its old parent's children (if any).\"\"\"\n        parent = getattr(node, \"tree_parent\", None)\n        if parent is None or parent is self:\n            return\n\n        if hasattr(parent, \"tree_children\"):\n            for i, existing in enumerate(parent.tree_children):\n                if existing is node:\n                    parent.tree_children[i] = None\n                    break\n\n        node._tree_parent = None\n\n    def _clear_existing_slot(self, node: NodeObject, target_index: int) -&gt; None:\n        \"\"\"\n        If `node` already belongs to this parent in the *other* slot,\n        clear the old slot.\n        \"\"\"\n        for i, existing in enumerate(self.tree_children):\n            if existing is node and i != target_index:\n                self.tree_children[i] = None\n\n    def _assign_child(self, index: int, node: Optional[NodeObject]) -&gt; None:\n        \"\"\"\n        Handles:\n        - Ensuring slot count\n        - Clearing old child if assigning None\n        - Preventing more than 2 distinct children\n        - Correctly detaching and reattaching node\n        \"\"\"\n        self._ensure_two_slots()\n        existing = self.tree_children[index]\n\n        if node is None:\n            if existing is not None:\n                self.tree_children[index] = None\n                existing._tree_parent = None\n            return\n\n        if not node in self.tree_children:\n            other = 1 - index\n            if (\n                self.tree_children[index] is not None\n                and self.tree_children[other] is not None\n            ):\n                raise ValueError(\"BinaryNodeObject cannot have more than two children\")\n\n        self._detach_from_old_parent(node)\n\n        self._clear_existing_slot(node, index)\n\n        self.tree_children[index] = node\n        node._tree_parent = self\n\n    # ---------------------------------------------------------\n    # Properties and setters\n    # ---------------------------------------------------------\n\n    @property\n    def left(self) -&gt; Optional[NodeObject]:\n        self._ensure_two_slots()\n        return self.tree_children[0]\n\n    @left.setter\n    def left(self, node: Optional[NodeObject]) -&gt; None:\n        self._assign_child(0, node)\n\n    @property\n    def right(self) -&gt; Optional[NodeObject]:\n        self._ensure_two_slots()\n        return self.tree_children[1]\n\n    @right.setter\n    def right(self, node: Optional[NodeObject]) -&gt; None:\n        self._assign_child(1, node)\n</code></pre>"},{"location":"api/binary_tree_diagram/binarynodeobject/#src.drawpyo.diagram_types.binary_tree.BinaryNodeObject.__init__","title":"<code>__init__(tree=None, **kwargs)</code>","text":"<p>Initialize a binary node with exactly 2 child slots [left, right].</p> <p>If <code>tree_children</code> is provided, it is normalized to two elements.</p> Source code in <code>src/drawpyo/diagram_types/binary_tree.py</code> <pre><code>def __init__(self, tree=None, **kwargs) -&gt; None:\n    \"\"\"\n    Initialize a binary node with exactly 2 child slots [left, right].\n\n    If `tree_children` is provided, it is normalized to two elements.\n    \"\"\"\n    children: List[Optional[BinaryNodeObject]] = kwargs.get(\"tree_children\", [])\n\n    # Normalize provided list to exactly 2 elements\n    if len(children) == 0:\n        normalized = [None, None]\n    elif len(children) == 1:\n        normalized = [children[0], None]\n    elif len(children) == 2:\n        normalized = children[:]\n    else:\n        raise ValueError(\"BinaryNodeObject cannot have more than two children\")\n\n    kwargs[\"tree_children\"] = normalized\n    super().__init__(tree=tree, **kwargs)\n</code></pre>"},{"location":"api/binary_tree_diagram/binarytreediagram/","title":"BinaryTreeDiagram","text":""},{"location":"api/binary_tree_diagram/binarytreediagram/#src.drawpyo.diagram_types.binary_tree.BinaryTreeDiagram","title":"<code>src.drawpyo.diagram_types.binary_tree.BinaryTreeDiagram</code>","text":"<p>               Bases: <code>TreeDiagram</code></p> <p>Simplifies TreeDiagram for binary-tree convenience.</p> Source code in <code>src/drawpyo/diagram_types/binary_tree.py</code> <pre><code>class BinaryTreeDiagram(TreeDiagram):\n    \"\"\"Simplifies TreeDiagram for binary-tree convenience.\"\"\"\n\n    DEFAULT_LEVEL_SPACING = 80\n    DEFAULT_ITEM_SPACING = 20\n    DEFAULT_GROUP_SPACING = 30\n    DEFAULT_LINK_STYLE = \"straight\"\n\n    def __init__(self, **kwargs) -&gt; None:\n        kwargs.setdefault(\"level_spacing\", self.DEFAULT_LEVEL_SPACING)\n        kwargs.setdefault(\"item_spacing\", self.DEFAULT_ITEM_SPACING)\n        kwargs.setdefault(\"group_spacing\", self.DEFAULT_GROUP_SPACING)\n        kwargs.setdefault(\"link_style\", self.DEFAULT_LINK_STYLE)\n        super().__init__(**kwargs)\n\n    def _attach(\n        self, parent: BinaryNodeObject, child: BinaryNodeObject, side: str\n    ) -&gt; None:\n        if not isinstance(parent, BinaryNodeObject) or not isinstance(\n            child, BinaryNodeObject\n        ):\n            raise TypeError(\"parent and child must be BinaryNodeObject instances\")\n\n        if parent.tree is not self:\n            parent.tree = self\n        child.tree = self\n\n        setattr(parent, side, child)\n\n    def add_left(self, parent: BinaryNodeObject, child: BinaryNodeObject) -&gt; None:\n        self._attach(parent, child, \"left\")\n\n    def add_right(self, parent: BinaryNodeObject, child: BinaryNodeObject) -&gt; None:\n        self._attach(parent, child, \"right\")\n\n    @classmethod\n    def from_dict(self, data: Dict[str, Any], **kwargs) -&gt; BinaryTreeDiagram:\n        \"\"\"\n        Create a BinaryTreeDiagram from a nested dictionary structure.\n\n        Each key represents a node, and its value is either None or another\n        dictionary with up to two keys (left and right children).\n        \"\"\"\n        pass  # Implementation would go here\n</code></pre>"},{"location":"api/binary_tree_diagram/binarytreediagram/#src.drawpyo.diagram_types.binary_tree.BinaryTreeDiagram.from_dict","title":"<code>from_dict(data, **kwargs)</code>  <code>classmethod</code>","text":"<p>Create a BinaryTreeDiagram from a nested dictionary structure.</p> <p>Each key represents a node, and its value is either None or another dictionary with up to two keys (left and right children).</p> Source code in <code>src/drawpyo/diagram_types/binary_tree.py</code> <pre><code>@classmethod\ndef from_dict(self, data: Dict[str, Any], **kwargs) -&gt; BinaryTreeDiagram:\n    \"\"\"\n    Create a BinaryTreeDiagram from a nested dictionary structure.\n\n    Each key represents a node, and its value is either None or another\n    dictionary with up to two keys (left and right children).\n    \"\"\"\n    pass  # Implementation would go here\n</code></pre>"},{"location":"api/legend/legend/","title":"Legend","text":""},{"location":"api/legend/legend/#src.drawpyo.diagram_types.legend.Legend","title":"<code>src.drawpyo.diagram_types.legend.Legend</code>","text":"<p>A simple color/label legend diagram.</p> Source code in <code>src/drawpyo/diagram_types/legend.py</code> <pre><code>class Legend:\n    \"\"\"A simple color/label legend diagram.\"\"\"\n\n    # Layout constants\n    COLOR_BOX_SIZE = 20\n    COLOR_TEXT_GAP = 10\n    ROW_GAP = 8\n    TITLE_BOTTOM_MARGIN = 20\n    BACKGROUND_PADDING = 15\n\n    def __init__(\n        self, mapping: dict[str, Union[str, StandardColor, ColorScheme]], **kwargs\n    ):\n        \"\"\"\n        Args:\n            mapping (dict[str, StandardColor, ColorScheme]): Mapping of labels to colors.\n\n        Keyword Args:\n            position (tuple[int, int]): Top-left diagram position. Default: (0, 0)\n            title (str): Optional title.\n            title_text_format (TextFormat): Formatting for the title.\n            label_text_format (TextFormat): Formatting for labels.\n            glass (bool): Whether color boxes have a glass effect. Default: False\n            rounded (bool): Whether color boxes have rounded corners. Default: False\n            background_color (str | StandardColor): Optional background fill color.\n        \"\"\"\n\n        if not isinstance(mapping, dict) or not mapping:\n            raise ValueError(\"Mapping must be a non-empty dict.\")\n\n        self._mapping: dict[str, Union[str, StandardColor, ColorScheme]] = (\n            mapping.copy()\n        )\n\n        # Position\n        self._position: tuple[int, int] = kwargs.get(\"position\", (0, 0))\n\n        # Title\n        self._title: Optional[str] = kwargs.get(\"title\")\n\n        # Text formats\n        self._title_text_format: TextFormat = deepcopy(\n            kwargs.get(\"title_text_format\", TextFormat())\n        )\n        self._label_text_format: TextFormat = deepcopy(\n            kwargs.get(\"label_text_format\", TextFormat())\n        )\n\n        # Color box styles\n        self._glass: Optional[bool] = kwargs.get(\"glass\", False)\n        self._rounded: Optional[bool] = kwargs.get(\"rounded\", False)\n\n        # Background\n        self._background_color: Optional[Union[str, StandardColor]] = kwargs.get(\n            \"background_color\"\n        )\n\n        self._group = Group()\n        self._build()\n\n    # -----------------------------------------------------\n    # Public methods\n    # -----------------------------------------------------\n\n    @property\n    def group(self) -&gt; Group:\n        return self._group\n\n    @property\n    def position(self) -&gt; tuple[int, int]:\n        return self._position\n\n    def update_mapping(\n        self, mapping: dict[str, Union[str, StandardColor, ColorScheme]]\n    ):\n        self._mapping = mapping.copy()\n        self._rebuild()\n\n    def move(self, new_position: tuple[int, int]):\n        new_x, new_y = new_position\n        old_x, old_y = self._position\n        dx = new_x - old_x\n        dy = new_y - old_y\n\n        for obj in self._group.objects:\n            x, y = obj.position\n            obj.position = (x + dx, y + dy)\n\n        self._position = new_position\n        self._group.update_geometry()\n\n    def add_to_page(self, page: Page):\n        for obj in self._group.objects:\n            page.add_object(obj)\n\n    # -----------------------------------------------------\n    # Private methods\n    # -----------------------------------------------------\n\n    def _rebuild(self):\n        self._group.objects.clear()\n        self._build()\n\n    def _build(self):\n        x, y = self._position\n\n        title_offset = (\n            (self._title_text_format.fontSize or 16) + self.TITLE_BOTTOM_MARGIN\n            if self._title\n            else 0\n        )\n\n        bg_width, bg_height = self._compute_background_dimensions(title_offset)\n\n        if self._background_color:\n            self._add_background(bg_width, bg_height, title_offset)\n\n        if self._title:\n            self._add_title()\n\n        current_y = y + title_offset\n\n        # Create rows\n        for label, color in self._mapping.items():\n            self._add_row(label, color, current_y)\n            current_y += self.COLOR_BOX_SIZE + self.ROW_GAP\n\n        self._group.update_geometry()\n\n    def _compute_background_dimensions(self, title_offset: int) -&gt; tuple[int, int]:\n        \"\"\"Compute background size dynamically based on label lengths.\"\"\"\n\n        # Estimate text width\n        max_text_len = max(len(label) for label in self._mapping)\n        approx_text_width = max_text_len * 8\n\n        width = (\n            self.COLOR_BOX_SIZE\n            + self.COLOR_TEXT_GAP\n            + approx_text_width\n            + (2 * self.BACKGROUND_PADDING)\n        )\n        height = (\n            title_offset\n            + len(self._mapping) * (self.COLOR_BOX_SIZE + self.ROW_GAP)\n            - self.ROW_GAP\n            + (2 * self.BACKGROUND_PADDING)\n        )\n\n        return width, height\n\n    def _add_background(self, w: int, h: int, title_offset: int):\n        x, y = self._position\n        bg = Object(\n            value=\"\",\n            position=(x - self.BACKGROUND_PADDING, y - self.BACKGROUND_PADDING),\n            width=w,\n            height=h,\n            fillColor=self._background_color,\n            strokeColor=None,\n        )\n        self._group.add_object(bg)\n\n    def _add_title(self):\n        x, y = self._position\n        text_h = (self._title_text_format.fontSize or 16) + 4\n\n        title_obj = Object(\n            value=self._title,\n            position=(x, y),\n            width=200,\n            height=text_h,\n            fillColor=\"none\",\n            strokeColor=\"none\",\n        )\n\n        title_obj.text_format = deepcopy(self._title_text_format)\n        title_obj.text_format.align = \"left\"\n        title_obj.text_format.verticalAlign = \"top\"\n\n        self._group.add_object(title_obj)\n\n    def _add_row(\n        self, label: str, color: Union[str, StandardColor, ColorScheme], y: int\n    ):\n        x, _ = self._position\n\n        # Color square\n        color_box = Object(\n            value=\"\",\n            position=(x, y),\n            width=self.COLOR_BOX_SIZE,\n            height=self.COLOR_BOX_SIZE,\n            fillColor=None if isinstance(color, ColorScheme) else color,\n            color_scheme=(color if isinstance(color, ColorScheme) else None),\n            rounded=self._rounded,\n            glass=self._glass,\n        )\n        self._group.add_object(color_box)\n\n        # Text label\n        label_obj = Object(\n            value=label,\n            position=(x + self.COLOR_BOX_SIZE + self.COLOR_TEXT_GAP, y),\n            width=200,\n            height=self.COLOR_BOX_SIZE,\n            fillColor=\"none\",\n            strokeColor=\"none\",\n        )\n        label_obj.text_format = deepcopy(self._label_text_format)\n        label_obj.text_format.align = \"left\"\n        label_obj.text_format.verticalAlign = \"middle\"\n\n        self._group.add_object(label_obj)\n\n    def __repr__(self):\n        return f\"Legend(items={len(self._mapping)}, position={self._position})\"\n</code></pre>"},{"location":"api/legend/legend/#src.drawpyo.diagram_types.legend.Legend.__init__","title":"<code>__init__(mapping, **kwargs)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>mapping</code> <code>dict[str, StandardColor, ColorScheme]</code> <p>Mapping of labels to colors.</p> required <p>Other Parameters:</p> Name Type Description <code>position</code> <code>tuple[int, int]</code> <p>Top-left diagram position. Default: (0, 0)</p> <code>title</code> <code>str</code> <p>Optional title.</p> <code>title_text_format</code> <code>TextFormat</code> <p>Formatting for the title.</p> <code>label_text_format</code> <code>TextFormat</code> <p>Formatting for labels.</p> <code>glass</code> <code>bool</code> <p>Whether color boxes have a glass effect. Default: False</p> <code>rounded</code> <code>bool</code> <p>Whether color boxes have rounded corners. Default: False</p> <code>background_color</code> <code>str | StandardColor</code> <p>Optional background fill color.</p> Source code in <code>src/drawpyo/diagram_types/legend.py</code> <pre><code>def __init__(\n    self, mapping: dict[str, Union[str, StandardColor, ColorScheme]], **kwargs\n):\n    \"\"\"\n    Args:\n        mapping (dict[str, StandardColor, ColorScheme]): Mapping of labels to colors.\n\n    Keyword Args:\n        position (tuple[int, int]): Top-left diagram position. Default: (0, 0)\n        title (str): Optional title.\n        title_text_format (TextFormat): Formatting for the title.\n        label_text_format (TextFormat): Formatting for labels.\n        glass (bool): Whether color boxes have a glass effect. Default: False\n        rounded (bool): Whether color boxes have rounded corners. Default: False\n        background_color (str | StandardColor): Optional background fill color.\n    \"\"\"\n\n    if not isinstance(mapping, dict) or not mapping:\n        raise ValueError(\"Mapping must be a non-empty dict.\")\n\n    self._mapping: dict[str, Union[str, StandardColor, ColorScheme]] = (\n        mapping.copy()\n    )\n\n    # Position\n    self._position: tuple[int, int] = kwargs.get(\"position\", (0, 0))\n\n    # Title\n    self._title: Optional[str] = kwargs.get(\"title\")\n\n    # Text formats\n    self._title_text_format: TextFormat = deepcopy(\n        kwargs.get(\"title_text_format\", TextFormat())\n    )\n    self._label_text_format: TextFormat = deepcopy(\n        kwargs.get(\"label_text_format\", TextFormat())\n    )\n\n    # Color box styles\n    self._glass: Optional[bool] = kwargs.get(\"glass\", False)\n    self._rounded: Optional[bool] = kwargs.get(\"rounded\", False)\n\n    # Background\n    self._background_color: Optional[Union[str, StandardColor]] = kwargs.get(\n        \"background_color\"\n    )\n\n    self._group = Group()\n    self._build()\n</code></pre>"},{"location":"api/pie_chart/piechart/","title":"Pie Chart","text":""},{"location":"api/pie_chart/piechart/#src.drawpyo.diagram_types.pie_chart.PieChart","title":"<code>src.drawpyo.diagram_types.pie_chart.PieChart</code>","text":"<p>A configurable pie chart built entirely from Object, Group, and PieSlice.</p> <p>This chart is mutable - you can update data, styling, and position after creation.</p> Source code in <code>src/drawpyo/diagram_types/pie_chart.py</code> <pre><code>class PieChart:\n    \"\"\"A configurable pie chart built entirely from Object, Group, and PieSlice.\n\n    This chart is mutable - you can update data, styling, and position after creation.\n    \"\"\"\n\n    # Layout constants\n    DEFAULT_SIZE = 200\n    TITLE_BOTTOM_MARGIN = 20\n    LABEL_OFFSET = 5\n    BACKGROUND_PADDING = 20\n\n    def __init__(self, data: dict[str, float], **kwargs):\n        \"\"\"\n        Args:\n            data (dict[str, float]): Mapping of labels to numeric values.\n\n        Keyword Args:\n            position (tuple[int, int]): Top-left chart position. Default: (0, 0)\n            size (int): Diameter of the pie. Default: 200\n            slice_colors (list[str | StandardColor | ColorScheme]): Colors for slices.\n            title (str): Optional title.\n            title_text_format (TextFormat): Formatting for the title.\n            label_text_format (TextFormat): Formatting for labels.\n            background_color (str | StandardColor): Optional chart background.\n            label_formatter (Callable[[str, float], str]): Custom formatter for slice labels.\n        \"\"\"\n\n        # Validate data\n        if not isinstance(data, dict):\n            raise TypeError(\"Data must be a dict.\")\n        if not data:\n            raise ValueError(\"Data cannot be empty.\")\n\n        invalid_keys = [k for k in data if not isinstance(k, str)]\n        if invalid_keys:\n            raise TypeError(f\"All keys must be strings: {invalid_keys}\")\n\n        invalid_values = [k for k, v in data.items() if not isinstance(v, (int, float))]\n        if invalid_values:\n            raise TypeError(f\"Values must be numeric: {invalid_values}\")\n\n        self._data: dict[str, float] = data.copy()\n\n        # Position and size\n        self._position: tuple[int, int] = kwargs.get(\"position\", (0, 0))\n        self._size: int = kwargs.get(\"size\", self.DEFAULT_SIZE)\n\n        # Text formats\n        self._title_text_format: TextFormat = deepcopy(\n            kwargs.get(\"title_text_format\", TextFormat())\n        )\n        self._label_text_format: TextFormat = deepcopy(\n            kwargs.get(\"label_text_format\", TextFormat())\n        )\n\n        # Title\n        self._title: Optional[str] = kwargs.get(\"title\")\n\n        # Background\n        self._background_color = kwargs.get(\"background_color\")\n\n        # Colors\n        slice_colors: list[Union[str, StandardColor, ColorScheme]] = kwargs.get(\n            \"slice_colors\", [\"#66ccff\"]\n        )\n        self._slice_colors: list = self._normalize_colors(slice_colors, len(data))\n        self._original_slice_colors = slice_colors\n\n        # Label formatting\n        self._label_formatter: Callable[[str, float, float], str] = kwargs.get(\n            \"label_formatter\", self.default_label_formatter\n        )\n\n        # Build\n        self._group: Group = Group()\n        self._build_chart()\n\n    # ------------------------------------------------------------------\n    # Properties\n    # ------------------------------------------------------------------\n\n    @property\n    def data(self) -&gt; dict[str, float]:\n        return self._data.copy()\n\n    @property\n    def position(self) -&gt; tuple[int, int]:\n        return self._position\n\n    @property\n    def group(self) -&gt; Group:\n        return self._group\n\n    # ------------------------------------------------------------------\n    # Public methods\n    # ------------------------------------------------------------------\n\n    def update_data(self, data: dict[str, float]) -&gt; None:\n        if not isinstance(data, dict):\n            raise TypeError(\"Data must be a dict.\")\n        if not data:\n            raise ValueError(\"Data cannot be empty.\")\n\n        self._data = data.copy()\n        self._slice_colors = self._normalize_colors(\n            self._original_slice_colors, len(data)\n        )\n        self._rebuild()\n\n    def update_colors(self, slice_colors: list[Union[str, StandardColor, ColorScheme]]):\n        self._original_slice_colors = slice_colors\n        self._slice_colors = self._normalize_colors(slice_colors, len(self._data))\n        self._rebuild()\n\n    def move(self, new_position: tuple[int, int]):\n        new_x, new_y = new_position\n        old_x, old_y = self._position\n        dx = new_x - old_x\n        dy = new_y - old_y\n\n        for obj in self._group.objects:\n            ox, oy = obj.position\n            obj.position = (ox + dx, oy + dy)\n\n        self._position = new_position\n        self._group.update_geometry()\n\n    def add_to_page(self, page: Page):\n        for obj in self._group.objects:\n            page.add_object(obj)\n\n    def default_label_formatter(self, key, value, total):\n        return f\"{key}: {value/total*100:.1f}%\"\n\n    # ------------------------------------------------------------------\n    # Private methods\n    # ------------------------------------------------------------------\n\n    def _normalize_colors(self, colors, count):\n        if not colors:\n            return [\"#66ccff\"] * count\n        return [colors[i % len(colors)] for i in range(count)]\n\n    def _rebuild(self):\n        self._group.objects.clear()\n        self._build_chart()\n\n    def _build_chart(self):\n        x, y = self._position\n\n        # Compute vertical offsets if title is present\n        title_h = (\n            (self._title_text_format.fontSize or 16) + self.TITLE_BOTTOM_MARGIN\n            if self._title\n            else 0\n        )\n        pie_y = y + title_h\n\n        if self._background_color:\n            self._add_background(title_h)\n        if self._title:\n            self._add_title()\n\n        total = sum(self._data.values())\n        if total == 0:\n            total = 1.0  # Avoid division by zero\n\n        start_angle = 0.0\n\n        for i, (label, value) in enumerate(self._data.items()):\n            fraction = value / total if total else 0\n            slice_color = self._slice_colors[i]\n\n            slice_obj = PieSlice(\n                value=\"\",\n                slice_value=fraction,\n                position=(x, pie_y),\n                size=self._size,\n                startAngle=start_angle,\n                fillColor=None if isinstance(slice_color, ColorScheme) else slice_color,\n                color_scheme=(\n                    slice_color if isinstance(slice_color, ColorScheme) else None\n                ),\n            )\n\n            self._group.add_object(slice_obj)\n\n            # SLICE LABEL\n            slice_label_pos = self._get_slice_label_position(\n                start_angle, fraction, x, pie_y\n            )\n            slice_text = self._label_formatter(label, value, total)\n            slice_label = Object(\n                value=slice_text,\n                position=slice_label_pos,\n                width=self._size,\n                height=self._size,\n                color_scheme=(\n                    slice_color if isinstance(slice_color, ColorScheme) else None\n                ),\n                fillColor=\"none\",\n                strokeColor=\"none\",\n            )\n            self._group.add_object(slice_label)\n\n            start_angle += fraction\n\n        self._group.update_geometry()\n\n    def _get_slice_label_position(\n        self, start_angle: float, fraction: float, x: int, y: int\n    ) -&gt; tuple[int, int]:\n        import math\n\n        # Mittelpunktwinkel der Scheibe (normalisiert 0\u20131)\n        mid_angle = start_angle + (fraction / 2)\n\n        # In Radiant umrechnen (Uhrzeigersinn)\n        theta = (mid_angle * 2 * math.pi) - (math.pi / 2)\n\n        # Radius + Offset\n        offset = (self._size / 4) + self.LABEL_OFFSET\n\n        # Kreisposition berechnen\n        label_x = x + math.cos(theta) * offset\n        label_y = y + math.sin(theta) * offset\n\n        return (label_x, label_y)\n\n    def _add_background(self, title_h: int):\n        x, y = self._position\n        size = self._size\n        bg = Object(\n            value=\"\",\n            position=(x - self.BACKGROUND_PADDING, y - self.BACKGROUND_PADDING),\n            width=size + 2 * self.BACKGROUND_PADDING,\n            height=size + 2 * self.BACKGROUND_PADDING + title_h,\n            fillColor=self._background_color,\n            strokeColor=None,\n        )\n        self._group.add_object(bg)\n\n    def _add_title(self):\n        x, y = self._position\n        title_height = (self._title_text_format.fontSize or 16) + 4\n\n        title_obj = Object(\n            value=self._title,\n            position=(x, y),\n            width=self._size,\n            height=title_height,\n            fillColor=\"none\",\n            strokeColor=\"none\",\n        )\n\n        title_obj.text_format = deepcopy(self._title_text_format)\n        title_obj.text_format.align = \"center\"\n        title_obj.text_format.verticalAlign = \"top\"\n\n        self._group.add_object(title_obj)\n\n    def __repr__(self):\n        return f\"PieChart(slices={len(self._data)}, position={self._position})\"\n</code></pre>"},{"location":"api/pie_chart/piechart/#src.drawpyo.diagram_types.pie_chart.PieChart.__init__","title":"<code>__init__(data, **kwargs)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, float]</code> <p>Mapping of labels to numeric values.</p> required <p>Other Parameters:</p> Name Type Description <code>position</code> <code>tuple[int, int]</code> <p>Top-left chart position. Default: (0, 0)</p> <code>size</code> <code>int</code> <p>Diameter of the pie. Default: 200</p> <code>slice_colors</code> <code>list[str | StandardColor | ColorScheme]</code> <p>Colors for slices.</p> <code>title</code> <code>str</code> <p>Optional title.</p> <code>title_text_format</code> <code>TextFormat</code> <p>Formatting for the title.</p> <code>label_text_format</code> <code>TextFormat</code> <p>Formatting for labels.</p> <code>background_color</code> <code>str | StandardColor</code> <p>Optional chart background.</p> <code>label_formatter</code> <code>Callable[[str, float], str]</code> <p>Custom formatter for slice labels.</p> Source code in <code>src/drawpyo/diagram_types/pie_chart.py</code> <pre><code>def __init__(self, data: dict[str, float], **kwargs):\n    \"\"\"\n    Args:\n        data (dict[str, float]): Mapping of labels to numeric values.\n\n    Keyword Args:\n        position (tuple[int, int]): Top-left chart position. Default: (0, 0)\n        size (int): Diameter of the pie. Default: 200\n        slice_colors (list[str | StandardColor | ColorScheme]): Colors for slices.\n        title (str): Optional title.\n        title_text_format (TextFormat): Formatting for the title.\n        label_text_format (TextFormat): Formatting for labels.\n        background_color (str | StandardColor): Optional chart background.\n        label_formatter (Callable[[str, float], str]): Custom formatter for slice labels.\n    \"\"\"\n\n    # Validate data\n    if not isinstance(data, dict):\n        raise TypeError(\"Data must be a dict.\")\n    if not data:\n        raise ValueError(\"Data cannot be empty.\")\n\n    invalid_keys = [k for k in data if not isinstance(k, str)]\n    if invalid_keys:\n        raise TypeError(f\"All keys must be strings: {invalid_keys}\")\n\n    invalid_values = [k for k, v in data.items() if not isinstance(v, (int, float))]\n    if invalid_values:\n        raise TypeError(f\"Values must be numeric: {invalid_values}\")\n\n    self._data: dict[str, float] = data.copy()\n\n    # Position and size\n    self._position: tuple[int, int] = kwargs.get(\"position\", (0, 0))\n    self._size: int = kwargs.get(\"size\", self.DEFAULT_SIZE)\n\n    # Text formats\n    self._title_text_format: TextFormat = deepcopy(\n        kwargs.get(\"title_text_format\", TextFormat())\n    )\n    self._label_text_format: TextFormat = deepcopy(\n        kwargs.get(\"label_text_format\", TextFormat())\n    )\n\n    # Title\n    self._title: Optional[str] = kwargs.get(\"title\")\n\n    # Background\n    self._background_color = kwargs.get(\"background_color\")\n\n    # Colors\n    slice_colors: list[Union[str, StandardColor, ColorScheme]] = kwargs.get(\n        \"slice_colors\", [\"#66ccff\"]\n    )\n    self._slice_colors: list = self._normalize_colors(slice_colors, len(data))\n    self._original_slice_colors = slice_colors\n\n    # Label formatting\n    self._label_formatter: Callable[[str, float, float], str] = kwargs.get(\n        \"label_formatter\", self.default_label_formatter\n    )\n\n    # Build\n    self._group: Group = Group()\n    self._build_chart()\n</code></pre>"},{"location":"api/tree_diagram/nodeobject/","title":"NodeObject","text":""},{"location":"api/tree_diagram/nodeobject/#src.drawpyo.diagram_types.tree.NodeObject","title":"<code>src.drawpyo.diagram_types.tree.NodeObject</code>","text":"<p>               Bases: <code>Object</code></p> <p>This class defines one of the nodes on a tree graph. It inherits from Object and performs the same in most regards. It also tracks the tree-specific parameters like the tree, children, parent, etc.</p> Source code in <code>src/drawpyo/diagram_types/tree.py</code> <pre><code>class NodeObject(Object):\n    \"\"\"This class defines one of the nodes on a tree graph. It inherits from Object and performs the same in most regards. It also tracks the tree-specific parameters like the tree, children, parent, etc.\"\"\"\n\n    def __init__(self, tree=None, **kwargs) -&gt; None:\n        \"\"\"The NodeObject should be instantiated with an owning tree object. A NodeObject can only have a single parent but can have any number of children.\n        Args:\n            tree (TreeDiagram, optional): The owning tree diagram. Defaults to None.\n\n        Keyword Args:\n            tree_children (list, optional): A list of other NodeObjects\n            parent (list, optional): The parent NodeObject\n        \"\"\"\n        super().__init__(**kwargs)\n        self.tree: Optional[TreeDiagram] = tree\n        self.tree_children: List[NodeObject] = kwargs.get(\"tree_children\", [])\n        self.tree_parent: Optional[NodeObject] = kwargs.get(\"tree_parent\", None)\n        self.peers: List[NodeObject] = []\n        # self.level = kwargs.get(\"level\", None)\n        # self.peers = kwargs.get(\"peers\", [])\n\n    @property\n    def tree(self) -&gt; TreeDiagram:\n        \"\"\"The TreeDiagram that owns the NodeObject\n\n        Returns:\n            TreeDiagram\n        \"\"\"\n        return self._tree\n\n    @tree.setter\n    def tree(self, value: Optional[TreeDiagram]) -&gt; None:\n        if value is not None:\n            value.add_object(self)\n        self._tree = value\n\n    @property\n    def tree_parent(self) -&gt; Optional[NodeObject]:\n        \"\"\"The parent NodeObject in the tree\n\n        Returns:\n            NodeObject\n        \"\"\"\n        return self._tree_parent\n\n    @tree_parent.setter\n    def tree_parent(self, value: Optional[NodeObject]) -&gt; None:\n        if value is not None:\n            value.tree_children.append(self)\n        self._tree_parent = value\n\n    def add_child(self, obj: NodeObject) -&gt; None:\n        \"\"\"Add a new child to the object\n\n        Args:\n            obj (NodeObject)\n        \"\"\"\n        self.tree_children.append(obj)\n        obj._tree_parent = self\n\n    def add_peer(self, obj: NodeObject) -&gt; None:\n        if obj not in self.peers:\n            self.peers.append(obj)\n        if self not in obj.peers:\n            obj.peers.append(self)\n\n    @property\n    def size_of_level(self) -&gt; Optional[int]:\n        \"\"\"The height or the width of the level, depending on tree orientation.\n\n        Returns:\n            int\n        \"\"\"\n        if self.tree is not None:\n            if self.tree.direction in [\"up\", \"down\"]:\n                return self.geometry.height\n            elif self.tree.direction in [\"left\", \"right\"]:\n                return self.geometry.width\n\n    @property\n    def size_in_level(self) -&gt; Optional[int]:\n        \"\"\"The size of the object within its level, either its width or height depending on tree orientation.\n\n        Returns:\n            int\n        \"\"\"\n        if self.tree is not None:\n            if self.tree.direction in [\"up\", \"down\"]:\n                return self.geometry.width\n            elif self.tree.direction in [\"left\", \"right\"]:\n                return self.geometry.height\n</code></pre>"},{"location":"api/tree_diagram/nodeobject/#src.drawpyo.diagram_types.tree.NodeObject.size_in_level","title":"<code>size_in_level</code>  <code>property</code>","text":"<p>The size of the object within its level, either its width or height depending on tree orientation.</p> <p>Returns:</p> Type Description <code>Optional[int]</code> <p>int</p>"},{"location":"api/tree_diagram/nodeobject/#src.drawpyo.diagram_types.tree.NodeObject.size_of_level","title":"<code>size_of_level</code>  <code>property</code>","text":"<p>The height or the width of the level, depending on tree orientation.</p> <p>Returns:</p> Type Description <code>Optional[int]</code> <p>int</p>"},{"location":"api/tree_diagram/nodeobject/#src.drawpyo.diagram_types.tree.NodeObject.tree","title":"<code>tree</code>  <code>property</code> <code>writable</code>","text":"<p>The TreeDiagram that owns the NodeObject</p> <p>Returns:</p> Type Description <code>TreeDiagram</code> <p>TreeDiagram</p>"},{"location":"api/tree_diagram/nodeobject/#src.drawpyo.diagram_types.tree.NodeObject.tree_parent","title":"<code>tree_parent</code>  <code>property</code> <code>writable</code>","text":"<p>The parent NodeObject in the tree</p> <p>Returns:</p> Type Description <code>Optional[NodeObject]</code> <p>NodeObject</p>"},{"location":"api/tree_diagram/nodeobject/#src.drawpyo.diagram_types.tree.NodeObject.__init__","title":"<code>__init__(tree=None, **kwargs)</code>","text":"<p>The NodeObject should be instantiated with an owning tree object. A NodeObject can only have a single parent but can have any number of children. Args:     tree (TreeDiagram, optional): The owning tree diagram. Defaults to None.</p> <p>Other Parameters:</p> Name Type Description <code>tree_children</code> <code>list</code> <p>A list of other NodeObjects</p> <code>parent</code> <code>list</code> <p>The parent NodeObject</p> Source code in <code>src/drawpyo/diagram_types/tree.py</code> <pre><code>def __init__(self, tree=None, **kwargs) -&gt; None:\n    \"\"\"The NodeObject should be instantiated with an owning tree object. A NodeObject can only have a single parent but can have any number of children.\n    Args:\n        tree (TreeDiagram, optional): The owning tree diagram. Defaults to None.\n\n    Keyword Args:\n        tree_children (list, optional): A list of other NodeObjects\n        parent (list, optional): The parent NodeObject\n    \"\"\"\n    super().__init__(**kwargs)\n    self.tree: Optional[TreeDiagram] = tree\n    self.tree_children: List[NodeObject] = kwargs.get(\"tree_children\", [])\n    self.tree_parent: Optional[NodeObject] = kwargs.get(\"tree_parent\", None)\n    self.peers: List[NodeObject] = []\n</code></pre>"},{"location":"api/tree_diagram/nodeobject/#src.drawpyo.diagram_types.tree.NodeObject.add_child","title":"<code>add_child(obj)</code>","text":"<p>Add a new child to the object</p> Source code in <code>src/drawpyo/diagram_types/tree.py</code> <pre><code>def add_child(self, obj: NodeObject) -&gt; None:\n    \"\"\"Add a new child to the object\n\n    Args:\n        obj (NodeObject)\n    \"\"\"\n    self.tree_children.append(obj)\n    obj._tree_parent = self\n</code></pre>"},{"location":"api/tree_diagram/treediagram/","title":"TreeDiagram","text":""},{"location":"api/tree_diagram/treediagram/#src.drawpyo.diagram_types.tree.TreeDiagram","title":"<code>src.drawpyo.diagram_types.tree.TreeDiagram</code>","text":"<p>The TreeDiagram contains a File object, a Page object, and all the NodeObjects in the tree.</p> Source code in <code>src/drawpyo/diagram_types/tree.py</code> <pre><code>class TreeDiagram:\n    \"\"\"The TreeDiagram contains a File object, a Page object, and all the NodeObjects in the tree.\"\"\"\n\n    def __init__(self, **kwargs) -&gt; None:\n        \"\"\"The TreeDiagram initiates its own File and Page objects. There are a number of formatting parameters that can be set to fine tune the rendering of the tree.\n\n        Keyword Args:\n            direction (str, optional): Direction that the tree grows from the root. Options are 'up', 'down', 'left', and 'right'. Defaults to 'down'.\n            link_style (str, optional): Connection style of the edges. Options are 'orthogonal', 'straight', and 'curved'. Defaults to 'orthogonal'.\n            level_spacing (int, optional): Spacing in pixels between levels. Defaults to 60.\n            item_spacing (int, optional): Spacing in pixels between groups within a level. Defaults to 15.\n            padding (int, optional): Spacing in pixels between objects within a group. Defaults to 10.\n            file_name (str, optional): The name of the tree diagram.\n            file_path (str, optional): The path where the tree diagram should be saved.\n        \"\"\"\n        # formatting\n        self.level_spacing: int = kwargs.get(\"level_spacing\", 60)\n        self.item_spacing: int = kwargs.get(\"item_spacing\", 15)\n        self.group_spacing: int = kwargs.get(\"group_spacing\", 30)\n        self.direction: str = kwargs.get(\"direction\", \"down\")\n        self.link_style: str = kwargs.get(\"link_style\", \"orthogonal\")\n        self.padding: int = kwargs.get(\"padding\", 10)\n\n        # Set up the File and Page objects\n        self.file: File = File()\n        self.file_name: str = kwargs.get(\"file_name\", \"Heirarchical Diagram.drawio\")\n        self.file_path: str = kwargs.get(\"file_path\", r\"C:/\")\n        self.page: Page = Page(file=self.file)\n\n        # Set up object and level lists\n        self.objects: List[NodeObject] = []\n        self.links: List[Edge] = []\n\n    ###########################################################\n    # Properties\n    ###########################################################\n    # These setters and getters keep the file name and file path within the\n    # File object\n    @property\n    def file_name(self) -&gt; str:\n        \"\"\"The file name of the TreeDiagram\n\n        Returns:\n            str\n        \"\"\"\n        return self.file.file_name\n\n    @file_name.setter\n    def file_name(self, fn: str) -&gt; None:\n        self.file.file_name = fn\n\n    @property\n    def file_path(self) -&gt; str:\n        \"\"\"The file path where the TreeDiagram will be saved\n\n        Returns:\n            str\n        \"\"\"\n        return self.file.file_path\n\n    @file_path.setter\n    def file_path(self, fn: str) -&gt; None:\n        self.file.file_path = fn\n\n    # These setters enforce the options for direction and link_style.\n    @property\n    def direction(self) -&gt; str:\n        \"\"\"The direction the tree diagram should grow. Options are \"up\", \"down\", \"left\", or \"right\".\n\n        Returns:\n            str\n        \"\"\"\n        return self._direction\n\n    @direction.setter\n    def direction(self, d: str) -&gt; None:\n        directions = [\"up\", \"down\", \"left\", \"right\"]\n        if d in directions:\n            self._direction = d\n        else:\n            raise ValueError(\n                \"{0} is not a valid entry for direction. Must be {1}.\".format(\n                    d, \", \".join(directions)\n                )\n            )\n\n    ###########################################################\n    # Formatting Properties\n    ###########################################################\n\n    @property\n    def origin(self) -&gt; Tuple[float, float]:\n        \"\"\"The origin points of the TreeDiagram. This is the point where the center of the top level of the TreeDiagram starts from. By default it's set to the top center of an edge of the page. Which edge depends on the direction of the tree diagram.\n\n        Returns:\n            tuple: A tuple of ints\n        \"\"\"\n        origins = {\n            \"up\": (self.page.width / 2, self.page.height - self.padding),\n            \"down\": (self.page.width / 2, self.padding),\n            \"right\": (self.padding, self.page.height / 2),\n            \"left\": (self.page.width - self.padding, self.page.height / 2),\n        }\n        return origins[self.direction]\n\n    def level_move(self, move: int) -&gt; Tuple[int, int]:\n        \"\"\"The functions takes in a relative distance to move within levels. It outputs a tuple with the relative move in the correct direction (horizontal or vertical) depending on the direction of the tree diagram.\n\n        Args:\n            move (int): The amount to move within levels\n\n        Returns:\n            tuple: A tuple containing a 0 and the move, in the right orientation.\n        \"\"\"\n        if self.direction in [\"up\", \"down\"]:\n            return (0, move)\n        elif self.direction in [\"left\", \"right\"]:\n            return (move, 0)\n\n    def move_between_levels(self, start: Tuple[int, int], move: int) -&gt; Tuple[int, int]:\n        \"\"\"The functions takes in a starting position and a relative distance to move between levels. It outputs a tuple with the final absolute position in the correct direction (horizontal or vertical) depending on the direction of the tree diagram.\n\n        Args:\n            start (tuple): The starting position, a tuple of ints\n            move (int): The direction to move between levels.\n\n        Raises:\n            ValueError: \"No direction defined!\"\n\n        Returns:\n            tuple: The final position, a tuple of ints\n        \"\"\"\n        if self.direction == \"up\":\n            return (start[0], start[1] - move)\n        elif self.direction == \"down\":\n            return (start[0], start[1] + move)\n        elif self.direction == \"left\":\n            return (start[0] - move, start[1])\n        elif self.direction == \"right\":\n            return (start[0] + move, start[1])\n        else:\n            raise ValueError(\"No direction defined!\")\n\n    def move_in_level(self, start: Tuple[int, int], move: int) -&gt; Tuple[int, int]:\n        \"\"\"The functions takes in a starting position and a relative distance to move within a level. It outputs a tuple with the final absolute position in the correct direction (horizontal or vertical) depending on the direction of the tree diagram.\n\n        Args:\n            start (tuple): The starting position, a tuple of ints\n            move (int): The direction to move between levels.\n\n        Raises:\n            ValueError: \"No direction defined!\"\n\n        Returns:\n            tuple: The final position, a tuple of ints\n        \"\"\"\n        if self.direction in [\"up\", \"down\"]:\n            return (start[0] + move, start[1])\n        elif self.direction in [\"left\", \"right\"]:\n            return (start[0], start[1] + move)\n        else:\n            raise ValueError(\"No direction defined!\")\n\n    def abs_move_between_levels(\n        self, start: Tuple[int, int], position: Tuple[int, int]\n    ) -&gt; Tuple[int, int]:\n        \"\"\"The functions takes in a starting position and an absolute position along the coordinates between levels. It outputs a tuple with the final absolute position in the correct direction (horizontal or vertical) depending on the direction of the tree diagram.\n\n        Args:\n            start (tuple): The starting position, a tuple of ints\n            position (tuple): The absolute position to move between levels, a tuple of ints\n\n        Raises:\n            ValueError: \"No direction defined!\"\n\n        Returns:\n            tuple: The final position, a tuple of ints\n        \"\"\"\n        if self.direction == \"up\":\n            return (start[0], position)\n        elif self.direction == \"down\":\n            return (start[0], position)\n        elif self.direction == \"left\":\n            return (position, start[1])\n        elif self.direction == \"right\":\n            return (position, start[1])\n        else:\n            raise ValueError(\"No direction defined!\")\n\n    def abs_move_in_level(\n        self, start: Tuple[int, int], position: Tuple[int, int]\n    ) -&gt; Tuple[int, int]:\n        \"\"\"The functions takes in a starting position and an absolute position along the coordinates within a level. It outputs a tuple with the final absolute position in the correct direction (horizontal or vertical) depending on the direction of the tree diagram.\n\n        Args:\n            start (tuple): The starting position, a tuple of ints\n            position (tuple): The absolute position to move within a levels, a tuple of ints\n\n        Raises:\n            ValueError: \"No direction defined!\"\n\n        Returns:\n            tuple: The final position, a tuple of ints\n        \"\"\"\n        if self.direction in [\"up\", \"down\"]:\n            return (position, start[1])\n        elif self.direction in [\"left\", \"right\"]:\n            return (start[0], position)\n        else:\n            raise ValueError(\"No direction defined!\")\n\n    ###########################################################\n    # Style Properties\n    ###########################################################\n\n    @property\n    def link_style(self) -&gt; str:\n        \"\"\"The style of the links in the TreeDiagram\n\n        Returns:\n            str\n        \"\"\"\n        return self._link_style\n\n    @link_style.setter\n    def link_style(self, d: str) -&gt; None:\n        link_styles = [\"orthogonal\", \"straight\", \"curved\"]\n        if d in link_styles:\n            self._link_style = d\n        else:\n            raise ValueError(\n                \"{0} is not a valid entry for link_style. Must be {1}.\".format(\n                    d, \", \".join(link_styles)\n                )\n            )\n\n    @property\n    def link_style_dict(self) -&gt; Dict[str, str]:\n        \"\"\"Returns the correct waypoint style for the set link_style\n\n        Returns:\n            dict: A dict with 'waypoint' as a key then the set link_style\n        \"\"\"\n        if self.link_style == \"orthogonal\":\n            return {\"waypoints\": \"orthogonal\"}\n        elif self.link_style == \"straight\":\n            return {\"waypoints\": \"straight\"}\n        elif self.link_style == \"curved\":\n            return {\"waypoints\": \"curved\"}\n\n    ###########################################################\n    # Object Linking and Sorting\n    ###########################################################\n\n    def add_object(self, obj: NodeObject, **kwargs: Any) -&gt; None:\n        if obj not in self.objects:\n            obj.page = self.page\n            if \"tree_parent\" in kwargs:\n                obj.tree_parent = kwargs.get(\"tree_parent\")\n            self.objects.append(obj)\n\n    ###########################################################\n    # Creating from dict\n    ###########################################################\n\n    @classmethod\n    def from_dict(\n        cls,\n        data: dict,\n        *,\n        colors: list = None,\n        coloring: str = \"depth\",\n        **diagram_kwargs,\n    ) -&gt; \"TreeDiagram\":\n        \"\"\"\n        Build a TreeDiagram from nested dict/list structures.\n        data: Nested dict/list structure representing the tree.\n        colors: List of ColorSchemes, StandardColors, or color hex strings to use for coloring nodes. Default: None\n        coloring: str - \"depth\" | \"hash\" | \"type\" - Method to match colors to nodes. Default: \"depth\"\n            1. \"depth\" - Color nodes based on their depth in the tree.\n            2. \"hash\" - Color nodes based on a hash of their value.\n            3. \"type\" - Color nodes based on their type (category, list_item, leaf).\n        \"\"\"\n\n        diagram = cls(**diagram_kwargs)\n\n        TYPE_INDEX = {\"category\": 0, \"list_item\": 1, \"leaf\": 2}\n\n        if coloring not in (\"depth\", \"hash\", \"type\"):\n            raise ValueError(f\"Invalid coloring mode: {coloring}\")\n\n        if colors is not None and not isinstance(colors, list):\n            raise TypeError(\"colors must be a list or None\")\n        if colors == []:\n            colors = None\n\n        def choose_color(value: str, node_type: str, depth: int):\n            \"\"\"Return a color from the palette based on mode.\"\"\"\n            if not colors:\n                return None\n\n            n = len(colors)\n\n            if coloring == \"depth\":\n                index = depth % n\n            elif coloring == \"hash\":\n                # Stable hash using md5\n                h = int(hashlib.md5(value.encode(\"utf-8\")).hexdigest(), 16)\n                index = h % n\n            elif coloring == \"type\":\n                index = TYPE_INDEX[node_type] % n\n\n            return colors[index]\n\n        def create_node(tree, value, parent, color):\n            \"\"\"Create NodeObject with proper color argument.\"\"\"\n            if color is None:\n                return NodeObject(tree=tree, value=value, tree_parent=parent)\n\n            if isinstance(color, drawpyo.ColorScheme):\n                return NodeObject(\n                    tree=tree, value=value, tree_parent=parent, color_scheme=color\n                )\n            elif isinstance(color, (drawpyo.StandardColor, str)):\n                return NodeObject(\n                    tree=tree, value=value, tree_parent=parent, fillColor=color\n                )\n            else:\n                raise TypeError(f\"Unsupported color type: {type(color)}\")\n\n        def build(parent: Optional[NodeObject], item, depth: int):\n            \"\"\"Recursively build tree nodes.\"\"\"\n\n            # LEAF NODE\n            if isinstance(item, (str, int, float)):\n                value = str(item)\n                color = choose_color(value, \"leaf\", depth)\n                create_node(diagram, value, parent, color)\n                return\n\n            # CATEGORY NODE (dict)\n            if isinstance(item, dict):\n                for key, value in item.items():\n                    if not isinstance(key, (str, int, float)):\n                        raise TypeError(f\"Invalid dict key type: {type(key)}\")\n\n                    key_str = str(key)\n                    color = choose_color(key_str, \"category\", depth)\n                    node = create_node(diagram, key_str, parent, color)\n                    build(node, value, depth + 1)\n                return\n\n            # LIST / TUPLE NODES\n            if isinstance(item, (list, tuple)):\n                for element in item:\n                    # list itself does not create a node, elements are siblings\n                    build(parent, element, depth)\n                return\n\n            raise TypeError(f\"Unsupported type in tree data: {type(item)}\")\n\n        if not isinstance(data, dict):\n            raise TypeError(\"Top-level tree must be a dict\")\n\n        build(None, data, depth=0)\n\n        diagram.auto_layout()\n        return diagram\n\n    ###########################################################\n    # Layout and Output\n    ###########################################################\n\n    @property\n    def roots(self) -&gt; List[NodeObject]:\n        return [x for x in self.objects if x.tree_parent is None]\n\n    def auto_layout(self) -&gt; TreeGroup:\n        def layout_child(tree_parent: Optional[NodeObject]) -&gt; TreeGroup:\n            grp = TreeGroup(tree=self)\n            grp.parent_object = tree_parent\n            # Filter out None children (for BinaryNodeObject compatibility)\n            actual_children = [c for c in tree_parent.tree_children if c is not None]\n            if len(actual_children) &gt; 0:\n                # has children, go through each child and check its children\n                for child in actual_children:\n                    self.connect(tree_parent, child)\n                    child_actual_children = [\n                        c for c in child.tree_children if c is not None\n                    ]\n                    if len(child_actual_children) &gt; 0:\n                        # If this child has its own children then recursive call\n                        grp.add_object(layout_child(child))\n                    else:\n                        grp.add_object(child)\n\n                # layout the row\n                grp = layout_group(grp)\n                # grp = add_parent(grp, parent)\n                grp.center_parent()\n            return grp\n\n        def layout_group(grp: TreeGroup) -&gt; TreeGroup:\n            pos = self.origin\n\n            for obj in grp.objects:\n                if obj is not grp.parent_object:\n                    obj.position = pos\n                    pos = self.move_in_level(pos, obj.size_in_level + self.item_spacing)\n            return grp\n\n        # def add_parent(grp, parent):\n        #     pos = grp.center_position\n        #     level_space = (\n        #         grp.size_of_level / 2\n        #         + self.level_spacing\n        #         + tree_parent.size_of_level / 2\n        #     )\n        #     pos = self.move_between_levels(pos, -level_space)\n        #     parent.center_position = pos\n        #     # add the parent_object\n        #     grp.parent_object = parent\n        #     return grp\n\n        top_group = TreeGroup(tree=self)\n\n        for root in self.roots:\n            top_group.add_object(layout_child(root))\n\n        if len(top_group.objects) &gt; 0:\n            # Position top group\n            top_group = layout_group(top_group)\n            # Center the top group\n            pos = self.origin\n            pos = self.move_between_levels(pos, top_group.size_of_level / 2)\n            top_group.center_position = pos\n\n        # lastly add peer links\n        self.connect_peers()\n\n        return top_group\n\n    def connect_peers(self) -&gt; None:\n        peer_style = {\n            \"endArrow\": \"none\",\n            \"dashed\": 1,\n            \"html\": 1,\n            \"rounded\": 0,\n            \"exitX\": 1,\n            \"exitY\": 0.5,\n            \"exitDx\": 0,\n            \"exitDy\": 0,\n            \"entryX\": 0,\n            \"entryY\": 0.5,\n            \"entryDx\": 0,\n            \"entryDx\": 0,\n            \"edgeStyle\": \"orthogonalEdgeStyle\",\n        }\n        for obj in self.objects:\n            for peer in obj.peers:\n                link_exists = False\n                for link in self.links:\n                    if link.source == obj and link.target == peer:\n                        link_exists = True\n                    elif link.source == peer and link.target == obj:\n                        link_exists = True\n                if not link_exists:\n                    edge = Edge(page=self.page, source=obj, target=peer)\n                    edge.apply_attribute_dict(peer_style)\n                    self.links.append(edge)\n\n    def connect(self, source: NodeObject, target: NodeObject) -&gt; None:\n        edge = Edge(page=self.page, source=source, target=target)\n        edge.apply_attribute_dict(self.link_style_dict)\n        if self.direction == \"down\":\n            # parent style\n            edge.exitX = 0.5\n            edge.exitY = 1\n            # child style\n            edge.entryX = 0.5\n            edge.entryY = 0\n        elif self.direction == \"up\":\n            # parent style\n            edge.exitX = 0.5\n            edge.exitY = 0\n            # child style\n            edge.entryX = 0.5\n            edge.entryY = 1\n        elif self.direction == \"left\":\n            # parent style\n            edge.exitX = 0\n            edge.exitY = 0.5\n            # child style\n            edge.entryX = 1\n            edge.entryY = 0.5\n        elif self.direction == \"right\":\n            # parent style\n            edge.exitX = 1\n            edge.exitY = 0.5\n            # child style\n            edge.entryX = 0\n            edge.entryY = 0.5\n        self.links.append(edge)\n\n    def draw_connections(self) -&gt; None:\n        # Draw connections\n        for lvl in self.objects.values():\n            for obj in lvl:\n                if obj.tree_parent is not None:\n                    self.connect(source=obj.tree_parent, target=obj)\n\n    def write(self, **kwargs) -&gt; None:\n        self.file.write(**kwargs)\n</code></pre>"},{"location":"api/tree_diagram/treediagram/#src.drawpyo.diagram_types.tree.TreeDiagram.direction","title":"<code>direction</code>  <code>property</code> <code>writable</code>","text":"<p>The direction the tree diagram should grow. Options are \"up\", \"down\", \"left\", or \"right\".</p> <p>Returns:</p> Type Description <code>str</code> <p>str</p>"},{"location":"api/tree_diagram/treediagram/#src.drawpyo.diagram_types.tree.TreeDiagram.file_name","title":"<code>file_name</code>  <code>property</code> <code>writable</code>","text":"<p>The file name of the TreeDiagram</p> <p>Returns:</p> Type Description <code>str</code> <p>str</p>"},{"location":"api/tree_diagram/treediagram/#src.drawpyo.diagram_types.tree.TreeDiagram.file_path","title":"<code>file_path</code>  <code>property</code> <code>writable</code>","text":"<p>The file path where the TreeDiagram will be saved</p> <p>Returns:</p> Type Description <code>str</code> <p>str</p>"},{"location":"api/tree_diagram/treediagram/#src.drawpyo.diagram_types.tree.TreeDiagram.link_style","title":"<code>link_style</code>  <code>property</code> <code>writable</code>","text":"<p>The style of the links in the TreeDiagram</p> <p>Returns:</p> Type Description <code>str</code> <p>str</p>"},{"location":"api/tree_diagram/treediagram/#src.drawpyo.diagram_types.tree.TreeDiagram.link_style_dict","title":"<code>link_style_dict</code>  <code>property</code>","text":"<p>Returns the correct waypoint style for the set link_style</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>Dict[str, str]</code> <p>A dict with 'waypoint' as a key then the set link_style</p>"},{"location":"api/tree_diagram/treediagram/#src.drawpyo.diagram_types.tree.TreeDiagram.origin","title":"<code>origin</code>  <code>property</code>","text":"<p>The origin points of the TreeDiagram. This is the point where the center of the top level of the TreeDiagram starts from. By default it's set to the top center of an edge of the page. Which edge depends on the direction of the tree diagram.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[float, float]</code> <p>A tuple of ints</p>"},{"location":"api/tree_diagram/treediagram/#src.drawpyo.diagram_types.tree.TreeDiagram.__init__","title":"<code>__init__(**kwargs)</code>","text":"<p>The TreeDiagram initiates its own File and Page objects. There are a number of formatting parameters that can be set to fine tune the rendering of the tree.</p> <p>Other Parameters:</p> Name Type Description <code>direction</code> <code>str</code> <p>Direction that the tree grows from the root. Options are 'up', 'down', 'left', and 'right'. Defaults to 'down'.</p> <code>link_style</code> <code>str</code> <p>Connection style of the edges. Options are 'orthogonal', 'straight', and 'curved'. Defaults to 'orthogonal'.</p> <code>level_spacing</code> <code>int</code> <p>Spacing in pixels between levels. Defaults to 60.</p> <code>item_spacing</code> <code>int</code> <p>Spacing in pixels between groups within a level. Defaults to 15.</p> <code>padding</code> <code>int</code> <p>Spacing in pixels between objects within a group. Defaults to 10.</p> <code>file_name</code> <code>str</code> <p>The name of the tree diagram.</p> <code>file_path</code> <code>str</code> <p>The path where the tree diagram should be saved.</p> Source code in <code>src/drawpyo/diagram_types/tree.py</code> <pre><code>def __init__(self, **kwargs) -&gt; None:\n    \"\"\"The TreeDiagram initiates its own File and Page objects. There are a number of formatting parameters that can be set to fine tune the rendering of the tree.\n\n    Keyword Args:\n        direction (str, optional): Direction that the tree grows from the root. Options are 'up', 'down', 'left', and 'right'. Defaults to 'down'.\n        link_style (str, optional): Connection style of the edges. Options are 'orthogonal', 'straight', and 'curved'. Defaults to 'orthogonal'.\n        level_spacing (int, optional): Spacing in pixels between levels. Defaults to 60.\n        item_spacing (int, optional): Spacing in pixels between groups within a level. Defaults to 15.\n        padding (int, optional): Spacing in pixels between objects within a group. Defaults to 10.\n        file_name (str, optional): The name of the tree diagram.\n        file_path (str, optional): The path where the tree diagram should be saved.\n    \"\"\"\n    # formatting\n    self.level_spacing: int = kwargs.get(\"level_spacing\", 60)\n    self.item_spacing: int = kwargs.get(\"item_spacing\", 15)\n    self.group_spacing: int = kwargs.get(\"group_spacing\", 30)\n    self.direction: str = kwargs.get(\"direction\", \"down\")\n    self.link_style: str = kwargs.get(\"link_style\", \"orthogonal\")\n    self.padding: int = kwargs.get(\"padding\", 10)\n\n    # Set up the File and Page objects\n    self.file: File = File()\n    self.file_name: str = kwargs.get(\"file_name\", \"Heirarchical Diagram.drawio\")\n    self.file_path: str = kwargs.get(\"file_path\", r\"C:/\")\n    self.page: Page = Page(file=self.file)\n\n    # Set up object and level lists\n    self.objects: List[NodeObject] = []\n    self.links: List[Edge] = []\n</code></pre>"},{"location":"api/tree_diagram/treediagram/#src.drawpyo.diagram_types.tree.TreeDiagram.abs_move_between_levels","title":"<code>abs_move_between_levels(start, position)</code>","text":"<p>The functions takes in a starting position and an absolute position along the coordinates between levels. It outputs a tuple with the final absolute position in the correct direction (horizontal or vertical) depending on the direction of the tree diagram.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>tuple</code> <p>The starting position, a tuple of ints</p> required <code>position</code> <code>tuple</code> <p>The absolute position to move between levels, a tuple of ints</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>\"No direction defined!\"</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, int]</code> <p>The final position, a tuple of ints</p> Source code in <code>src/drawpyo/diagram_types/tree.py</code> <pre><code>def abs_move_between_levels(\n    self, start: Tuple[int, int], position: Tuple[int, int]\n) -&gt; Tuple[int, int]:\n    \"\"\"The functions takes in a starting position and an absolute position along the coordinates between levels. It outputs a tuple with the final absolute position in the correct direction (horizontal or vertical) depending on the direction of the tree diagram.\n\n    Args:\n        start (tuple): The starting position, a tuple of ints\n        position (tuple): The absolute position to move between levels, a tuple of ints\n\n    Raises:\n        ValueError: \"No direction defined!\"\n\n    Returns:\n        tuple: The final position, a tuple of ints\n    \"\"\"\n    if self.direction == \"up\":\n        return (start[0], position)\n    elif self.direction == \"down\":\n        return (start[0], position)\n    elif self.direction == \"left\":\n        return (position, start[1])\n    elif self.direction == \"right\":\n        return (position, start[1])\n    else:\n        raise ValueError(\"No direction defined!\")\n</code></pre>"},{"location":"api/tree_diagram/treediagram/#src.drawpyo.diagram_types.tree.TreeDiagram.abs_move_in_level","title":"<code>abs_move_in_level(start, position)</code>","text":"<p>The functions takes in a starting position and an absolute position along the coordinates within a level. It outputs a tuple with the final absolute position in the correct direction (horizontal or vertical) depending on the direction of the tree diagram.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>tuple</code> <p>The starting position, a tuple of ints</p> required <code>position</code> <code>tuple</code> <p>The absolute position to move within a levels, a tuple of ints</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>\"No direction defined!\"</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, int]</code> <p>The final position, a tuple of ints</p> Source code in <code>src/drawpyo/diagram_types/tree.py</code> <pre><code>def abs_move_in_level(\n    self, start: Tuple[int, int], position: Tuple[int, int]\n) -&gt; Tuple[int, int]:\n    \"\"\"The functions takes in a starting position and an absolute position along the coordinates within a level. It outputs a tuple with the final absolute position in the correct direction (horizontal or vertical) depending on the direction of the tree diagram.\n\n    Args:\n        start (tuple): The starting position, a tuple of ints\n        position (tuple): The absolute position to move within a levels, a tuple of ints\n\n    Raises:\n        ValueError: \"No direction defined!\"\n\n    Returns:\n        tuple: The final position, a tuple of ints\n    \"\"\"\n    if self.direction in [\"up\", \"down\"]:\n        return (position, start[1])\n    elif self.direction in [\"left\", \"right\"]:\n        return (start[0], position)\n    else:\n        raise ValueError(\"No direction defined!\")\n</code></pre>"},{"location":"api/tree_diagram/treediagram/#src.drawpyo.diagram_types.tree.TreeDiagram.from_dict","title":"<code>from_dict(data, *, colors=None, coloring='depth', **diagram_kwargs)</code>  <code>classmethod</code>","text":"<p>Build a TreeDiagram from nested dict/list structures. data: Nested dict/list structure representing the tree. colors: List of ColorSchemes, StandardColors, or color hex strings to use for coloring nodes. Default: None coloring: str - \"depth\" | \"hash\" | \"type\" - Method to match colors to nodes. Default: \"depth\"     1. \"depth\" - Color nodes based on their depth in the tree.     2. \"hash\" - Color nodes based on a hash of their value.     3. \"type\" - Color nodes based on their type (category, list_item, leaf).</p> Source code in <code>src/drawpyo/diagram_types/tree.py</code> <pre><code>@classmethod\ndef from_dict(\n    cls,\n    data: dict,\n    *,\n    colors: list = None,\n    coloring: str = \"depth\",\n    **diagram_kwargs,\n) -&gt; \"TreeDiagram\":\n    \"\"\"\n    Build a TreeDiagram from nested dict/list structures.\n    data: Nested dict/list structure representing the tree.\n    colors: List of ColorSchemes, StandardColors, or color hex strings to use for coloring nodes. Default: None\n    coloring: str - \"depth\" | \"hash\" | \"type\" - Method to match colors to nodes. Default: \"depth\"\n        1. \"depth\" - Color nodes based on their depth in the tree.\n        2. \"hash\" - Color nodes based on a hash of their value.\n        3. \"type\" - Color nodes based on their type (category, list_item, leaf).\n    \"\"\"\n\n    diagram = cls(**diagram_kwargs)\n\n    TYPE_INDEX = {\"category\": 0, \"list_item\": 1, \"leaf\": 2}\n\n    if coloring not in (\"depth\", \"hash\", \"type\"):\n        raise ValueError(f\"Invalid coloring mode: {coloring}\")\n\n    if colors is not None and not isinstance(colors, list):\n        raise TypeError(\"colors must be a list or None\")\n    if colors == []:\n        colors = None\n\n    def choose_color(value: str, node_type: str, depth: int):\n        \"\"\"Return a color from the palette based on mode.\"\"\"\n        if not colors:\n            return None\n\n        n = len(colors)\n\n        if coloring == \"depth\":\n            index = depth % n\n        elif coloring == \"hash\":\n            # Stable hash using md5\n            h = int(hashlib.md5(value.encode(\"utf-8\")).hexdigest(), 16)\n            index = h % n\n        elif coloring == \"type\":\n            index = TYPE_INDEX[node_type] % n\n\n        return colors[index]\n\n    def create_node(tree, value, parent, color):\n        \"\"\"Create NodeObject with proper color argument.\"\"\"\n        if color is None:\n            return NodeObject(tree=tree, value=value, tree_parent=parent)\n\n        if isinstance(color, drawpyo.ColorScheme):\n            return NodeObject(\n                tree=tree, value=value, tree_parent=parent, color_scheme=color\n            )\n        elif isinstance(color, (drawpyo.StandardColor, str)):\n            return NodeObject(\n                tree=tree, value=value, tree_parent=parent, fillColor=color\n            )\n        else:\n            raise TypeError(f\"Unsupported color type: {type(color)}\")\n\n    def build(parent: Optional[NodeObject], item, depth: int):\n        \"\"\"Recursively build tree nodes.\"\"\"\n\n        # LEAF NODE\n        if isinstance(item, (str, int, float)):\n            value = str(item)\n            color = choose_color(value, \"leaf\", depth)\n            create_node(diagram, value, parent, color)\n            return\n\n        # CATEGORY NODE (dict)\n        if isinstance(item, dict):\n            for key, value in item.items():\n                if not isinstance(key, (str, int, float)):\n                    raise TypeError(f\"Invalid dict key type: {type(key)}\")\n\n                key_str = str(key)\n                color = choose_color(key_str, \"category\", depth)\n                node = create_node(diagram, key_str, parent, color)\n                build(node, value, depth + 1)\n            return\n\n        # LIST / TUPLE NODES\n        if isinstance(item, (list, tuple)):\n            for element in item:\n                # list itself does not create a node, elements are siblings\n                build(parent, element, depth)\n            return\n\n        raise TypeError(f\"Unsupported type in tree data: {type(item)}\")\n\n    if not isinstance(data, dict):\n        raise TypeError(\"Top-level tree must be a dict\")\n\n    build(None, data, depth=0)\n\n    diagram.auto_layout()\n    return diagram\n</code></pre>"},{"location":"api/tree_diagram/treediagram/#src.drawpyo.diagram_types.tree.TreeDiagram.level_move","title":"<code>level_move(move)</code>","text":"<p>The functions takes in a relative distance to move within levels. It outputs a tuple with the relative move in the correct direction (horizontal or vertical) depending on the direction of the tree diagram.</p> <p>Parameters:</p> Name Type Description Default <code>move</code> <code>int</code> <p>The amount to move within levels</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, int]</code> <p>A tuple containing a 0 and the move, in the right orientation.</p> Source code in <code>src/drawpyo/diagram_types/tree.py</code> <pre><code>def level_move(self, move: int) -&gt; Tuple[int, int]:\n    \"\"\"The functions takes in a relative distance to move within levels. It outputs a tuple with the relative move in the correct direction (horizontal or vertical) depending on the direction of the tree diagram.\n\n    Args:\n        move (int): The amount to move within levels\n\n    Returns:\n        tuple: A tuple containing a 0 and the move, in the right orientation.\n    \"\"\"\n    if self.direction in [\"up\", \"down\"]:\n        return (0, move)\n    elif self.direction in [\"left\", \"right\"]:\n        return (move, 0)\n</code></pre>"},{"location":"api/tree_diagram/treediagram/#src.drawpyo.diagram_types.tree.TreeDiagram.move_between_levels","title":"<code>move_between_levels(start, move)</code>","text":"<p>The functions takes in a starting position and a relative distance to move between levels. It outputs a tuple with the final absolute position in the correct direction (horizontal or vertical) depending on the direction of the tree diagram.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>tuple</code> <p>The starting position, a tuple of ints</p> required <code>move</code> <code>int</code> <p>The direction to move between levels.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>\"No direction defined!\"</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, int]</code> <p>The final position, a tuple of ints</p> Source code in <code>src/drawpyo/diagram_types/tree.py</code> <pre><code>def move_between_levels(self, start: Tuple[int, int], move: int) -&gt; Tuple[int, int]:\n    \"\"\"The functions takes in a starting position and a relative distance to move between levels. It outputs a tuple with the final absolute position in the correct direction (horizontal or vertical) depending on the direction of the tree diagram.\n\n    Args:\n        start (tuple): The starting position, a tuple of ints\n        move (int): The direction to move between levels.\n\n    Raises:\n        ValueError: \"No direction defined!\"\n\n    Returns:\n        tuple: The final position, a tuple of ints\n    \"\"\"\n    if self.direction == \"up\":\n        return (start[0], start[1] - move)\n    elif self.direction == \"down\":\n        return (start[0], start[1] + move)\n    elif self.direction == \"left\":\n        return (start[0] - move, start[1])\n    elif self.direction == \"right\":\n        return (start[0] + move, start[1])\n    else:\n        raise ValueError(\"No direction defined!\")\n</code></pre>"},{"location":"api/tree_diagram/treediagram/#src.drawpyo.diagram_types.tree.TreeDiagram.move_in_level","title":"<code>move_in_level(start, move)</code>","text":"<p>The functions takes in a starting position and a relative distance to move within a level. It outputs a tuple with the final absolute position in the correct direction (horizontal or vertical) depending on the direction of the tree diagram.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>tuple</code> <p>The starting position, a tuple of ints</p> required <code>move</code> <code>int</code> <p>The direction to move between levels.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>\"No direction defined!\"</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, int]</code> <p>The final position, a tuple of ints</p> Source code in <code>src/drawpyo/diagram_types/tree.py</code> <pre><code>def move_in_level(self, start: Tuple[int, int], move: int) -&gt; Tuple[int, int]:\n    \"\"\"The functions takes in a starting position and a relative distance to move within a level. It outputs a tuple with the final absolute position in the correct direction (horizontal or vertical) depending on the direction of the tree diagram.\n\n    Args:\n        start (tuple): The starting position, a tuple of ints\n        move (int): The direction to move between levels.\n\n    Raises:\n        ValueError: \"No direction defined!\"\n\n    Returns:\n        tuple: The final position, a tuple of ints\n    \"\"\"\n    if self.direction in [\"up\", \"down\"]:\n        return (start[0] + move, start[1])\n    elif self.direction in [\"left\", \"right\"]:\n        return (start[0], start[1] + move)\n    else:\n        raise ValueError(\"No direction defined!\")\n</code></pre>"},{"location":"api/tree_diagram/treediagram/#treegroup","title":"TreeGroup","text":""},{"location":"api/tree_diagram/treediagram/#src.drawpyo.diagram_types.tree.TreeGroup","title":"<code>src.drawpyo.diagram_types.tree.TreeGroup</code>","text":"<p>               Bases: <code>Group</code></p> <p>This class defines a group within a TreeDiagram. When a set of NodeObjects share the same parent they're grouped together for auto positioning. Each level of a TreeDiagram is a set of groups.</p> Source code in <code>src/drawpyo/diagram_types/tree.py</code> <pre><code>class TreeGroup(Group):\n    \"\"\"This class defines a group within a TreeDiagram. When a set of NodeObjects share the same parent they're grouped together for auto positioning. Each level of a TreeDiagram is a set of groups.\"\"\"\n\n    def __init__(self, tree=None, parent_object=None, **kwargs) -&gt; None:\n        \"\"\"The TreeGroup is instantiated with all the arguments of the Group. Additionally, the owning tree and the parent_object.\n\n        Args:\n            tree (TreeDiagram, optional): The TreeDiagram that owns the group. Defaults to None.\n            parent_object (NodeObject, optional): The parent object in the group. Defaults to None.\n        \"\"\"\n        super().__init__(**kwargs)\n        self.tree: Optional[TreeDiagram] = tree\n        self.parent_object: Optional[NodeObject] = parent_object\n\n    @property\n    def parent_object(self) -&gt; Optional[NodeObject]:\n        \"\"\"The object that defines the parent of the group.\n\n        Returns:\n            NodeObject\n        \"\"\"\n        return self._parent_object\n\n    @parent_object.setter\n    def parent_object(self, value: Optional[NodeObject]) -&gt; None:\n        if value is not None:\n            self.add_object(value)\n        self._parent_object = value\n\n    def center_parent(self) -&gt; None:\n        \"\"\"This function centers the parent_objects along the group and then offsets it by the level spacing.\"\"\"\n        children_grp = TreeGroup(tree=self.tree)\n        for obj in self.objects:\n            if obj is not self.parent_object:\n                children_grp.add_object(obj)\n        pos = children_grp.center_position\n\n        level_space = (\n            children_grp.size_of_level / 2\n            + self.tree.level_spacing\n            + self.parent_object.size_of_level / 2\n        )\n        pos = self.tree.move_between_levels(pos, -level_space)\n        self.parent_object.center_position = pos\n\n    # I don't love that these are copy-pasted from NodeObject but the multiple\n    # inheritance was too much of a pain to have TreeGroup inherit.\n    @property\n    def size_of_level(self) -&gt; Optional[int]:\n        \"\"\"The height or the width of the level, depending on tree orientation.\n\n        Returns:\n            int\n        \"\"\"\n        if self.tree is not None:\n            if self.tree.direction in [\"up\", \"down\"]:\n                return self.height\n            elif self.tree.direction in [\"left\", \"right\"]:\n                return self.width\n\n    @property\n    def size_in_level(self) -&gt; Optional[int]:\n        \"\"\"The size of the object within its level, either its width or height depending on tree orientation.\n\n        Returns:\n            int\n        \"\"\"\n        if self.tree is not None:\n            if self.tree.direction in [\"up\", \"down\"]:\n                return self.width\n            elif self.tree.direction in [\"left\", \"right\"]:\n                return self.height\n</code></pre>"},{"location":"api/tree_diagram/treediagram/#src.drawpyo.diagram_types.tree.TreeGroup.parent_object","title":"<code>parent_object</code>  <code>property</code> <code>writable</code>","text":"<p>The object that defines the parent of the group.</p> <p>Returns:</p> Type Description <code>Optional[NodeObject]</code> <p>NodeObject</p>"},{"location":"api/tree_diagram/treediagram/#src.drawpyo.diagram_types.tree.TreeGroup.size_in_level","title":"<code>size_in_level</code>  <code>property</code>","text":"<p>The size of the object within its level, either its width or height depending on tree orientation.</p> <p>Returns:</p> Type Description <code>Optional[int]</code> <p>int</p>"},{"location":"api/tree_diagram/treediagram/#src.drawpyo.diagram_types.tree.TreeGroup.size_of_level","title":"<code>size_of_level</code>  <code>property</code>","text":"<p>The height or the width of the level, depending on tree orientation.</p> <p>Returns:</p> Type Description <code>Optional[int]</code> <p>int</p>"},{"location":"api/tree_diagram/treediagram/#src.drawpyo.diagram_types.tree.TreeGroup.__init__","title":"<code>__init__(tree=None, parent_object=None, **kwargs)</code>","text":"<p>The TreeGroup is instantiated with all the arguments of the Group. Additionally, the owning tree and the parent_object.</p> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>TreeDiagram</code> <p>The TreeDiagram that owns the group. Defaults to None.</p> <code>None</code> <code>parent_object</code> <code>NodeObject</code> <p>The parent object in the group. Defaults to None.</p> <code>None</code> Source code in <code>src/drawpyo/diagram_types/tree.py</code> <pre><code>def __init__(self, tree=None, parent_object=None, **kwargs) -&gt; None:\n    \"\"\"The TreeGroup is instantiated with all the arguments of the Group. Additionally, the owning tree and the parent_object.\n\n    Args:\n        tree (TreeDiagram, optional): The TreeDiagram that owns the group. Defaults to None.\n        parent_object (NodeObject, optional): The parent object in the group. Defaults to None.\n    \"\"\"\n    super().__init__(**kwargs)\n    self.tree: Optional[TreeDiagram] = tree\n    self.parent_object: Optional[NodeObject] = parent_object\n</code></pre>"},{"location":"api/tree_diagram/treediagram/#src.drawpyo.diagram_types.tree.TreeGroup.center_parent","title":"<code>center_parent()</code>","text":"<p>This function centers the parent_objects along the group and then offsets it by the level spacing.</p> Source code in <code>src/drawpyo/diagram_types/tree.py</code> <pre><code>def center_parent(self) -&gt; None:\n    \"\"\"This function centers the parent_objects along the group and then offsets it by the level spacing.\"\"\"\n    children_grp = TreeGroup(tree=self.tree)\n    for obj in self.objects:\n        if obj is not self.parent_object:\n            children_grp.add_object(obj)\n    pos = children_grp.center_position\n\n    level_space = (\n        children_grp.size_of_level / 2\n        + self.tree.level_spacing\n        + self.parent_object.size_of_level / 2\n    )\n    pos = self.tree.move_between_levels(pos, -level_space)\n    self.parent_object.center_position = pos\n</code></pre>"},{"location":"diagram_types/bar_charts/","title":"Bar Charts","text":"<p>A bar chart is a visual graph that uses rectangular bars to compare the size of different categories. The <code>BarChart</code> module allows you to generate visualizations from dictionaries mapping strings to numerical values.</p>"},{"location":"diagram_types/bar_charts/#create-a-simple-bar-chart","title":"Create a simple Bar Chart","text":"<p>Let's first prepare the data and label formatting before initializing a simple chart using it.</p> <pre><code># Define the chart title\nchart_title = \"Coffee Grinder Prices\"\n\n# Define the chart data\ncoffee_grinder_prices = {\n    \"Manual\": 29,\n    \"Blade\": 45,\n    \"Burr\":  120,\n}\n\n# Custom formatters can override default label values\ndef custom_label_formatter(_category: str, value: int) -&gt; str:\n    return f\"{value} $\"\n\n# Create the chart object\nchart = BarChart(\n    coffee_grinder_prices,\n    title=chart_title,\n    inside_label_formatter=custom_label_formatter,\n)\n</code></pre> <p>There are a number of configuration parameters available to fine-tune the layout and appearance of the <code>BarChart</code>, which can be passed as keyword arguments.</p> Parameter Effect Default <code>position</code> Top-left chart origin as <code>(x, y)</code> <code>(0, 0)</code> <code>show_axis</code> Toggles axis and tick display <code>False</code> <code>bar_width</code> Width of each bar <code>40</code> <code>bar_spacing</code> Horizontal spacing between bars <code>20</code> <code>max_bar_height</code> Height of the tallest bar <code>200</code> <code>bar_colors</code> List of colors or ColorSchemes applied to bars <code>[\"#66ccff\"]</code> <code>title</code> Optional chart title <code>None</code> <code>title_text_format</code> Text formatting for the title <code>TextFormat()</code> <code>base_text_format</code> Formatting for labels below bars <code>TextFormat()</code> <code>inside_text_format</code> Formatting for labels rendered inside bars <code>TextFormat()</code> <code>background_color</code> Optional background rectangle behind the chart <code>None</code> <code>axis_tick_count</code> Number of tick intervals on the chart axis <code>5</code> <code>axis_text_format</code> Formatting for axis tick labels <code>TextFormat()</code> <code>base_label_formatter</code> Callable that formats the category label below each bar <code>lambda l,v: l</code> <code>inside_label_formatter</code> Callable that formats values printed inside each bar <code>lambda l,v: str(v)</code> <code>glass</code> Whether bars have a glass effect. <code>False</code> <code>rounded</code> Whether bars have rounded corners. <code>False</code> <p>With a few visual adjustments, the resulting chart renders as:</p> <p></p>"},{"location":"diagram_types/binary_tree_diagrams/","title":"Binary Tree Diagrams","text":"<p>Binary trees are one of the most common hierarchical structures, and this module provides a specialized pair of classes \u2014 BinaryNodeObject and BinaryTreeDiagram \u2014 designed to make creating, linking, and laying out binary trees convenient and safe.</p> <p>BinaryNodeObject enforces the strict \"at most two children\" rule and exposes intuitive <code>left</code> and <code>right</code> properties. BinaryTreeDiagram extends TreeDiagram with binary-friendly defaults and helper methods.</p>"},{"location":"diagram_types/binary_tree_diagrams/#create-a-binary-tree","title":"Create a Binary Tree","text":"<p>To get started, import the binary tree types and create a <code>BinaryTreeDiagram</code>:</p> <pre><code>from drawpyo.diagram_types import BinaryTreeDiagram\n\ntree = BinaryTreeDiagram(\n    file_path=\"path/to/diagram\",\n    file_name=\"Binary Tree.drawio\",\n)\n</code></pre> <p>There are a number of configuration parameters available to fine tune the layout of the BinaryTreeDiagram:</p> Parameter Effect Default level_spacing Vertical spacing between levels 80 item_spacing Horizontal spacing between sibling groups 20 group_spacing Spacing between unrelated groups 30 link_style Edge connection style \"straight\" padding Spacing between objects within a group 10"},{"location":"diagram_types/binary_tree_diagrams/#add-nodes","title":"Add Nodes","text":"<p>Binary trees use BinaryNodeObject, a subclass of NodeObject that provides two dedicated child slots: <code>left</code> and <code>right</code>.</p> <pre><code>from drawpyo.diagram_types import BinaryNodeObject\n\nroot = BinaryNodeObject(tree=tree, value=\"Root\")\nleft = BinaryNodeObject(tree=tree, value=\"Left Branch\")\nright = BinaryNodeObject(tree=tree, value=\"Right Branch\")\n</code></pre>"},{"location":"diagram_types/binary_tree_diagrams/#using-the-left-and-right-setters","title":"Using the <code>left</code> and <code>right</code> setters","text":"<p>Every BinaryNodeObject has:</p> <ul> <li>exactly two child slots, always present</li> <li>direct accessors: <code>node.left</code> and <code>node.right</code></li> </ul> <p>Assign children:</p> <pre><code>root.left = left\nroot.right = right\n</code></pre> <p>Changing a child's side automatically fixes its parent relationship:</p> <pre><code>root.left = right     # reassigns and detaches from old parent\n</code></pre> <p>Setting a side to <code>None</code> removes the child:</p> <pre><code>root.right = None\n</code></pre>"},{"location":"diagram_types/binary_tree_diagrams/#using-binarytreediagram-convenience-methods","title":"Using BinaryTreeDiagram convenience methods","text":"<p>BinaryTreeDiagram provides small helpers to ensure consistency and type safety:</p> <pre><code>tree.add_left(root, left)\ntree.add_right(root, right)\n</code></pre> <p>Both methods:</p> <ul> <li>ensure parent and child are BinaryNodeObjects</li> <li>automatically register both under the same <code>BinaryTreeDiagram</code></li> </ul>"},{"location":"diagram_types/binary_tree_diagrams/#rules-and-guarantees","title":"Rules and Guarantees","text":"<p>BinaryNodeObject enforces strict binary-tree behavior.</p>"},{"location":"diagram_types/binary_tree_diagrams/#child-slot-normalization","title":"Child Slot Normalization","text":"<p>Nodes always maintain exactly two slots:</p> <pre><code>[left, right]\n</code></pre> <p>If you supply fewer than two children on creation:</p> <pre><code>node = BinaryNodeObject(tree_children=[child])\n</code></pre> <p>\u2026it becomes:</p> <pre><code>[child, None]\n</code></pre> <p>If you supply more than two:</p> <pre><code>BinaryNodeObject(tree_children=[a, b, c])\n</code></pre> <p>\u2192 Raises <code>ValueError</code>.</p>"},{"location":"diagram_types/binary_tree_diagrams/#moving-nodes-between-parents","title":"Moving Nodes Between Parents","text":"<p>Assigning a node as a child:</p> <ul> <li>detaches it from any existing parent</li> <li>prevents a node from occupying both sides at once</li> <li>prevents more than two unique children</li> </ul>"},{"location":"diagram_types/binary_tree_diagrams/#parent-safety","title":"Parent Safety","text":"<p>BinaryTreeDiagram forbids attaching non-binary nodes:</p> <pre><code>tree.add_left(parent, not_a_binary_node)\n</code></pre> <p>\u2192 Raises <code>TypeError</code>.</p>"},{"location":"diagram_types/binary_tree_diagrams/#full-example","title":"Full Example","text":"<pre><code>from drawpyo.diagram_types import BinaryTreeDiagram, BinaryNodeObject\n\n# Create the diagram\ntree = BinaryTreeDiagram(\n    file_path=\"~/Binary Trees\",\n    file_name=\"SimpleBinary.drawio\"\n)\n\n# Root\nroot = BinaryNodeObject(tree=tree, value=\"Root Node\")\n\n# Children\na = BinaryNodeObject(tree=tree, value=\"Left Child\")\nb = BinaryNodeObject(tree=tree, value=\"Right Child\")\n\n# Attach via setters\nroot.left = a\nroot.right = b\n\n# Further branching\na.left  = BinaryNodeObject(tree=tree, value=\"A1\")\na.right = BinaryNodeObject(tree=tree, value=\"A2\")\nb.left  = BinaryNodeObject(tree=tree, value=\"B1\")\n\ntree.auto_layout()\ntree.write()\n</code></pre>"},{"location":"diagram_types/legends/","title":"Legendy","text":"<p>A legend displays a color-to-label mapping, typically used to explain color coding in diagrams. The <code>Legend</code> class renders a vertical list of colored boxes with corresponding text labels.</p>"},{"location":"diagram_types/legends/#create-a-simple-legend","title":"Create a simple Legend","text":"<p>Define your color mapping and initialize the legend:</p> <pre><code># Define the legend mapping\nstatus_colors = {\n    \"Active\": \"#4CAF50\",\n    \"Pending\": \"#FFC107\",\n    \"Inactive\": \"#9E9E9E\",\n}\n\n# Create the legend\nlegend = Legend(\n    status_colors,\n    title=\"Status\",\n    position=(50, 50),\n)\n</code></pre> <p>The <code>Legend</code> constructor accepts keyword arguments to customize appearance and layout:</p> Parameter Effect Default <code>position</code> Top-left position as <code>(x, y)</code> <code>(0, 0)</code> <code>title</code> Optional title above the legend <code>None</code> <code>title_text_format</code> Formatting for the title <code>TextFormat()</code> <code>label_text_format</code> Formatting for labels <code>TextFormat()</code> <code>glass</code> Apply glass effect to color boxes <code>False</code> <code>rounded</code> Apply rounded corners to color boxes <code>False</code> <code>background_color</code> Optional background fill color <code>None</code>"},{"location":"diagram_types/legends/#color-values","title":"Color Values","text":"<p>Colors can be strings (hex codes), <code>StandardColor</code> enums, or <code>ColorScheme</code> objects.</p>"},{"location":"diagram_types/legends/#methods","title":"Methods","text":"<p><code>update_mapping(mapping)</code> \u2014 Replace the legend's color mapping and rebuild.</p> <p><code>move(new_position)</code> \u2014 Reposition the entire legend to <code>(x, y)</code>.</p> <p><code>add_to_page(page)</code> \u2014 Add all legend objects to a <code>Page</code>.</p>"},{"location":"diagram_types/legends/#example-with-styling","title":"Example with Styling","text":"<pre><code>legend = Legend(\n    status_colors,\n    position=(400, 100),\n    title=\"Order Status\",\n    title_text_format=title_format,\n    label_text_format=label_format,\n    glass=True,\n    rounded=True,\n    background_color=\"#F5F5F5\",\n)\n\nlegend.add_to_page(page)\n</code></pre> <p>The legend automatically sizes itself based on label lengths and applies consistent spacing between rows.</p> <p></p>"},{"location":"diagram_types/pie_charts/","title":"Pie Charts","text":"<p>A pie chart is a circular visualization that divides a whole into proportional slices. The <code>PieChart</code> module provides a configurable way to render labeled pie slices from a dictionary mapping strings to numerical values.</p>"},{"location":"diagram_types/pie_charts/#create-a-simple-pie-chart","title":"Create a simple Pie Chart","text":"<p>Start by preparing the data and any optional formatting before initializing a chart.</p> <pre><code># Define the chart title\nchart_title = \"Coffee Orders\"\n\n# Define the pie chart data\ncoffee_orders = {\n    \"Americano\": 64,\n    \"Espresso\": 21,\n    \"Latte\": 15,\n}\n\n# Custom formatter to override slice labels\ndef label_formatter(category: str, value: float, total: float) -&gt; str:\n    return f\"{category}: {value/total*100:.1f}%\"\n\n# Create the chart object\nchart = PieChart(\n    coffee_orders,\n    title=chart_title,\n    size=250,\n    label_formatter=label_formatter,\n)\n</code></pre> <p>Just like with the Bar Chart module, the <code>PieChart</code> constructor accepts a variety of keyword arguments to adjust appearance, layout, and textual formatting.</p> Parameter Effect Default <code>position</code> Top-left position where the chart is placed as <code>(x, y)</code> <code>(0, 0)</code> <code>size</code> Diameter of the pie <code>200</code> <code>slice_colors</code> List of colors or ColorSchemes for slice fills <code>[\"#66ccff\"]</code> <code>title</code> Optional chart title <code>None</code> <code>title_text_format</code> Formatting for the title (alignment, font, size, etc.) <code>TextFormat()</code> <code>label_text_format</code> Formatting applied to slice labels <code>TextFormat()</code> <code>background_color</code> Optional background rectangle behind the pie <code>None</code> <code>label_formatter</code> Callable formatting each slice\u2019s label as <code>(label, value, total)</code> <code>default_label_formatter</code>"},{"location":"diagram_types/pie_charts/#label-formatting","title":"Label Formatting","text":"<p>Each slice automatically receives a label positioned along its radius. The default format produces percentage values:</p> <pre><code>\"{label}: {percentage:.1f}%\"\n</code></pre> <p>You may fully override this via the <code>label_formatter</code> callback.</p>"},{"location":"diagram_types/pie_charts/#slice-colors","title":"Slice Colors","text":"<p>The list passed to <code>slice_colors</code> is cycled if fewer entries are provided than slices. Colors may be strings, <code>StandardColor</code>, or <code>ColorScheme</code> objects.</p>"},{"location":"diagram_types/pie_charts/#example-chart","title":"Example Chart","text":"<p>With additional formatting and color schemes, you can create a custom-styled chart:</p> <pre><code>chart = PieChart(\n    coffee_orders,\n    position=(100, 0),\n    size=350,\n    slice_colors=slice_colors,  # list of custom ColorScheme objects\n    title=chart_title,\n    title_text_format=title_format,\n    label_formatter=label_formatter,\n    background_color=\"#DBC5AF\",\n)\n</code></pre> <p>After optional customization, add the chart to a <code>Page</code> and save the <code>.drawio</code> file.</p> <p></p>"},{"location":"diagram_types/tree_diagrams/","title":"Tree Diagrams","text":"<p>These very useful diagram types are why drawpyo was written initially! The TreeDiagram module allows the easy creation of heirarchical directed trees, managing the tree parent and children relationships, then providing a convenient auto layout function.</p>"},{"location":"diagram_types/tree_diagrams/#create-a-tree","title":"Create a Tree","text":"<p>The two main objects to work with in drawpyo's trees are TreeDiagrams and NodeObjects. To start, create a TreeDiagram:</p> <pre><code>import drawpyo.diagram_types import TreeDiagram\n\ntree = TreeDiagram(\n    file_path = 'path/to/tree',\n    file_name = 'Tree Name.drawio',\n)\n</code></pre> <p>There are a number of configuration parameters available to fine tune the layout of the TreeDiagram. They can be passed in during initialization or later.</p> Parameter Effect Default direction direction that the tree grows from the root ('up', 'down', 'left', 'right') 'down' link_style Connection style of the edges ('orthogonal', 'straight', 'curved') 'orthogonal' level_spacing Spacing in pixels between levels 60 item_spacing Spacing in pixels between groups within a level 15 padding Spacing in pixels between objects within a group 10"},{"location":"diagram_types/tree_diagrams/#add-nodes","title":"Add Nodes","text":"<p>The custom object type that defines the nodes on the tree are called NodeObjects. Create some NodeObjects:</p> <pre><code>from drawpyo.diagram_types import NodeObject\n\n# Top object\ngrinders = NodeObject(tree=tree, value=\"Appliances for Grinding Coffee\", base_style=\"rounded rectangle\")\n\n# Main categories\nblade_grinders = NodeObject(tree=tree, value=\"Blade Grinders\", tree_parent=grinders)\nburr_grinders = NodeObject(tree=tree, value=\"Burr Grinders\", tree_parent=grinders)\nblunt_objects = NodeObject(tree=tree, value=\"Blunt Objects\", tree_parent=grinders)\n</code></pre> <p>Note that the base_style was manually declared for the first object. But NodeObjects will default to \"rounded rectangle\" so it's not necessary for every one. Any NodeObject can be a tree parent, so you can keep adding objects down the tree:</p> <pre><code># Other\nelec_blade = NodeObject(tree=tree, value=\"Electric Blade Grinder\", tree_parent=blade_grinders)\nmnp = NodeObject(tree=tree, value=\"Mortar and Pestle\", tree_parent=blunt_objects)\n\n# Conical Burrs\nconical = NodeObject(tree=tree, value=\"Conical Burrs\", tree_parent=burr_grinders)\nelec_conical = NodeObject(tree=tree, value=\"Electric\", tree_parent=conical)\nmanual_conical = NodeObject(tree=tree, value=\"Manual\", tree_parent=conical)\n</code></pre> <p>Important Note: TreeDiagrams do not currently support NodeObjects with multiple tree parents! It may not ever as this seriously complicates the auto layout process. However, you can add links between any two objects in the tree and render them in the diagram. They just may look ugly until you manually rearrange the diagram.</p> <p>Finally, before writing the diagram you'll want to run the magic penultimate step: auto layout.</p> <pre><code>tree.auto_layout()\ntree.write()\n</code></pre> <p>With some more additions, the resulting diagram renders as:</p> <p></p>"},{"location":"diagram_types/tree_diagrams/#create-a-tree-from-a-dictionary","title":"Create a Tree from a Dictionary","text":"<p><code>TreeDiagram</code> supports creating an entire tree structure directly from a nested dictionary or list. This allows you to generate trees programmatically without manually creating every <code>NodeObject</code>.</p>"},{"location":"diagram_types/tree_diagrams/#rules-for-dictlist-conversion","title":"Rules for dict/list conversion","text":"Input Type Behavior Dict Each key becomes a category node, and its value is recursively processed as its children. List / Tuple Each element becomes a sibling under the same parent. Scalar (<code>str</code>, <code>int</code>, <code>float</code>) Treated as a leaf node. Unsupported types Raises a <code>TypeError</code>."},{"location":"diagram_types/tree_diagrams/#coloring-nodes","title":"Coloring Nodes","text":"<p>You can control node colors using the <code>colors</code> list and <code>coloring</code> mode.</p> Parameter Description Options / Default <code>colors</code> List of <code>ColorScheme</code>, <code>StandardColor</code>, or color hex strings. Default: <code>None</code> <code>coloring</code> Method used to assign colors to nodes. <code>\"depth\"</code> (default), <code>\"hash\"</code>, <code>\"type\"</code> <p>Coloring Modes</p> Mode Description <code>depth</code> Colors nodes based on their depth in the tree. <code>hash</code> Colors nodes based on a hash of their value (stable across runs). <code>type</code> Colors nodes based on node type: category, list item, or leaf."},{"location":"diagram_types/tree_diagrams/#example","title":"Example","text":"<pre><code>from drawpyo.diagram_types import TreeDiagram\n\ndata = {\n    \"Root\": {\n        \"Branch A\": [\"Leaf 1\", \"Leaf 2\"],\n        \"Branch B\": [\"Leaf 3\"]\n    }\n}\n\ntree = TreeDiagram.from_dict(\n    data,\n    file_path=\"~/Test Drawpyo Charts\",\n    file_name=\"Minimal Tree.drawio\",\n    direction=\"down\",\n    colors=[\"#DDDDDD\",\"#BBBBBB\"],\n    coloring=\"depth\"\n)\n\ntree.write()\n</code></pre>"},{"location":"usage/basic_usage/","title":"Basic Functionality","text":"<p>Drawpyo's basic functionality provides the same features as using the Draw.io app. You can create files with one or more pages, add objects to them, and position those objects. You can style objects from built-in shape libraries, manually, or from style strings. Those objects can be shapes, containers, or edges to connect them. Finally you can save your diagrams where they can be opened with the Draw.io app.</p>"},{"location":"usage/basic_usage/#files","title":"Files","text":""},{"location":"usage/basic_usage/#make-a-new-file","title":"Make a new file","text":"<p>A File object represents a Draw.io file. If no file_path is set the default path will be 'user/Drawpyo Charts' where 'user' will be an OS-specific user home folder.</p> <pre><code>diagram = drawpyo.File()\nfile.file_path = r\"C:\\drawpyo\"\nfile.file_name = \"Test Generated Edges.drawio\"\n</code></pre>"},{"location":"usage/basic_usage/#write-a-file","title":"Write a file","text":"<p>Files can be written simply with the write() function. This function takes a few parameters to make it more flexible: | Parameter | Setting | | - | - | | <code>file_path</code> | This will overwrite the previously set file_path. | | <code>file_name</code> | This will overwrite the previously set file_name. Like file_path, useful in creating multiple copies of a diagram with slight variations | | <code>overwrite</code> | This boolean parameter controls whether an existing diagram should be overwritten or not. |</p>"},{"location":"usage/basic_usage/#pages","title":"Pages","text":""},{"location":"usage/basic_usage/#add-a-page","title":"Add a page","text":"<p>The Page object represents the different diagram pages that you can create in Draw.io. A Page can be created without linking it to a File but it won't be writable without a File object.</p> <pre><code># Add a page\npage = drawpy.Page(file=file)\n</code></pre>"},{"location":"usage/basic_usage/#page-parameters","title":"Page Parameters","text":"<p>There are a number of customizable parameter for pages:</p> argument description width Width of the document in pixels height Height of the document in pixels grid Enable grid (0 or 1) grid_size Side of grid squares in pixels guides Enable guides (0 or 1) tooltips Enable tooltips (0 or 1) scale Scale of the drawing"},{"location":"usage/color_management/","title":"Color Management","text":"<p>Drawpyo supports three ways to handle colors:</p> <ol> <li>Hex strings</li> <li>Standard colors - a built-in palette of named hex colors for easier access.</li> <li>Color schemes - a reusable object that groups fill, strokeand  font colors.</li> </ol>"},{"location":"usage/color_management/#standard-colors","title":"Standard Colors","text":"<p>Drawpyo includes a set of predefined colors exposed through the StandardColor enum. These match the standard Draw.io color palette and are arranged from lightest (1) to darkest (9) within each color family.</p> <pre><code>from drawpyo import StandardColor\n\nitem.fill_color = StandardColor.BLUE5\nitem.stroke_color = StandardColor.GRAY4\n</code></pre> <p>All values inside the enum are strings (e.g., <code>\"#007FFF\"</code>). When used inside a <code>ColorScheme</code>, enum values automatically resolve to their underlying hex string.</p> <p>Because the enum includes many shades, it provides a convenient palette for consistent styling across diagrams.</p>"},{"location":"usage/color_management/#color-schemes","title":"Color Schemes","text":"<p>A <code>ColorScheme</code> represents a small set of related colors used for an object's fill, stroke and font. Each color value may be:</p> <ul> <li><code>None</code></li> <li>a hex string of the form <code>#RRGGBB</code></li> <li>a <code>StandardColor</code> enum value</li> </ul> <pre><code>from drawpyo import ColorScheme, StandardColor\n\nscheme = ColorScheme(\n    fill_color=StandardColor.BLUE5,\n    stroke_color=\"#FF0000\",\n)\n</code></pre> <p>Invalid hex strings raise a <code>ValueError</code>.</p>"},{"location":"usage/color_management/#setting-colors","title":"Setting Colors","text":"<p>Each component may be updated after creation:</p> <pre><code>scheme.set_fill_color(\"#ABCDEF\")\nscheme.set_stroke_color(StandardColor.GRAY7)\nscheme.set_gradient(None)\n</code></pre>"},{"location":"usage/color_management/#color-hierarchy","title":"Color Hierarchy","text":"<p>When creating an object without specifying its colors  - or when explicitly passing <code>None</code> - Drawpyo applies a default value. Colors can come from three possible sources, and Drawpyo resolves them in the following order:</p>"},{"location":"usage/color_management/#1-object-specific-colors","title":"1. Object-specific colors","text":"<p>Colors provided directly to an object take the highest priority:</p> <ul> <li><code>fill_color</code></li> <li><code>stroke_color</code></li> <li><code>fontColor</code> (via an object\u2019s <code>text_format</code>)</li> </ul> <p>If these are set, they always override any color scheme applied to the object.</p>"},{"location":"usage/color_management/#2-color-scheme","title":"2. Color Scheme","text":"<p>If an object has a <code>ColorScheme</code> assigned and no object-specific color overrides it, its <code>fill_color</code>, <code>stroke_color</code> and <code>font_color</code> values are used.</p>"},{"location":"usage/color_management/#3-defaults","title":"3. Defaults","text":"<p>If neither object-specific colors nor a color scheme provide a value, Drawpyo falls back to the default colors used internally (e.g., Draw.io defaults).</p>"},{"location":"usage/color_management/#summary","title":"Summary","text":"<pre><code>Object-specific colors  &gt;  Color scheme colors  &gt;  Default colors\n</code></pre> <p>This hierarchy ensures that explicit styling always wins, while still allowing consistent themes via color schemes and reasonable defaults where nothing is specified.</p>"},{"location":"usage/edges/","title":"Edges","text":"<p>Edges are the lines and arrows that connect objects in Draw.io. There's quite a bit of variabiability in how they're created and styled so there's a bit more complexity than with objects.</p>"},{"location":"usage/edges/#creating-a-basic-edge","title":"Creating a basic edge","text":"<p>Like objects, there's a Edge object that can be easily created:</p> <pre><code>link = drawpyo.diagram.Edge(\n    page=page,\n    source=item_1,\n    target=item_2,\n    )\n</code></pre>"},{"location":"usage/edges/#edge-labels","title":"Edge Labels","text":"<p>The value of an edge is the label that appears on it. It can be set using the <code>label</code> value.</p> <p>The position of the label can be fine tuned with two parameters:</p> Parameter Effect <code>label_position</code> The position along the edge's axis where the label appears. This is float value between -1 and 1. 0 is neutral/in the center, -1 is at the source, and 1 is at the target. <code>label_offset</code> The offset in pixels perpendicular to the axis of the edge."},{"location":"usage/edges/#label-positions-rendered","title":"Label Positions Rendered","text":""},{"location":"usage/edges/#edge-geometry","title":"Edge Geometry","text":"<p>Besides the source and target, the edge geometry can be very finely tuned. There are eight parameters that control where and how the edge meets the source and target objects:</p> Parameter Definition <code>entryX</code> From where along the X axis on the source object the edge originates (0-1) <code>entryY</code> From where along the Y axis on the source object the edge originates (0-1) <code>entryDx</code> Applies an offset in pixels to the X axis entry point <code>entryDy</code> Applies an offset in pixels to the Y axis entry point <code>exitX</code> From where along the X axis on the target object the edge originates\u00a0(0-1) <code>exitY</code> From where along the Y axis on the target object the edge originates\u00a0(0-1) <code>exitDx</code> Applies an offset in pixels to the X axis exit point <code>exitDy</code> Applies an offset in pixels to the Y axis exit point <code>targetPerimeterSpacing</code> The negative or positive spacing between the target and end of the edge in points <code>sourcePerimeterSpacing</code> The negative or positive spacing between the source and end of the edge in points <p>If these parameters are set to <code>None</code> then the Draw.io rendering engine will place the origination and direction of the edge wherever makes the most sense based on the layout of the objects. This is the same as the behavior in the app when an edge is dragged to the center of a shape (highlighting the whole object green) instead of to a specific node on the border (and seeing just that node highlighted in green).</p> <p>They can also be set to X and Y coordinates designating where on the source and target objects the edge will meet it. The rest of the routing will be handled automatically.</p> <p></p> <p>Some examples of different coordinate settings:</p> <p></p> <p>Other attributes for controlling the general shape of the object are:</p> Parameter Definition <code>jettySize</code> Defines the length of the straight line coming out of or into an object before the edge makes its first turn"},{"location":"usage/edges/#points","title":"Points","text":"<p>You can also add points to Edges to further fine tune their routing. This isn't always necessary, usually setting the entry/exit parameters handles the auto routing correctly. However this is an option, using the <code>Edge.add_point()</code> and <code>Edge.add_point_pos()</code> functions. The edge will then route through those points but auto layout otherwise.</p>"},{"location":"usage/edges/#styling-edges","title":"Styling edges","text":"<p>Just about every edge styling option from the Draw.io app is implemented in Drawpyo. It's easiest to just play with all of the different line styling options in Draw.io to understand how they render but the major options are listed here.</p>"},{"location":"usage/edges/#text-styling","title":"Text Styling","text":"<p>The styling within an an edge label is contained inside of a <code>TextFormat</code> object. All styling parameters can be accessed at the attribute <code>Edge.text_format</code>, which contains a <code>TextFormat</code> object.</p> <p>For more information about styling text, see Formatting Text for more information.</p>"},{"location":"usage/edges/#color-and-shading","title":"Color and Shading","text":"<p>Edge coloring can be set with a stroke and fill color, though only the stroke applies to a simple edge.</p> Parameter Effect <code>opacity</code> The opacity of the edge (0-100) <code>strokeColor</code> The color of the edge or the stroke around the edge shape ('default', 'none', or a hex color code) <code>strokeWidth</code> The width of the edge or the stroke around the edge shape (1-999) <code>fillColor</code> The fill color of the edge shape\u00a0('default', 'none', or a hex color code)"},{"location":"usage/edges/#effects","title":"Effects","text":"<p>Draw.io has four effects that can be set on an edge. They're all boolean valuable that can be enabled.</p> Paramater Rendered default (None) <code>rounded</code> <code>shadow</code> <code>sketch</code> <code>flowAnimation</code>* <p>*(this animates in Draw.io)</p>"},{"location":"usage/edges/#jumps","title":"Jumps","text":"<p>By default, when an edge crosses another edge they'll just be rendered as a cross. You can also enable line jumps; the top edge will 'jump' over the bottom edge. There are different styles of line jumps and they can have variable sizes as well.</p> Parameter Effect <code>jumpStyle</code> The style of the line jump. Can be 'arc', 'gap', 'sharp', or 'line'. <code>jumpSize</code> The size of the rendered line jumps in points. <p>The different rendered jump styles are:</p> Parameter Rendered default (None) <code>arc</code> <code>gap</code> <code>sharp</code> <code>line</code>"},{"location":"usage/edges/#waypoints","title":"Waypoints","text":"<p>The <code>waypoint</code> parameter controls how the line is routed from the source to the target. For example, a straight line is just point to point. A curved line tries to maintain gentle curves and perpendicularity to the source and target objects. Options are:</p> Parameter Rendered default (None) <code>straight</code> <code>orthogonal</code> <code>vertical</code> <code>horizontal</code> <code>isometric</code> <code>isometric_vertical</code> <code>curved</code> <code>entity_relation</code>"},{"location":"usage/edges/#connections","title":"Connections","text":"<p>The <code>connection</code> parameter is abstractly named but it controls what type of edge this is. Most edges are lines but other types are available.</p> Parameter Rendered default (None) <code>line</code> <code>link</code> <code>arrow</code> <code>simple_arrow</code>"},{"location":"usage/edges/#patterns","title":"Patterns","text":"<p>The <code>pattern</code> parameter controls how the line stroke is rendered. Options are:</p> Parameter Rendered default (None) <code>solid</code> <code>dashed_small</code> <code>dashed_medium</code> <code>dashed_large</code> <code>dotted_small</code> <code>dotted_medium</code> <code>dotted_large</code>"},{"location":"usage/edges/#line-ends","title":"Line Ends","text":"<p>The <code>line_end_target</code> and <code>line_end_source</code> parameter sets whatever is rendered where the edge meets the objects. There are secondary boolean parameters for the fill of the ends (<code>endFill_target</code> and <code>endFill_source</code>) but not all ends can be filled.</p> <p>The line end size can also be adjusted with <code>endSize</code> and <code>startSize</code> parameters, both set in points.</p> Parameter Rendered Unfilled Rendered Filled default (None) na <code>classic</code> <code>classicThin</code> <code>open</code> na <code>openThin</code> na <code>openAsync</code> na <code>block</code> <code>blockThin</code> <code>async</code> <code>oval</code> <code>diamond</code> <code>diamondThin</code> <code>dash</code> na <code>halfCircle</code> na <code>cross</code> na <code>circlePlus</code> na <code>circle</code> na <code>baseDash</code> na <code>ERone</code> na <code>ERmandOne</code> na <code>ERmany</code> na <code>ERoneToMany</code> na <code>ERzeroToOne</code> na <code>ERzeroToMany</code> na <code>doubleBlock</code>"},{"location":"usage/extended_objects/","title":"Extended Objects","text":"<p>While any of the objects in Draw.io can be created by setting the correct combination of attributes it's not always convenient, particularly when an 'object' is actually a small group of objects. To offer a little more convenience drawpyo has extended objects. These inherit from the Object class but extend it with added functionality, though not quite to the level of the custom diagram types.</p> <p>There's only one extended object implemented now but there could be more in the future, either mirroring Draw.io functionality or new object types.</p>"},{"location":"usage/extended_objects/#list","title":"List","text":"<p>A list object is available in the General library in Draw.io. It's simple a small container object with a horizontal label filled with text objects as the list items. The Draw.io app conveniently keeps the list items positioned and in order as you add or remove, also scaling the size of the list container.</p> <p></p>"},{"location":"usage/extended_objects/#creating-a-list","title":"Creating a List","text":"<p>To create a list in drawpyo, use the <code>diagram.List</code> object.</p> <pre><code>new_list = drawpyo.diagram.List(title=\"List\", page=page, width=200)\n</code></pre> <p>Like any other Object, the position and geometry can be set during creation as well as various styling attributes.</p>"},{"location":"usage/extended_objects/#adding-items","title":"Adding Items","text":"<p>There are a few methods of adding items. The easiest would be using the <code>.add_item()</code> method.</p> <pre><code>new_list.add_item(\"item 1\")\nnew_list.add_item(\"item B\")\nnew_list.add_item(\"item iii\")\n</code></pre> <p>This will create a text object, set the List as its parent, position it correctly, and then resize the List object.</p> <p>You can also access the property <code>list_items</code>. It will return a list of strings denoting all the items in the list. But it also has a setter property, so setting it to a list of strings will remove existing items and then go through the creation and resizing process.</p>"},{"location":"usage/extended_objects/#deleting-items","title":"Deleting Items","text":"<p>The easiest way to delete an item is to call the <code>.remove_item()</code> method. Pass in the text of the item to remove and it will be strucken from the list then the list resized.</p> <pre><code>new_list.remove_item(\"item B\")\n</code></pre>"},{"location":"usage/extended_objects/#resizing-the-list","title":"Resizing the List","text":"<p>The list will be automatically resized to match the contents when the above methods are called. But the resize can also be called manually with the <code>.autosize()</code> method.</p>"},{"location":"usage/objects/","title":"Objects","text":"<p>Though some diagram types have their own object subclasses, the main class for creating objects is the Object class.</p>"},{"location":"usage/objects/#creating-a-basic-object","title":"Creating a basic object","text":"<pre><code>base_obj = drawpyo.diagram.Object(page=page)\n</code></pre> <p>The default object type is a rounded corner rectangle with white background and a black border just like in the Draw.io app.</p> <p></p> <p>The value attribute holds the text to display in the object.</p> <pre><code>base_obj.value = \"This Object's Name is Fred\"\n</code></pre> <p></p>"},{"location":"usage/objects/#creating-an-object-from-a-shape-library","title":"Creating an object from a shape library","text":"<p>Just like the built-in shape libraries in the Draw.io app, Drawpyo supports generating shapes from libraries. Currently the 'general' and 'flowchart' libraries from the Draw.io app is defined but more will be added in the future.</p> <p>These libraries are defined in TOML files and drawpyo supports importing custom shape libraries! See Shape Libraries for more information.</p> <p>To generate an object from a library:</p> <pre><code>object = drawpyo.diagram.object_from_library(\n    library=\"general\",\n    obj_name=\"process\",\n    page=page,\n    )\n</code></pre> <p>This function returns a normal Object but prestyled by the library. It can then be further styled or modified.</p>"},{"location":"usage/objects/#object-geometry","title":"Object Geometry","text":"<p>All objects contain a structure called ObjectGeometry that provides a layer of abstraction. Interacting directly with the geometry class is optional.</p>"},{"location":"usage/objects/#object-sizing","title":"Object Sizing","text":"<p>The three parameters that affect object placement are size and aspect. Size has to be set individually with the .width and .height attributes.</p> <pre><code>Object.width = 120\nObject.height = 80\nObject.aspect = 'fixed'\n</code></pre> <p>In earlier versions there was a 'size' attribute. But then it was found that 'size' was also used as a style attribute for certain shapes so the geometry size attribute was removed in favor of using width and height directly.</p>"},{"location":"usage/objects/#object-geometry-and-placement","title":"Object Geometry and Placement","text":"<p>Repositioning objects is simple but there are a few convenience features to know about. There are two attributes available for setting the position by either the top left corner or the center:</p> <pre><code>Object.position = (0, 0)\nObject.center_position = (0, 0)\n</code></pre> <p>The X and Y positions can also be accessed directly in the geometry object.</p> <pre><code>Object.geometry.x = 0\nObject.geometry.y = 0\n</code></pre>"},{"location":"usage/objects/#styling-objects","title":"Styling Objects","text":""},{"location":"usage/objects/#generating-from-a-style-string","title":"Generating from a style string","text":"<p>While styling an object from scratch in drawpyo is possible, you're probably using drawpyo because Draw.io exists and is a great UI so use it! The easiest workflow is to style objects in Draw.io, or at least play with the different parameters to understand how they'll render visually.</p> <p>Once you have an object styled in Draw.io how you like it, you can replicate the styling attributes you want manually or just copy the style string.</p> <p>To do this, first style an object as much as you want:</p> <p></p> <p>Then right click on the object and select 'Edit Style:'. The following pop-up will show the exact style string:</p> <p></p> <p>This style string can be copied into the drawpyo function <code>apply_style_string</code>:</p> <pre><code>style_str_obj = drawpyo.diagram.Object(page=page)\n\nstyle_str_obj.apply_style_string(\n    \"rounded=1;whiteSpace=wrap;html=1;fillColor=#dae8fc;strokeColor=#6c8ebf;gradientColor=#63B6FF;glass=1;strokeWidth=5;shadow=1;\"\n)\n</code></pre> <p>The <code>style_str_obj</code> will now have all of the custom styled attributes. It can also be used as a template object for others.</p>"},{"location":"usage/objects/#styling-manually","title":"Styling Manually","text":"<p>There are infinite permutations of object formatting and styling available. There are some higher order attributes that set the template for the object. What lower order styling attributes may or may not apply in combination. Then there are attributes like size and text formatting that apply in all cases. These interactions are difficult to predict in drawpyo alone so a good way to get familiar with all of the possible options and types of customizations is just to play with the Draw.io app directly to design formatting to your taste.</p> <p>Almost all styling attributes are optional (and drawpyo adds the non-optional ones automatically). If an attribute is unset or set to None then it won't be included in the file output. This will set that specific styling behavior to a default mode.</p>"},{"location":"usage/objects/#text-styling","title":"Text Styling","text":"<p>The styling within an object is contained inside of a <code>TextFormat</code> object. All styling parameters can be accessed at the attribute <code>Object.text_format</code>, which contains a <code>TextFormat</code> object.</p> <p>For more information about styling text, see Formatting Text for more information.</p>"},{"location":"usage/objects/#basestyle-and-shape","title":"BaseStyle and Shape","text":"<p>The highest order styling attribute in Draw.io for objects is <code>shape</code>. This sets how the object behaves and is rendered. Different values include:</p> <ul> <li>parallelogram</li> <li>shape</li> <li>process</li> <li>hexagon</li> <li>document</li> <li>cylinder3</li> <li>internalStorage</li> <li>cube</li> <li>step</li> <li>tape</li> <li>trapezoid</li> <li>note</li> <li>card</li> <li>callout</li> <li>dataStorage</li> </ul> <p>and many more.</p> <p>Confusingly there is another attribute called <code>baseStyle</code> that is sometimes used in combination with <code>shape</code> and sometimes without.</p> <p>BaseStyles include:</p> <ul> <li>text</li> <li>ellipse</li> <li>rhombus</li> <li>triangle</li> <li>swimlane</li> </ul> <p>It can be hard to predict how these two attributes will interact. To utilize them it's recommended to start in the Draw.io app, use their shape libraries or templates to get the desired style, then look at the style string to see what <code>shape</code> and <code>baseStyle</code> were used. When creating an object from a shape library these two attributes are handled automatically.</p>"},{"location":"usage/objects/#basic-styling-attributes","title":"Basic Styling Attributes","text":"<p>These attributes mostly apply to most shape/baseStyle combinations and can be set on almost any object.</p> <ul> <li>rounded</li> <li>fillColor</li> <li>strokeColor</li> <li>opacity</li> <li>whiteSpace</li> <li>glass</li> <li>shadow</li> <li>comic</li> <li>line_pattern</li> </ul>"},{"location":"usage/objects/#further-styling-attributes","title":"Further Styling Attributes","text":"<p>As mentioned above, not all of these attributes will apply to all object shapes and types. But some commonly called include:</p> <ul> <li>darkOpacity</li> <li>darkOpacity2</li> <li>backgroundOutline</li> <li>perimeter</li> </ul>"},{"location":"usage/parent_child_objects/","title":"Parent and Child Objects","text":"<p>In Draw.io, any object can have a parent. This is used within the app for containers and lists but actually any object can have subobjects. Within the XML this is achieved just be setting the <code>parent</code> attribute from <code>1</code> (the page) to any other object's ID. This changes the X and Y coordinates of the child object to be relative to the parent's X and Y coordinates.</p> <p>Drawpyo has convenient support for subobjects with a handful of attributes and parameters.</p>"},{"location":"usage/parent_child_objects/#linking-parent-and-child-objects","title":"Linking Parent and Child Objects","text":"<p>A parent object can be assigned to any subobject either during instantiation or after the fact by using the <code>parent</code> property. Every object has this property as well as a <code>children</code> property that's a list of other objects.</p> <p>Creating the parent object:</p> <pre><code>parent_container = drawpyo.diagram.object_from_library(\n    library=\"general\", obj_name=\"labeled_horizontal_container\", page=page\n)\n</code></pre> <p>Adding child objects:</p> <pre><code>block_1 = drawpyo.diagram.object_from_library(\n    library=\"general\", obj_name=\"rectangle\", page=page\n)\nblock_1.value = \"Block 1\"\nblock_1.parent = parent_container\n\nblock_2 = drawpyo.diagram.Object(\n    position_rel_to_parent=(300, 300), parent=parent_container, value=\"Block 2\", page=page\n)\n</code></pre> <p>There are also methods for adding and removing objects:</p> <pre><code>    parent_container.add_object(block_1)\n    parent_container.remove_object(block_2)\n</code></pre> <p>This will create or remove the link on both ends (set the parent attribute of the child object as well as add the child to the parents. These functions are called by the setters of the <code>parent</code> property, this is just an alternate syntax.</p>"},{"location":"usage/parent_child_objects/#positioning","title":"Positioning","text":"<p>Within the Draw.io application, child objects X and Y coordinates are relative to the parent object. This isn't always useful so drawpyo offers two different position attributes. Both are tuples of ints: (X, Y). They both modify or return the underlying Geometry object so they can be used interchangeably and are not duplicate variables.</p> <p>The normal <code>position</code> attribute continues to be relative to the page regardless of whether there's a parent object set.</p> <p>There is also a <code>position_rel_to_parent</code> attribute that will return the position with respect to the position of the parent.</p>"},{"location":"usage/parent_child_objects/#autosizing","title":"Autosizing","text":"<p>It's useful to have a parent object expand or contract to fit its objects. This behavior is disabled by default but can be enabled by setting the <code>autosize_to_children</code> boolean parameter to True. There is also a corresponding parameter called <code>autosize_margin</code> that sets the margin to maintain around the child objects in pixels. When this is set anytime that a child object is added, resized, or repositioned the parent will expand to fit the contents plus the margins. By default the parent will never contract unless <code>autocontract</code> is set to True as well.</p> <p>Note that the margin is inclusive of a container's title block.</p> <p>The autofit behavior can also be called manually using the <code>resize_to_children()</code> function on an object. This will respect the autofit_margin and autocontract behavior.</p>"},{"location":"usage/parent_child_objects/#combining-relative-positioning-and-autosizing","title":"Combining Relative Positioning and Autosizing","text":"<p>Combining the autosizing behavior with relative positioning can cause unexpected behavior. Since the parent object will resize every time a child object is added or moved within it the successive objects added will now be relative to a new updated parent object position. This will make your code order-dependent.</p> <p>To avoid this, either disable <code>autosize_to_children</code> or use absolute positioning for child objects.</p>"},{"location":"usage/shape_libs/","title":"Shape Libraries","text":"<p>The Draw.io app has a lot of built-in shape libraries available. The basic library contains shapes and building blocks but there are increasingly more specific libraries such as flowcharts, wiring diagrams, and org charts. You can also export and import shape libraries into Draw.io.</p> <p>To replicate this feature for drawpyo, I created a library format based on TOML. Draw.io's libraries are XML which isn't as human readable or writable and is more specification than necessary.</p> <p>Supporting Draw.io's XML based library is a planned feature.</p>"},{"location":"usage/shape_libs/#built-in-shape-libraries","title":"Built-In Shape Libraries","text":"<p>Drawpyo uses these TOML shape libraries to store the default libraries. The default libraries are in /drawpyo/shape_libraries. These are the libraries that are available in the Draw.io app.</p> <p>Implemented default libraries:</p> <ul> <li>General</li> <li>Flowchart</li> </ul> <p>There is also a set of TOML databases for other formats, like all of the various combinations of edge styles and the line styles. These are stored in /drawpyo/formatting_database.</p>"},{"location":"usage/shape_libs/#custom-shape-libraries","title":"Custom Shape Libraries","text":"<p>This functionality is available to the user so you can define your own custom libraries! TOML was selected because it's a very simple and human-readable config file format. the TOML project website has a very nice high level overview. But drawpyo is hardly scratching the surface of what TOML is capable of so little expertise is needed.</p>"},{"location":"usage/shape_libs/#creating-a-shape-library","title":"Creating a Shape Library","text":"<p>To define a shape library create a .toml file. Current convention is to start with a title tag for clarity.</p> <pre><code>title = \"Custom drawpyo shapes\"\n</code></pre> <p>You can then define a custom object by naming the object in square brackets and adding whichever attributes you want:</p> <pre><code>[square]\nwidth = 80\nheight = 80\naspect = \"fixed\"\n</code></pre> <p>You can also have any shape inherit another and then either modify or extend its style:</p> <pre><code>[perfect_circle]\ninherit = \"square\"\nbaseStyle = \"ellipse\"\n</code></pre> <p>This <code>perfect_circle</code> will now inherit the fixed aspect and size attributes from <code>square</code> but with the ellipse baseStyle.</p>"},{"location":"usage/shape_libs/#style-attribute-types","title":"Style Attribute Types","text":"<p>The attributes in the TOML file can come from three sets:</p>"},{"location":"usage/shape_libs/#drawpyo-attributes-snake_case","title":"Drawpyo attributes (snake_case)","text":"<p>These are the attributes that drawpyo uses to abstract some complicated style strings, such as <code>size</code> instead of the Draw.io parameters of <code>width</code> and <code>height</code>.</p>"},{"location":"usage/shape_libs/#predefined-style-attributes","title":"Predefined style attributes","text":"<p>Such as any of the attributes listed in the Styling section of Objects. These will simply be overwritten with the values in the TOML file.</p>"},{"location":"usage/shape_libs/#any-new-style-attributes","title":"Any new style attributes","text":"<p>If you want to add a rare style attribute that drawpyo hasn't defined or worked with yet, no worries! When you import the TOML library if there are new style attributes defined then they'll get added to the Object and exported into the Draw.io file.</p>"},{"location":"usage/shape_libs/#using-a-custom-library","title":"Using a Custom Library","text":"<p>To use a custom shape library it just needs to be imported then passed to the object definition function:</p> <pre><code>custom_library = drawpyo.diagram.import_shape_database(\n\u00a0\u00a0\u00a0\u00a0file_name=r\"path/to/toml_lib\"\n\u00a0\u00a0\u00a0\u00a0)\n\nnew_obj = drawpyo.diagram.object_from_library(\n    library = custom_library,\n    obj_name = 'object_name_from_lib',\n    page=page,\n    )\n</code></pre>"},{"location":"usage/text_format/","title":"Formatting Text","text":"<p>Everywhere that text appears in Draw.io has the same basic text formatting options. TO support this in drawpyo there's a custom class, <code>TextFormat</code>, that handles all of these options for code reusability. This also means that <code>TextFormat</code> objects can be created and copied into new objects or edges to make reformatting text convenient.</p> <p>Any object with formattable text will have a .text_format attribute that holds a <code>TextFormat</code> class.</p>"},{"location":"usage/text_format/#type-face-attributes","title":"Type Face Attributes","text":"Attribute Data Type Description <code>fontFamily</code> str The typeface to use. See Draw.io for a list of font choices. <code>fontSize</code> int The size of the font in points <code>fontColor</code> str The color of the typeface <code>bold</code> bool Bold font <code>italic</code> bool Italic font <code>underline</code> bool Underlined font <code>textShadow</code> bool Whether to place a shadow underneath the text <code>textOpacity</code> int The transparency level of the text. 0-100"},{"location":"usage/text_format/#text-alignment-and-spacing-attributes","title":"Text Alignment and Spacing Attributes","text":"<p>The text is rendered inside a box and various layout and alignment choices can be made to control where and how it's positioned.</p> Attribute Data Type Description <code>spacing</code> int The global spacing to add around the text and the outside of the bounding box <code>spacingTop</code> int The top spacing to add around the text <code>spacingBottom</code> int The bottom spacing to add around the text <code>spacingLeft</code> int The left spacing to add around the text <code>spacingRight</code> int The right spacing to add around the text <code>direction</code> str The direction to orient the text. Can be 'horizontal' or 'vertical' <code>align</code> str The horizontal alignment of the text. Can be 'left', 'center', or 'right' <code>verticalAlign</code> str The vertical alignment of the text. Can be 'top', 'middle', or 'bottom' <p>Spacing Attributes</p>"},{"location":"usage/text_format/#label-box-attributes","title":"Label Box Attributes","text":"<p>Some aspects of the text bounding box itself can also be formatted.</p> Attribute Data Type Description <code>labelBorderColor</code> str The color of the border around the bounding box <code>labelBackgroundColor</code> str The color of the fill of the bounding box <code>labelPosition</code> str The position of the bounding box as it relates to the owning object"}]}